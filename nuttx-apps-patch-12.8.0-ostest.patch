diff -Naur apps-12.8.0/audioutils/Kconfig apps/audioutils/Kconfig
--- apps-12.8.0/audioutils/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/audioutils/Kconfig	2025-11-04 11:04:40.942384665 +0200
@@ -0,0 +1,14 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Audio Utility libraries"
+source "/home/laur/lucru/rtos/apps/audioutils/fmsynth/Kconfig"
+source "/home/laur/lucru/rtos/apps/audioutils/lame/Kconfig"
+source "/home/laur/lucru/rtos/apps/audioutils/libmad/Kconfig"
+source "/home/laur/lucru/rtos/apps/audioutils/mml_parser/Kconfig"
+source "/home/laur/lucru/rtos/apps/audioutils/nxaudio/Kconfig"
+endmenu # Audio Utility libraries
diff -Naur apps-12.8.0/benchmarks/coremark/add_init_message.patch apps/benchmarks/coremark/add_init_message.patch
--- apps-12.8.0/benchmarks/coremark/add_init_message.patch	2025-01-24 11:45:01.769435567 +0200
+++ apps/benchmarks/coremark/add_init_message.patch	1970-01-01 02:00:00.000000000 +0200
@@ -1,12 +0,0 @@
---- coremark/posix/core_portme.c
-+++ coremark/posix/core_portme.c
-@@ -208,6 +208,9 @@ ee_u32 default_num_contexts = MULTITHREAD;
- void
- portable_init(core_portable *p, int *argc, char *argv[])
- {
-+
-+    ee_printf("Running CoreMark...\n");
-+
- #if PRINT_ARGS
-     int i;
-     for (i = 0; i < *argc; i++)
diff -Naur apps-12.8.0/benchmarks/coremark/CMakeLists.txt apps/benchmarks/coremark/CMakeLists.txt
--- apps-12.8.0/benchmarks/coremark/CMakeLists.txt	2025-01-24 11:45:01.768435630 +0200
+++ apps/benchmarks/coremark/CMakeLists.txt	1970-01-01 02:00:00.000000000 +0200
@@ -1,153 +0,0 @@
-# ##############################################################################
-# apps/benchmarks/coremark/CMakeLists.txt
-#
-# SPDX-License-Identifier: Apache-2.0
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more contributor
-# license agreements.  See the NOTICE file distributed with this work for
-# additional information regarding copyright ownership.  The ASF licenses this
-# file to you under the Apache License, Version 2.0 (the "License"); you may not
-# use this file except in compliance with the License.  You may obtain a copy of
-# the License at
-#
-# http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
-# License for the specific language governing permissions and limitations under
-# the License.
-#
-# ##############################################################################
-
-if(CONFIG_BENCHMARK_COREMARK)
-
-  # ############################################################################
-  # Config and Fetch Coremark application
-  # ############################################################################
-
-  set(COREMARKAPP_DIR ${CMAKE_CURRENT_LIST_DIR}/coremark)
-
-  if(NOT EXISTS ${COREMARKAPP_DIR})
-    FetchContent_Declare(
-      coremark_fetch
-      URL https://github.com/eembc/coremark/archive/main.zip SOURCE_DIR
-          ${CMAKE_CURRENT_LIST_DIR}/coremark BINARY_DIR
-          ${CMAKE_BINARY_DIR}/apps/benchmarks/coremark/coremark
-      DOWNLOAD_NO_PROGRESS true
-      TIMEOUT 30)
-
-    FetchContent_GetProperties(coremark_fetch)
-    if(NOT coremark_fetch_POPULATED)
-      FetchContent_Populate(coremark_fetch)
-    endif()
-  endif()
-
-  if(CONFIG_COREMARK_MULTITHREAD_OVERRIDE)
-    set(COREMARK_NTHREADS ${CONFIG_COREMARK_MULTITHREAD_COUNT})
-  endif()
-
-  if(CONFIG_SMP_NCPUS)
-    set(COREMARK_NTHREADS ${CONFIG_SMP_NCPUS})
-  else()
-    set(COREMARK_NTHREADS 1)
-  endif()
-
-  if(CONFIG_COREMARK_PRINT_ARGS)
-    set(COREMARK_PRINT_ARGS 1)
-  else()
-    set(COREMARK_PRINT_ARGS 0)
-  endif()
-
-  # ############################################################################
-  # Flags
-  # ############################################################################
-
-  if(CONFIG_COREMARK_MULTITHREAD_OVERRIDE)
-    set(COREMARK_NTHREADS ${CONFIG_COREMARK_MULTITHREAD_COUNT})
-  else()
-    if(CONFIG_SMP_NCPUS)
-      set(COREMARK_NTHREADS ${CONFIG_SMP_NCPUS})
-    else()
-      set(COREMARK_NTHREADS 1)
-    endif()
-  endif()
-
-  if(CONFIG_COREMARK_PRINT_ARGS)
-    set(COREMARK_PRINT_ARGS 1)
-  else()
-    set(COREMARK_PRINT_ARGS 0)
-  endif()
-
-  get_target_property(FLAGS_STR_LIST nuttx COMPILE_OPTIONS)
-  list(JOIN FLAGS_STR_LIST " " FLAGS_STR)
-
-  set(CFLAGS -Dcrc16=coremark_crc16 -Wno-strict-prototypes -Wno-undef)
-
-  if("${CONFIG_COREMARK_MEM_METHOD}" STREQUAL "1")
-    list(APPEND CFLAGS -DMEM_LOCATION=\"HEAP\")
-  elseif("${CONFIG_COREMARK_MEM_METHOD}" STREQUAL "2")
-    list(APPEND CFLAGS -DMEM_LOCATION=\"STACK\")
-  else()
-    list(APPEND CFLAGS -DMEM_LOCATION=\"GLOBAL\")
-  endif()
-
-  list(
-    APPEND
-    CFLAGS
-    -DCALLGRIND_RUN=0
-    -DCOMPILER_REQUIRES_SORT_RETURN=0
-    -DCORE_DEBUG=${CONFIG_COREMARK_DEBUG}
-    -DFLAGS_STR="${FLAGS_STR}"
-    -DMEM_METHOD=${CONFIG_COREMARK_MEM_METHOD}
-    -DMICA=0
-    -DMULTITHREAD=${COREMARK_NTHREADS}
-    -DPERFORMANCE_RUN=1
-    -DPRINT_ARGS=${COREMARK_PRINT_ARGS}
-    -DSEED_METHOD=${CONFIG_COREMARK_SEED_METHOD}
-    -DUSE_CLOCK=1
-    -DUSE_PTHREAD)
-
-  if(CONFIG_COREMARK_ITERATIONS_OVERRIDE)
-    list(APPEND CFLAGS -DITERATIONS=${CONFIG_COREMARK_ITERATIONS_COUNT})
-  else()
-    list(APPEND CFLAGS -DITERATIONS=0)
-
-  endif()
-
-  # ############################################################################
-  # Sources
-  # ############################################################################
-
-  set(CSRCS
-      ${COREMARKAPP_DIR}/core_main.c ${COREMARKAPP_DIR}/core_list_join.c
-      ${COREMARKAPP_DIR}/core_matrix.c ${COREMARKAPP_DIR}/core_state.c
-      ${COREMARKAPP_DIR}/core_util.c ${COREMARKAPP_DIR}/posix/core_portme.c)
-
-  # ############################################################################
-  # Include Directory
-  # ############################################################################
-
-  set(INCDIR ${COREMARKAPP_DIR} ${COREMARKAPP_DIR}/posix)
-
-  # ############################################################################
-  # Applications Configuration
-  # ############################################################################
-
-  nuttx_add_application(
-    NAME
-    ${CONFIG_COREMARK_PROGNAME}
-    PRIORITY
-    ${CONFIG_COREMARK_PRIORITY}
-    STACKSIZE
-    ${CONFIG_COREMARK_STACKSIZE}
-    MODULE
-    ${CONFIG_BENCHMARK_COREMARK}
-    COMPILE_FLAGS
-    ${CFLAGS}
-    SRCS
-    ${CSRCS}
-    INCLUDE_DIRECTORIES
-    ${INCDIR})
-
-endif()
diff -Naur apps-12.8.0/benchmarks/coremark/Kconfig apps/benchmarks/coremark/Kconfig
--- apps-12.8.0/benchmarks/coremark/Kconfig	2025-01-24 11:45:01.769435567 +0200
+++ apps/benchmarks/coremark/Kconfig	1970-01-01 02:00:00.000000000 +0200
@@ -1,86 +0,0 @@
-#
-# For a description of the syntax of this configuration file,
-# see the file kconfig-language.txt in the NuttX tools repository.
-#
-
-menuconfig BENCHMARK_COREMARK
-	tristate "CoreMark Benchmark"
-	select LIBC_FLOATINGPOINT
-	default n
-	---help---
-		Enable support for the EEMBC's CoreMark benchmark application.
-
-if BENCHMARK_COREMARK
-
-config COREMARK_PROGNAME
-	string "CoreMark program name"
-	default "coremark"
-	---help---
-		This is the name of the program that will be used when the NSH ELF
-		program is installed.
-
-config COREMARK_PRIORITY
-	int "CoreMark task priority"
-	default 100
-
-config COREMARK_STACKSIZE
-	int "CoreMark task stack size"
-	default 4096
-
-config COREMARK_SEED_METHOD
-	int "Coremark Seed Method"
-	default 2
-	---help---
-		Set Coremark Seed Method:
-		0: SEED_ARG
-		1: SEED_FUNC
-		2: SEED_VOLATILE
-
-config COREMARK_MEM_METHOD
-	int "Coremark Memory Method"
-	default 1
-	---help---
-		Set Coremark Memory Method:
-		0: MEM_STATIC
-		1: MEM_MALLOC
-		2: MEM_STACK
-
-config COREMARK_DEBUG
-	int "Coremark Core Debug"
-	default 0
-	---help---
-		Enable the Core Debug:
-		0: Disable
-		1: Enable
-
-config COREMARK_PRINT_ARGS
-	bool "Print CoreMark arguments when executing"
-	default n
-	---help---
-		Print the command line arguments passed on to coremark.
-
-config COREMARK_MULTITHREAD_OVERRIDE
-	bool "Override number of threads"
-	default n
-	---help---
-		Override the default number of threads to be executed.
-		The default value is the same as the number of CPU cores.
-
-config COREMARK_MULTITHREAD_COUNT
-	depends on COREMARK_MULTITHREAD_OVERRIDE
-	int "Number of threads to be executed"
-	default 1
-
-config COREMARK_ITERATIONS_OVERRIDE
-	bool "Override number of iterations"
-	default n
-	---help---
-		Override the default number of iterations for the benchmark.
-		The default value is defined by the application based on the system.
-
-config COREMARK_ITERATIONS_COUNT
-	depends on COREMARK_ITERATIONS_OVERRIDE
-	int "Number of iterations"
-	default 100
-
-endif # BENCHMARK_COREMARK
diff -Naur apps-12.8.0/benchmarks/coremark/Make.defs apps/benchmarks/coremark/Make.defs
--- apps-12.8.0/benchmarks/coremark/Make.defs	2025-01-24 11:45:01.768435630 +0200
+++ apps/benchmarks/coremark/Make.defs	1970-01-01 02:00:00.000000000 +0200
@@ -1,27 +0,0 @@
-############################################################################
-# apps/benchmarks/coremark/Make.defs
-#
-# SPDX-License-Identifier: Apache-2.0
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.  The
-# ASF licenses this file to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance with the
-# License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
-# License for the specific language governing permissions and limitations
-# under the License.
-#
-############################################################################
-
-ifneq ($(CONFIG_BENCHMARK_COREMARK),)
-CONFIGURED_APPS += $(APPDIR)/benchmarks/coremark
-CFLAGS += ${INCDIR_PREFIX}$(APPDIR)/benchmarks/coremark/coremark
-CFLAGS += ${INCDIR_PREFIX}$(APPDIR)/benchmarks/coremark/coremark/posix
-endif
diff -Naur apps-12.8.0/benchmarks/coremark/Makefile apps/benchmarks/coremark/Makefile
--- apps-12.8.0/benchmarks/coremark/Makefile	2025-01-24 11:45:01.768435630 +0200
+++ apps/benchmarks/coremark/Makefile	1970-01-01 02:00:00.000000000 +0200
@@ -1,145 +0,0 @@
-############################################################################
-# apps/benchmarks/coremark/Makefile
-#
-# SPDX-License-Identifier: Apache-2.0
-#
-# Licensed to the Apache Software Foundation (ASF) under one or more
-# contributor license agreements.  See the NOTICE file distributed with
-# this work for additional information regarding copyright ownership.  The
-# ASF licenses this file to you under the Apache License, Version 2.0 (the
-# "License"); you may not use this file except in compliance with the
-# License.  You may obtain a copy of the License at
-#
-#   http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
-# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
-# License for the specific language governing permissions and limitations
-# under the License.
-#
-############################################################################
-
-include $(APPDIR)/Make.defs
-
-# Coremark application
-
-############################################################################
-# Flags
-############################################################################
-
-COREMARK_URL ?= "https://github.com/eembc/coremark/archive"
-
-COREMARK_VERSION = main
-COREMARK_ZIP = $(COREMARK_VERSION).zip
-
-COREMARK_UNPACKNAME = coremark
-UNPACK ?= unzip -q -o
-
-VPATH += $(COREMARK_UNPACKNAME)
-VPATH += $(COREMARK_UNPACKNAME)$(DELIM)posix
-DEPPATH += --dep-path $(COREMARK_UNPACKNAME)
-DEPPATH += --dep-path $(COREMARK_UNPACKNAME)$(DELIM)posix
-
-CFLAGS += -Dcrc16=coremark_crc16
-CFLAGS += -Wno-strict-prototypes -Wno-undef
-
-ifeq ($(CONFIG_COREMARK_MULTITHREAD_OVERRIDE),y)
-COREMARK_NTHREADS = $(CONFIG_COREMARK_MULTITHREAD_COUNT)
-else
-ifneq ($(CONFIG_SMP_NCPUS),)
-COREMARK_NTHREADS = $(CONFIG_SMP_NCPUS)
-else
-COREMARK_NTHREADS = 1
-endif
-endif
-
-ifeq ($(CONFIG_COREMARK_PRINT_ARGS),y)
-COREMARK_PRINT_ARGS = 1
-else
-COREMARK_PRINT_ARGS = 0
-endif
-
-ifeq ($(CONFIG_COREMARK_MEM_METHOD), 1)
-CFLAGS += ${DEFINE_PREFIX}MEM_LOCATION=\"HEAP\"
-else ifeq ($(CONFIG_COREMARK_MEM_METHOD), 2)
-CFLAGS += ${DEFINE_PREFIX}MEM_LOCATION=\"STACK\"
-else
-CFLAGS += ${DEFINE_PREFIX}MEM_LOCATION=\"GLOBAL\"
-endif
-
-CFLAGS += ${DEFINE_PREFIX}CALLGRIND_RUN=0
-CFLAGS += ${DEFINE_PREFIX}COMPILER_REQUIRES_SORT_RETURN=0
-CFLAGS += ${DEFINE_PREFIX}CORE_DEBUG=$(CONFIG_COREMARK_DEBUG)
-CFLAGS += ${DEFINE_PREFIX}FLAGS_STR=\""$(ARCHOPTIMIZATION)\""
-CFLAGS += ${DEFINE_PREFIX}MEM_METHOD=$(CONFIG_COREMARK_MEM_METHOD)
-CFLAGS += ${DEFINE_PREFIX}MICA=0
-CFLAGS += ${DEFINE_PREFIX}MULTITHREAD=$(COREMARK_NTHREADS)
-CFLAGS += ${DEFINE_PREFIX}PERFORMANCE_RUN=1
-CFLAGS += ${DEFINE_PREFIX}PRINT_ARGS=$(COREMARK_PRINT_ARGS)
-CFLAGS += ${DEFINE_PREFIX}SEED_METHOD=$(CONFIG_COREMARK_SEED_METHOD)
-CFLAGS += ${DEFINE_PREFIX}USE_CLOCK=1
-CFLAGS += ${DEFINE_PREFIX}USE_PTHREAD
-
-ifeq ($(CONFIG_COREMARK_ITERATIONS_OVERRIDE),y)
-CFLAGS += ${DEFINE_PREFIX}ITERATIONS=$(CONFIG_COREMARK_ITERATIONS_COUNT)
-else
-CFLAGS += ${DEFINE_PREFIX}ITERATIONS=0
-endif
-
-CFLAGS += ${DEFINE_PREFIX}crcu8=coremark_crcu8
-CFLAGS += ${DEFINE_PREFIX}crcu16=coremark_crcu16
-CFLAGS += ${DEFINE_PREFIX}crcu32=coremark_crcu32
-CFLAGS += ${DEFINE_PREFIX}crc16=coremark_crc16
-
-CSRCS += core_list_join.c
-CSRCS += core_matrix.c
-CSRCS += core_state.c
-CSRCS += core_util.c
-CSRCS += core_portme.c
-
-############################################################################
-# Targets
-############################################################################
-
-$(COREMARK_ZIP):
-	@echo "Downloading: $(COREMARK_URL)/$(COREMARK_ZIP)"
-	$(Q) curl -O -L $(COREMARK_URL)/$(COREMARK_ZIP)
-
-$(COREMARK_UNPACKNAME): $(COREMARK_ZIP)
-	@echo "Unpacking: $(COREMARK_ZIP) -> $(COREMARK_UNPACKNAME)"
-	$(Q) $(UNPACK) $(COREMARK_ZIP)
-	$(Q) mv	coremark-$(COREMARK_VERSION) $(COREMARK_UNPACKNAME)
-	$(Q) patch -p0 < add_init_message.patch # Update init message
-	$(Q) touch $(COREMARK_UNPACKNAME)
-
-clean::
-	$(call DELFILE, $(OBJS))
-
-# Download and unpack tarball if no git repo found
-
-ifeq ($(wildcard $(COREMARK_UNPACKNAME)/.git),)
-context:: $(COREMARK_UNPACKNAME)
-
-distclean::
-	$(call DELDIR, $(COREMARK_UNPACKNAME))
-	$(call DELFILE, $(COREMARK_ZIP))
-endif
-
-############################################################################
-# Applications Configuration
-############################################################################
-
-MODULE = $(CONFIG_BENCHMARK_COREMARK)
-
-PROGNAME  += $(CONFIG_COREMARK_PROGNAME)
-PRIORITY  += $(CONFIG_COREMARK_PRIORITY)
-STACKSIZE += $(CONFIG_COREMARK_STACKSIZE)
-
-MAINSRC += core_main.c
-
-# Build with WebAssembly when CONFIG_INTERPRETERS_WAMR is enabled
-
-WASM_BUILD = both
-
-include $(APPDIR)/Application.mk
diff -Naur apps-12.8.0/benchmarks/Kconfig apps/benchmarks/Kconfig
--- apps-12.8.0/benchmarks/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/benchmarks/Kconfig	2025-11-04 11:04:40.715520524 +0200
@@ -0,0 +1,23 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Benchmark Applications"
+source "/home/laur/lucru/rtos/apps/benchmarks/cachespeed/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/coremark/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/coremark-pro/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/dhrystone/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/fio/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/iozone/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/osperf/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/ramspeed/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/rt-tests/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/spinlock_bench/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/superpi/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/tacle-bench/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/test-tlb/Kconfig"
+source "/home/laur/lucru/rtos/apps/benchmarks/tinymembench/Kconfig"
+endmenu # Benchmark Applications
diff -Naur apps-12.8.0/boot/Kconfig apps/boot/Kconfig
--- apps-12.8.0/boot/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/boot/Kconfig	2025-11-04 11:04:39.978962029 +0200
@@ -0,0 +1,12 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Bootloader Utilities"
+source "/home/laur/lucru/rtos/apps/boot/mcuboot/Kconfig"
+source "/home/laur/lucru/rtos/apps/boot/miniboot/Kconfig"
+source "/home/laur/lucru/rtos/apps/boot/nxboot/Kconfig"
+endmenu # Bootloader Utilities
diff -Naur apps-12.8.0/builtin/Make.dep apps/builtin/Make.dep
--- apps-12.8.0/builtin/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/Make.dep	2025-11-05 16:00:05.090655847 +0200
@@ -0,0 +1,49 @@
+# Gen Make.dep automatically
+builtin_list.c.home.laur.lucru.rtos.apps.builtin.o: builtin_list.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/builtin.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/param.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h builtin_proto.h \
+ builtin_list.h
+exec_builtin.c.home.laur.lucru.rtos.apps.builtin.o: exec_builtin.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/apps/include/builtin/builtin.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/builtin.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/builtin/registry/coremark.bdat apps/builtin/registry/coremark.bdat
--- apps-12.8.0/builtin/registry/coremark.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/coremark.bdat	2025-11-04 11:04:40.957375688 +0200
@@ -0,0 +1 @@
+{ "coremark", 100, 4096, coremark_main },
diff -Naur apps-12.8.0/builtin/registry/coremark.pdat apps/builtin/registry/coremark.pdat
--- apps-12.8.0/builtin/registry/coremark.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/coremark.pdat	2025-11-04 11:04:40.957375688 +0200
@@ -0,0 +1 @@
+int coremark_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/builtin/registry/getprime.bdat apps/builtin/registry/getprime.bdat
--- apps-12.8.0/builtin/registry/getprime.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/getprime.bdat	2025-11-04 11:09:44.300632045 +0200
@@ -0,0 +1 @@
+{ "getprime", 50, 2048, getprime_main },
diff -Naur apps-12.8.0/builtin/registry/getprime.pdat apps/builtin/registry/getprime.pdat
--- apps-12.8.0/builtin/registry/getprime.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/getprime.pdat	2025-11-04 11:09:44.302629992 +0200
@@ -0,0 +1 @@
+int getprime_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/builtin/registry/hello.bdat apps/builtin/registry/hello.bdat
--- apps-12.8.0/builtin/registry/hello.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/hello.bdat	2025-11-04 11:09:43.766192641 +0200
@@ -0,0 +1 @@
+{ "hello", 100, 2048, hello_main },
diff -Naur apps-12.8.0/builtin/registry/hello.pdat apps/builtin/registry/hello.pdat
--- apps-12.8.0/builtin/registry/hello.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/hello.pdat	2025-11-04 11:09:43.769189415 +0200
@@ -0,0 +1 @@
+int hello_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/builtin/registry/mount.bdat apps/builtin/registry/mount.bdat
--- apps-12.8.0/builtin/registry/mount.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/mount.bdat	2025-11-04 11:09:43.857094779 +0200
@@ -0,0 +1 @@
+{ "mount", SCHED_PRIORITY_DEFAULT, 2048, mount_main },
diff -Naur apps-12.8.0/builtin/registry/mount.pdat apps/builtin/registry/mount.pdat
--- apps-12.8.0/builtin/registry/mount.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/mount.pdat	2025-11-04 11:09:43.860091552 +0200
@@ -0,0 +1 @@
+int mount_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/builtin/registry/nsh.bdat apps/builtin/registry/nsh.bdat
--- apps-12.8.0/builtin/registry/nsh.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/nsh.bdat	2025-11-04 11:09:44.139797262 +0200
@@ -0,0 +1 @@
+{ "nsh", 100, 2048, nsh_main },
diff -Naur apps-12.8.0/builtin/registry/nsh.pdat apps/builtin/registry/nsh.pdat
--- apps-12.8.0/builtin/registry/nsh.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/nsh.pdat	2025-11-04 11:09:44.142794183 +0200
@@ -0,0 +1 @@
+int nsh_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/builtin/registry/ostest.bdat apps/builtin/registry/ostest.bdat
--- apps-12.8.0/builtin/registry/ostest.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/ostest.bdat	2025-11-04 11:09:44.384545845 +0200
@@ -0,0 +1 @@
+{ "ostest", SCHED_PRIORITY_DEFAULT, 2048, ostest_main },
diff -Naur apps-12.8.0/builtin/registry/ostest.pdat apps/builtin/registry/ostest.pdat
--- apps-12.8.0/builtin/registry/ostest.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/ostest.pdat	2025-11-04 11:09:44.387542766 +0200
@@ -0,0 +1 @@
+int ostest_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/builtin/registry/sh.bdat apps/builtin/registry/sh.bdat
--- apps-12.8.0/builtin/registry/sh.bdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/sh.bdat	2025-11-04 11:09:44.150785974 +0200
@@ -0,0 +1 @@
+{ "sh", 100, 2048, sh_main },
diff -Naur apps-12.8.0/builtin/registry/sh.pdat apps/builtin/registry/sh.pdat
--- apps-12.8.0/builtin/registry/sh.pdat	1970-01-01 02:00:00.000000000 +0200
+++ apps/builtin/registry/sh.pdat	2025-11-04 11:09:44.152783921 +0200
@@ -0,0 +1 @@
+int sh_main(int argc, char *argv[]);
diff -Naur apps-12.8.0/canutils/Kconfig apps/canutils/Kconfig
--- apps-12.8.0/canutils/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/canutils/Kconfig	2025-11-04 11:04:40.736507956 +0200
@@ -0,0 +1,18 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "CAN Utilities"
+source "/home/laur/lucru/rtos/apps/canutils/candump/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/canlib/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/cansend/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/lely-canopen/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/libcanutils/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/libdronecan/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/libobd2/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/libopencyphal/Kconfig"
+source "/home/laur/lucru/rtos/apps/canutils/slcan/Kconfig"
+endmenu # CAN Utilities
diff -Naur apps-12.8.0/crypto/Kconfig apps/crypto/Kconfig
--- apps-12.8.0/crypto/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/crypto/Kconfig	2025-11-04 11:04:40.056914934 +0200
@@ -0,0 +1,17 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Cryptography Library Support"
+source "/home/laur/lucru/rtos/apps/crypto/controlse/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/libsodium/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/libtomcrypt/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/mbedtls/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/openssl_mbedtls_wrapper/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/tinycrypt/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/tinydtls/Kconfig"
+source "/home/laur/lucru/rtos/apps/crypto/wolfssl/Kconfig"
+endmenu # Cryptography Library Support
diff -Naur apps-12.8.0/database/Kconfig apps/database/Kconfig
--- apps-12.8.0/database/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/database/Kconfig	2025-11-04 11:04:40.921397234 +0200
@@ -0,0 +1,10 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Database"
+source "/home/laur/lucru/rtos/apps/database/sqlite/Kconfig"
+endmenu # Database
diff -Naur apps-12.8.0/examples/hello/Make.dep apps/examples/hello/Make.dep
--- apps-12.8.0/examples/hello/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/examples/hello/Make.dep	2025-11-05 16:00:05.221601754 +0200
@@ -0,0 +1,58 @@
+# Gen Make.dep automatically
+hello_main.c.home.laur.lucru.rtos.apps.examples.hello.o: hello_main.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/examples/Kconfig apps/examples/Kconfig
--- apps-12.8.0/examples/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/examples/Kconfig	2025-11-04 11:04:40.579601920 +0200
@@ -0,0 +1,210 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Examples"
+source "/home/laur/lucru/rtos/apps/examples/abntcodi/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/adc/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/adjtime/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/adxl372_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ajoystick/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/alarm/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/amg88xx/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/apa102/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/apds9960/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/audio_rttl/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/bastest/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/battery/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ble/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/bme680/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/bmi160/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/bmp180/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/bmp280/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/bridge/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/buttons/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/calib_udelay/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/camera/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/can/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/capture/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/cbortest/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/cctype/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/charger/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/chat/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/chrono/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/configdata/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/cordic/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/cpuhog/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/cromfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/dac/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/dhcpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/dhtxx/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/discover/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/djoystick/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/dronecan/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/elf/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/embedlog/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/esp32_himem/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/etl/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/fb/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/fboverlay/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/flash_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/flowc/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/fmsynth/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/foc/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ft80x/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ftpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ftpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/fxos8700cq_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/gpio/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/gps/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hall/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hdc1008_demo/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello_d/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello_nim/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello_rust/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello_swift/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello_wasm/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/helloxx/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hello_zig/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hidkbd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hts221_reader/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/hx711/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/i2schar/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/i2sloop/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/igmp/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ina219/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ina226/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ini_dumper/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ipcfg/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ipforward/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/isl29023/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/json/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/keyboard/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/leds/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/leds_rust/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/leds_zig/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/libtest/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lis3dsh_reader/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lp503x/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lsm303_reader/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lsm330spi_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lsm6dsl_reader/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ltr308/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lua_module/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lvgldemo/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/lvglterm/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/max31855/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mcuboot/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/media/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mld/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mlx90614/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mml_parser/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/modbus/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/modbusmaster/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/module/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mount/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mqttc/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mtdpart/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mtdrwb/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/netlink_route/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/netloop/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/netpkt/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nettest/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nimble/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nng_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/noteprintf/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nrf24l01_btle/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nrf24l01_term/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/null/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nunchuck/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxdemo/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxflat/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxhello/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nximage/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nx/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxlines/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxscope/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxterm/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/nxtext/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/obd2/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/oneshot/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/opencyphal/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pca9635/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pdcurses/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pf_ieee802154/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pipe/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/poll/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/popen/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/posix_spawn/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/powerled/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/powermonitor/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pppd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pty_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pwfb/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pwlines/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/pwm/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/qencoder/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/random/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/relays/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/rfid_readuid/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/rgbled/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/rmtchar/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/romfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/rpmsgsocket/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/scd41/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sendmail/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sensor_fusion/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/serialblaster/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/serialrx/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/serloop/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/settings/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/shm_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sht3x/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/slcd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/smps/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sotest/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/spislv_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/stat/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/stepper/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sx127x_demo/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/system/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/tcpblaster/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/tcpecho/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/tcp_ipc_client/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/tcp_ipc_server/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/telnetd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/termios/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/thttpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/tiff/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/timer_gpio/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/timer/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/tlpi/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/touchscreen/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/udgram/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/udpblaster/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/udp/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/uid/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/unionfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/usbserial/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/userfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/usrsocktest/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ustream/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/veml6070/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/wamr_module/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/watchdog/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/watched/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/watcher/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/webserver/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/wgetjson/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/wget/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/wiegand/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ws2812esp32rmt/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/ws2812/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/xbc_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/xmlrpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/zerocross/Kconfig"
+endmenu # Examples
diff -Naur apps-12.8.0/examples/mcuboot/Kconfig apps/examples/mcuboot/Kconfig
--- apps-12.8.0/examples/mcuboot/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/examples/mcuboot/Kconfig	2025-11-04 11:04:40.314760522 +0200
@@ -0,0 +1,12 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "MCUboot Examples"
+source "/home/laur/lucru/rtos/apps/examples/mcuboot/slot_confirm/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mcuboot/swap_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/mcuboot/update_agent/Kconfig"
+endmenu # MCUboot Examples
diff -Naur apps-12.8.0/examples/module/Kconfig apps/examples/module/Kconfig
--- apps-12.8.0/examples/module/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/examples/module/Kconfig	2025-11-04 11:04:40.154856282 +0200
@@ -0,0 +1,11 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Module example"
+source "/home/laur/lucru/rtos/apps/examples/module/chardev/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/module/main/Kconfig"
+endmenu # Module example
diff -Naur apps-12.8.0/examples/mount/Make.dep apps/examples/mount/Make.dep
--- apps-12.8.0/examples/mount/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/examples/mount/Make.dep	2025-11-05 16:00:05.378536924 +0200
@@ -0,0 +1,125 @@
+# Gen Make.dep automatically
+ramdisk.c.home.laur.lucru.rtos.apps.examples.mount.o: ramdisk.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/boardctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/drivers/ramdisk.h \
+ /home/laur/lucru/rtos/apps/include/fsutils/mkfatfs.h mount.h
+mount_main.c.home.laur.lucru.rtos.apps.examples.mount.o: mount_main.c \
+ /home/laur/lucru/rtos/nuttx/include/sys/mount.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/statfs.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h mount.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mmcsd.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/examples/mount/mount_main.c apps/examples/mount/mount_main.c
--- apps-12.8.0/examples/mount/mount_main.c	2025-01-24 11:45:01.733437854 +0200
+++ apps/examples/mount/mount_main.c	2025-11-04 11:04:40.273785060 +0200
@@ -35,8 +35,10 @@
 #include <fcntl.h>
 #include <dirent.h>
 #include <errno.h>
+#include <debug.h>
 
 #include "mount.h"
+#include <nuttx/mmcsd.h> 
 
 /****************************************************************************
  * Pre-processor Definitions
@@ -65,6 +67,10 @@
 #ifdef CONFIG_EXAMPLES_MOUNT_DEVNAME
 static const char g_testfile1[]      = "/mnt/fs/TestDir/TestFile.txt";
 #endif
+static const char g_testdiri[]      = "/mnt/fs/i";
+static const char g_testdirj[]      = "/mnt/fs/j";
+static const char g_testfilej[]      = "/mnt/fs/j/j.txt";
+static const char g_testfilel[]      = "/mnt/fs/WrTest1.txt";
 static const char g_testfile2[]      = "/mnt/fs/TestDir/WrTest1.txt";
 static const char g_testfile3[]      = "/mnt/fs/NewDir1/WrTest2.txt";
 static const char g_testfile4[]      = "/mnt/fs/NewDir3/Renamed.txt";
@@ -87,60 +93,60 @@
 #ifdef TEST_USE_STAT
 static void show_stat(const char *path, struct stat *ps)
 {
-  printf("%s stat:\n", path);
-  printf("\tmode        : %08x\n", ps->st_mode);
+  _info("%s stat:\n", path);
+  _info("\tmode        : %08x\n", ps->st_mode);
 
   if (S_ISREG(ps->st_mode))
     {
-      printf("\ttype        : File\n");
+      _info("\ttype        : File\n");
     }
   else if (S_ISDIR(ps->st_mode))
     {
-      printf("\ttype        : Directory\n");
+      _info("\ttype        : Directory\n");
     }
   else if (S_ISCHR(ps->st_mode))
     {
-      printf("\ttype        : Character driver\n");
+      _info("\ttype        : Character driver\n");
     }
   else if (S_ISBLK(ps->st_mode))
     {
-      printf("\ttype        : Block driver\n");
+      _info("\ttype        : Block driver\n");
     }
   else if (S_ISMQ(ps->st_mode))
     {
-      printf("\ttype        : Message queue\n");
+      _info("\ttype        : Message queue\n");
     }
   else if (S_ISSEM(ps->st_mode))
     {
-      printf("\ttype        : Named semaphore\n");
+      _info("\ttype        : Named semaphore\n");
     }
   else if (S_ISSHM(ps->st_mode))
     {
-      printf("\ttype        : Shared memory\n");
+      _info("\ttype        : Shared memory\n");
     }
   else if (S_ISSOCK(ps->st_mode))
     {
-      printf("\ttype        : Socket\n");
+      _info("\ttype        : Socket\n");
     }
   else if (S_ISMTD(ps->st_mode))
     {
-      printf("\ttype        : Named MTD driver\n");
+      _info("\ttype        : Named MTD driver\n");
     }
   else if (S_ISLNK(ps->st_mode))
     {
-      printf("\ttype        : Symbolic link\n");
+      _info("\ttype        : Symbolic link\n");
     }
   else
     {
-      printf("\ttype        : Unknown\n");
+      _info("\ttype        : Unknown\n");
     }
 
-  printf("\tsize        : %jd (bytes)\n", (intmax_t)ps->st_size);
-  printf("\tblock size  : %d (bytes)\n",  ps->st_blksize);
-  printf("\tsize        : %ju (blocks)\n", (uintmax_t)ps->st_blocks);
-  printf("\taccess time : %ju\n", (uintmax_t)ps->st_atime);
-  printf("\tmodify time : %ju\n", (uintmax_t)ps->st_mtime);
-  printf("\tchange time : %ju\n", (uintmax_t)ps->st_ctime);
+  _info("\tsize        : %jd (bytes)\n", (intmax_t)ps->st_size);
+  _info("\tblock size  : %d (bytes)\n",  ps->st_blksize);
+  _info("\tsize        : %ju (blocks)\n", (uintmax_t)ps->st_blocks);
+  _info("\taccess time : %ju\n", (uintmax_t)ps->st_atime);
+  _info("\tmodify time : %ju\n", (uintmax_t)ps->st_mtime);
+  _info("\tchange time : %ju\n", (uintmax_t)ps->st_ctime);
 }
 #endif
 
@@ -158,23 +164,23 @@
    * expectederror
    */
 
-  printf("show_statfs: Try statfs(%s)\n", path);
+  _info("show_statfs: Try statfs(%s)\n", path);
   ret = statfs(path, &buf);
   if (ret == 0)
     {
-      printf("show_statfs: statfs(%s) succeeded\n", path);
-      printf("\tFS Type           : %0" PRIx32 "\n", buf.f_type);
-      printf("\tBlock size        : %zd\n", buf.f_bsize);
-      printf("\tNumber of blocks  : %jd\n", (intmax_t)buf.f_blocks);
-      printf("\tFree blocks       : %jd\n", (intmax_t)buf.f_bfree);
-      printf("\tFree user blocks  : %jd\n", (intmax_t)buf.f_bavail);
-      printf("\tNumber file nodes : %jd\n", (intmax_t)buf.f_files);
-      printf("\tFree file nodes   : %jd\n", (intmax_t)buf.f_ffree);
-      printf("\tFile name length  : %zd\n", buf.f_namelen);
+      _info("show_statfs: statfs(%s) succeeded\n", path);
+      _info("\tFS Type           : %0" PRIx32 "\n", buf.f_type);
+      _info("\tBlock size        : %zd\n", buf.f_bsize);
+      _info("\tNumber of blocks  : %jd\n", (intmax_t)buf.f_blocks);
+      _info("\tFree blocks       : %jd\n", (intmax_t)buf.f_bfree);
+      _info("\tFree user blocks  : %jd\n", (intmax_t)buf.f_bavail);
+      _info("\tNumber file nodes : %jd\n", (intmax_t)buf.f_files);
+      _info("\tFree file nodes   : %jd\n", (intmax_t)buf.f_ffree);
+      _info("\tFile name length  : %zd\n", buf.f_namelen);
     }
   else
     {
-      printf("show_statfs: ERROR statfs(%s) failed with errno=%d\n",
+      _info("show_statfs: ERROR statfs(%s) failed with errno=%d\n",
              path, errno);
       g_nerrors++;
     }
@@ -197,7 +203,7 @@
   dirp = opendir(path);
   if (!dirp)
     {
-      printf("show_directories: ERROR opendir(\"%s\") with errno=%d\n",
+      _info("show_directories: ERROR opendir(\"%s\") with errno=%d\n",
              path, errno);
       g_nerrors++;
       return;
@@ -213,7 +219,7 @@
       if (DIRENT_ISDIRECTORY(direntry->d_type))
         {
           char *subdir;
-          printf("%s/\n", direntry->d_name);
+          _info("%s/\n", direntry->d_name);
           snprintf(g_namebuffer, sizeof(g_namebuffer),
                    "%s/%s", path, direntry->d_name);
           subdir = strdup(g_namebuffer);
@@ -222,7 +228,7 @@
         }
       else
         {
-          printf("%s\n", direntry->d_name);
+          _info("%s\n", direntry->d_name);
         }
     }
 
@@ -241,18 +247,18 @@
 {
   int fd;
 
-  printf("fail_read_open: Try open(%s) for reading\n", path);
+  _info("fail_read_open: Try open(%s) for reading\n", path);
 
   fd = open(path, O_RDONLY);
   if (fd >= 0)
     {
-      printf("fail_read_open: ERROR open(%s) succeeded\n", path);
+      _info("fail_read_open: ERROR open(%s) succeeded\n", path);
       g_nerrors++;
       close(fd);
     }
   else if (errno != expectederror)
     {
-      printf("fail_read_open: ERROR open(%s) with errno=%d(expect %d)\n",
+      _info("fail_read_open: ERROR open(%s) with errno=%d(expect %d)\n",
              path, errno, expectederror);
       g_nerrors++;
     }
@@ -271,12 +277,12 @@
 
   /* Read a test file that is already on the test file system image */
 
-  printf("read_test_file: opening %s for reading\n", path);
+  _info("read_test_file: opening %s for reading\n", path);
 
   fd = open(path, O_RDONLY);
   if (fd < 0)
     {
-      printf("read_test_file: ERROR failed to open %s, errno=%d\n",
+      _info("read_test_file: ERROR failed to open %s, errno=%d\n",
              path, errno);
       g_nerrors++;
     }
@@ -286,14 +292,14 @@
       nbytes = read(fd, buffer, 128);
       if (nbytes < 0)
         {
-          printf("read_test_file: ERROR failed to read from %s, errno=%d\n",
+          _info("read_test_file: ERROR failed to read from %s, errno=%d\n",
                  path, errno);
           g_nerrors++;
         }
       else
         {
           buffer[127] = '\0';
-          printf("read_test_file: Read \"%s\" from %s\n", buffer, path);
+          _info("read_test_file: Read \"%s\" from %s\n", buffer, path);
         }
 
       close(fd);
@@ -310,12 +316,12 @@
 
   /* Write a test file into a pre-existing file on the test file system */
 
-  printf("write_test_file: opening %s for writing\n", path);
+  _info("write_test_file: opening %s for writing\n", path);
 
   fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
   if (fd < 0)
     {
-      printf("write_test_file: ERROR to open %s for writing, errno=%d\n",
+      _info("write_test_file: ERROR to open %s for writing, errno=%d\n",
              path, errno);
       g_nerrors++;
     }
@@ -324,13 +330,13 @@
       int nbytes = write(fd, g_testmsg, strlen(g_testmsg));
       if (nbytes < 0)
         {
-          printf("write_test_file: ERROR failed to write to %s, errno=%d\n",
+          _info("write_test_file: ERROR failed to write to %s, errno=%d\n",
                  path, errno);
           g_nerrors++;
         }
       else
         {
-          printf("write_test_file: wrote %d bytes to %s\n", nbytes, path);
+          _info("write_test_file: wrote %d bytes to %s\n", nbytes, path);
         }
 
       close(fd);
@@ -349,17 +355,17 @@
    * expectederror
    */
 
-  printf("fail_mkdir: Try mkdir(%s)\n", path);
+  _info("fail_mkdir: Try mkdir(%s)\n", path);
 
   ret = mkdir(path, 0666);
   if (ret == 0)
     {
-      printf("fail_mkdir: ERROR mkdir(%s) succeeded\n", path);
+      _info("fail_mkdir: ERROR mkdir(%s) succeeded\n", path);
       g_nerrors++;
     }
   else if (errno != expectederror)
     {
-      printf("fail_mkdir: ERROR mkdir(%s) with errno=%d(expect %d)\n",
+      _info("fail_mkdir: ERROR mkdir(%s) with errno=%d(expect %d)\n",
              path, errno, expectederror);
       g_nerrors++;
     }
@@ -373,12 +379,12 @@
 {
   int ret;
 
-  printf("succeed_mkdir: Try mkdir(%s)\n", path);
+  _info("succeed_mkdir: Try mkdir(%s)\n", path);
 
   ret = mkdir(path, 0666);
   if (ret != 0)
     {
-      printf("succeed_mkdir: ERROR mkdir(%s) failed with errno=%d\n",
+      _info("succeed_mkdir: ERROR mkdir(%s) failed with errno=%d\n",
              path, errno);
       g_nerrors++;
     }
@@ -396,17 +402,17 @@
    * expectederror
    */
 
-  printf("fail_rmdir: Try rmdir(%s)\n", path);
+  _info("fail_rmdir: Try rmdir(%s)\n", path);
 
   ret = rmdir(path);
   if (ret == 0)
     {
-      printf("fail_rmdir: ERROR rmdir(%s) succeeded\n", path);
+      _info("fail_rmdir: ERROR rmdir(%s) succeeded\n", path);
       g_nerrors++;
     }
   else if (errno != expectederror)
     {
-      printf("fail_rmdir: ERROR rmdir(%s) with errno=%d(expect %d)\n",
+      _info("fail_rmdir: ERROR rmdir(%s) with errno=%d(expect %d)\n",
              path, errno, expectederror);
       g_nerrors++;
     }
@@ -420,12 +426,12 @@
 {
   int ret;
 
-  printf("succeed_rmdir: Try rmdir(%s)\n", path);
+  _info("succeed_rmdir: Try rmdir(%s)\n", path);
 
   ret = rmdir(path);
   if (ret != 0)
     {
-      printf("succeed_rmdir: ERROR rmdir(%s) failed with errno=%d\n",
+      _info("succeed_rmdir: ERROR rmdir(%s) failed with errno=%d\n",
              path, errno);
       g_nerrors++;
     }
@@ -443,17 +449,17 @@
    * expectederror
    */
 
-  printf("fail_unlink: Try unlink(%s)\n", path);
+  _info("fail_unlink: Try unlink(%s)\n", path);
 
   ret = unlink(path);
   if (ret == 0)
     {
-      printf("fail_unlink: ERROR unlink(%s) succeeded\n", path);
+      _info("fail_unlink: ERROR unlink(%s) succeeded\n", path);
       g_nerrors++;
     }
   else if (errno != expectederror)
     {
-      printf("fail_unlink: ERROR unlink(%s) with errno=%d(expect %d)\n",
+      _info("fail_unlink: ERROR unlink(%s) with errno=%d(expect %d)\n",
              path, errno, expectederror);
       g_nerrors++;
     }
@@ -469,14 +475,16 @@
 
   /* Try unlink() against the test file.  It should succeed. */
 
-  printf("succeed_unlink: Try unlink(%s)\n", path);
+  _info("succeed_unlink: Try unlink(%s)\n", path);
 
   ret = unlink(path);
   if (ret != 0)
     {
-      printf("succeed_unlink: ERROR unlink(%s) failed with errno=%d\n",
+      _info("succeed_unlink: ERROR unlink(%s) failed with errno=%d\n",
              path, errno);
       g_nerrors++;
+    } else {
+	    _info("succeed_unlink: success\n");
     }
 }
 
@@ -493,18 +501,18 @@
    * expectederror
    */
 
-  printf("fail_rename: Try rename(%s->%s)\n", oldpath, newpath);
+  _info("fail_rename: Try rename(%s->%s)\n", oldpath, newpath);
 
   ret = rename(oldpath, newpath);
   if (ret == 0)
     {
-      printf("fail_rename: ERROR rename(%s->%s) succeeded\n",
+      _info("fail_rename: ERROR rename(%s->%s) succeeded\n",
              oldpath, newpath);
       g_nerrors++;
     }
   else if (errno != expectederror)
     {
-      printf("fail_rename: ERROR rename(%s->%s) with errno=%d(expect %d)\n",
+      _info("fail_rename: ERROR rename(%s->%s) with errno=%d(expect %d)\n",
              oldpath, newpath, errno, expectederror);
       g_nerrors++;
     }
@@ -518,12 +526,12 @@
 {
   int ret;
 
-  printf("succeed_rename: Try rename(%s->%s)\n", oldpath, newpath);
+  _info("succeed_rename: Try rename(%s->%s)\n", oldpath, newpath);
 
   ret = rename(oldpath, newpath);
   if (ret != 0)
     {
-      printf("succeed_rename: ERROR rename(%s->%s) failed with errno=%d\n",
+      _info("succeed_rename: ERROR rename(%s->%s) failed with errno=%d\n",
              oldpath, newpath, errno);
       g_nerrors++;
     }
@@ -543,18 +551,18 @@
    * expectederror
    */
 
-  printf("fail_stat: Try stat(%s)\n", path);
+  _info("fail_stat: Try stat(%s)\n", path);
 
   ret = stat(path, &buf);
   if (ret == 0)
     {
-      printf("fail_stat: ERROR stat(%s) succeeded\n", path);
+      _info("fail_stat: ERROR stat(%s) succeeded\n", path);
       show_stat(path, &buf);
       g_nerrors++;
     }
   else if (errno != expectederror)
     {
-      printf("fail_stat: ERROR stat(%s) failed with errno=%d(expected %d)\n",
+      _info("fail_stat: ERROR stat(%s) failed with errno=%d(expected %d)\n",
              path, errno, expectederror);
       g_nerrors++;
     }
@@ -573,18 +581,18 @@
   struct stat buf;
   int ret;
 
-  printf("succeed_stat: Try stat(%s)\n", path);
+  _info("succeed_stat: Try stat(%s)\n", path);
 
   ret = stat(path, &buf);
   if (ret != 0)
     {
-      printf("succeed_stat: ERROR stat(%s) failed with errno=%d\n",
+      _info("succeed_stat: ERROR stat(%s) failed with errno=%d\n",
              path, errno);
       g_nerrors++;
     }
   else
     {
-      printf("succeed_stat: stat(%s) succeeded\n", path);
+      _info("succeed_stat: stat(%s) succeeded\n", path);
       show_stat(path, &buf);
     }
 }
@@ -606,35 +614,59 @@
 
 #ifndef CONFIG_EXAMPLES_MOUNT_DEVNAME
   /* Create a RAM disk for the test */
-
+  _info("mount_main: creating RAM disk\n");
   ret = create_ramdisk();
   if (ret < 0)
     {
-      printf("mount_main: ERROR failed to create RAM disk\n");
+      _info("mount_main: ERROR failed to create RAM disk\n");
       return 1;
-    }
+    } else
+      _info("mount_main: created RAM disk\n");
 #endif
 
+  mmcsd_spislotinitialize(0, 0, 0);
+
   /* Mount the test file system (see arch/sim/src/up_deviceimage.c */
 
-  printf("mount_main: mounting %s filesystem at target=%s with source=%s\n",
+  _info("mount_main: mounting %s filesystem at target=%s with source=%s\n",
          g_filesystemtype, g_target, g_source);
 
   ret = mount(g_source, g_target, g_filesystemtype, 0, NULL);
-  printf("mount_main: mount() returned %d\n", ret);
-
-  if (ret == 0)
-    {
-      show_statfs(g_mntdir);
-      show_statfs(g_target);
+  _info("mount_main: mount() returned %d\n", ret);
 
+  if (ret < 0) {
+      _info("mount errno=%d\n", errno);
+  } else if (ret == 0)
+    {
+      //show_statfs(g_mntdir);
+      //show_statfs(g_target);
+#if 0
+      succeed_mkdir(g_testdirj);
+	  write_test_file(g_testfilej);
+	  succeed_rename(g_testdirj, g_testdiri);
+      show_directories("", 0);
+#endif
+      	write_test_file(g_testfilel);
+		//show_directories("", 0);
+      	//succeed_stat(g_testfilel);
+      	//show_statfs(g_testfilel);
+		read_test_file(g_testfilel);
+		succeed_unlink(g_testfilel);
+//#if 0
 #ifdef CONFIG_EXAMPLES_MOUNT_DEVNAME
+      succeed_mkdir(g_testdir1);
+      show_directories("", 0);
+      succeed_stat(g_testdir1);
+      show_statfs(g_testdir1);
+
       /* Read a test file that is already on the test file system image */
 
+	  write_test_file(g_testfile1);
       show_directories("", 0);
       succeed_stat(g_testfile1);
       show_statfs(g_testfile1);
       read_test_file(g_testfile1);
+	  //succeed_unlink(g_testfile1);
 #else
       /* Create the test directory that would have been on the canned
        * filesystem
@@ -727,6 +759,7 @@
 
       fail_mkdir(g_testdir2, EEXIST);
 
+
       /* Write a test file into a new directory on the test file system */
 
       fail_stat(g_testfile3, ENOENT);
@@ -756,7 +789,7 @@
       fail_rename(g_testdir4, g_testdir3, ENOENT);
 
       /* Try rename() to a non-existing directory.  Should succeed */
-
+	  _info("Try rename() to a non-existing directory.  Should succeed\n");
       fail_stat(g_testdir4, ENOENT);
       succeed_rename(g_testdir3, g_testdir4);
       show_directories("", 0);
@@ -765,7 +798,7 @@
       show_statfs(g_testdir4);
 
       /* Try rename() of file.  Should work. */
-
+	  _info("Try rename() of file.  Should work.\n");
       fail_stat(g_testfile4, ENOENT);
       succeed_rename(g_testfile3, g_testfile4);
       show_directories("", 0);
@@ -777,18 +810,21 @@
 
       read_test_file(g_testfile4);
 
+	  //show_directories("", 0);
+//#endif
+
       /* Unmount the file system */
 
-      printf("mount_main: Try unmount(%s)\n", g_target);
+      _info("mount_main: Try unmount(%s)\n", g_target);
 
       ret = umount(g_target);
       if (ret != 0)
         {
-          printf("mount_main: ERROR umount() failed, errno %d\n", errno);
+          _info("mount_main: ERROR umount() failed, errno %d\n", errno);
           g_nerrors++;
         }
 
-      printf("mount_main: %d errors reported\n", g_nerrors);
+      _info("mount_main: %d errors reported\n", g_nerrors);
     }
 
   fflush(stdout);
diff -Naur apps-12.8.0/examples/mount/ramdisk.c apps/examples/mount/ramdisk.c
--- apps-12.8.0/examples/mount/ramdisk.c	2025-01-24 11:45:01.733437854 +0200
+++ apps/examples/mount/ramdisk.c	2025-11-04 11:04:40.273785060 +0200
@@ -32,6 +32,7 @@
 #include <stdlib.h>
 #include <string.h>
 #include <errno.h>
+#include <debug.h>
 
 #include <nuttx/drivers/ramdisk.h>
 
@@ -87,7 +88,7 @@
   ret = boardctl(BOARDIOC_MKRD, (uintptr_t)&desc);
   if (ret < 0)
     {
-      printf("create_ramdisk: Failed to create ramdisk at %s: %d\n",
+      _info("create_ramdisk: Failed to create ramdisk at %s: %d\n",
              g_source, -ret);
       return ret;
     }
@@ -97,7 +98,7 @@
   ret = mkfatfs(g_source, &g_fmt);
   if (ret < 0)
     {
-      printf("create_ramdisk: Failed to create FAT filesystem on ramdisk at %s\n",
+      _info("create_ramdisk: Failed to create FAT filesystem on ramdisk at %s\n",
              g_source);
       return ret;
     }
diff -Naur apps-12.8.0/examples/sotest/Kconfig apps/examples/sotest/Kconfig
--- apps-12.8.0/examples/sotest/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/examples/sotest/Kconfig	2025-11-04 11:04:40.486657580 +0200
@@ -0,0 +1,12 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "sotest example"
+source "/home/laur/lucru/rtos/apps/examples/sotest/main/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sotest/modprint/Kconfig"
+source "/home/laur/lucru/rtos/apps/examples/sotest/sotest/Kconfig"
+endmenu # sotest example
diff -Naur apps-12.8.0/fsutils/Kconfig apps/fsutils/Kconfig
--- apps-12.8.0/fsutils/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/fsutils/Kconfig	2025-11-04 11:04:40.018937677 +0200
@@ -0,0 +1,19 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "File System Utilities"
+source "/home/laur/lucru/rtos/apps/fsutils/flash_eraseall/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/inifile/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/inih/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/ipcfg/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/libtinycbor/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/mkfatfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/mkgpt/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/mkmbr/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/mksmartfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/fsutils/passwd/Kconfig"
+endmenu # File System Utilities
diff -Naur apps-12.8.0/fsutils/mkfatfs/Make.dep apps/fsutils/mkfatfs/Make.dep
--- apps-12.8.0/fsutils/mkfatfs/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/fsutils/mkfatfs/Make.dep	2025-11-05 16:00:05.548466727 +0200
@@ -0,0 +1,136 @@
+# Gen Make.dep automatically
+mkfatfs.c.home.laur.lucru.rtos.apps.fsutils.mkfatfs.o: mkfatfs.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/apps/include/fsutils/mkfatfs.h fat32.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h mkfatfs.h
+configfat.c.home.laur.lucru.rtos.apps.fsutils.mkfatfs.o: configfat.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/apps/include/fsutils/mkfatfs.h fat32.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h mkfatfs.h
+writefat.c.home.laur.lucru.rtos.apps.fsutils.mkfatfs.o: writefat.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fat.h \
+ /home/laur/lucru/rtos/apps/include/fsutils/mkfatfs.h fat32.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h mkfatfs.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/games/Kconfig apps/games/Kconfig
--- apps-12.8.0/games/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/games/Kconfig	2025-11-04 11:04:40.955376885 +0200
@@ -0,0 +1,10 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Games"
+source "/home/laur/lucru/rtos/apps/games/brickmatch/Kconfig"
+endmenu # Games
diff -Naur apps-12.8.0/graphics/Kconfig apps/graphics/Kconfig
--- apps-12.8.0/graphics/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/graphics/Kconfig	2025-11-04 11:04:40.856436136 +0200
@@ -0,0 +1,21 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Graphics Support"
+source "/home/laur/lucru/rtos/apps/graphics/ft80x/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/libjpeg/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/libyuv/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/lvgl/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/nxglyphs/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/nxwidgets/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/nxwm/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/pdcurs34/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/screenshot/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/slcd/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/tiff/Kconfig"
+source "/home/laur/lucru/rtos/apps/graphics/twm4nx/Kconfig"
+endmenu # Graphics Support
diff -Naur apps-12.8.0/include/fsutils/mkfatfs.h apps/include/fsutils/mkfatfs.h
--- apps-12.8.0/include/fsutils/mkfatfs.h	2025-01-24 11:45:01.794433979 +0200
+++ apps/include/fsutils/mkfatfs.h	2025-11-04 11:04:40.876424166 +0200
@@ -35,7 +35,7 @@
  ****************************************************************************/
 
 #define MKFATFS_DEFAULT_NFATS        2     /* 2: Default number of FATs */
-#define MKFATFS_DEFAULT_FATTYPE      0     /* 0: Autoselect FAT size */
+#define MKFATFS_DEFAULT_FATTYPE      32     /* 0: Autoselect FAT size */
 #define MKFATFS_DEFAULT_CLUSTSHIFT   0xff  /* 0xff: Autoselect cluster size */
 #define MKFATFS_DEFAULT_VOLUMELABEL  { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' }
 #define MKFATFS_DEFAULT_BKUPBOOT     0     /* 0: Determine sector number of the backup boot sector */
diff -Naur apps-12.8.0/industry/Kconfig apps/industry/Kconfig
--- apps-12.8.0/industry/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/industry/Kconfig	2025-11-04 11:04:39.952978069 +0200
@@ -0,0 +1,12 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Industrial Applications"
+source "/home/laur/lucru/rtos/apps/industry/abnt_codi/Kconfig"
+source "/home/laur/lucru/rtos/apps/industry/foc/Kconfig"
+source "/home/laur/lucru/rtos/apps/industry/scpi/Kconfig"
+endmenu # Industrial Applications
diff -Naur apps-12.8.0/inertial/Kconfig apps/inertial/Kconfig
--- apps-12.8.0/inertial/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/inertial/Kconfig	2025-11-04 11:04:39.970966964 +0200
@@ -0,0 +1,10 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Inertial Libraries Support"
+source "/home/laur/lucru/rtos/apps/inertial/madgwick/Kconfig"
+endmenu # Inertial Libraries Support
diff -Naur apps-12.8.0/interpreters/Kconfig apps/interpreters/Kconfig
--- apps-12.8.0/interpreters/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/interpreters/Kconfig	2025-11-04 11:04:41.332156970 +0200
@@ -0,0 +1,21 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Interpreters"
+source "/home/laur/lucru/rtos/apps/interpreters/bas/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/duktape/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/ficl/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/luajit/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/lua/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/luamodules/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/minibasic/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/python/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/quickjs/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/toywasm/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/wamr/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/wasm3/Kconfig"
+endmenu # Interpreters
diff -Naur apps-12.8.0/interpreters/luamodules/Kconfig apps/interpreters/luamodules/Kconfig
--- apps-12.8.0/interpreters/luamodules/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/interpreters/luamodules/Kconfig	2025-11-04 11:04:41.311169176 +0200
@@ -0,0 +1,13 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "LUA Modules"
+source "/home/laur/lucru/rtos/apps/interpreters/luamodules/cjson/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/luamodules/lfs/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/luamodules/luasyslog/Kconfig"
+source "/home/laur/lucru/rtos/apps/interpreters/luamodules/luv/Kconfig"
+endmenu # LUA Modules
diff -Naur apps-12.8.0/logging/Kconfig apps/logging/Kconfig
--- apps-12.8.0/logging/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/logging/Kconfig	2025-11-04 11:04:40.968369104 +0200
@@ -0,0 +1,11 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Logging Utilities"
+source "/home/laur/lucru/rtos/apps/logging/embedlog/Kconfig"
+source "/home/laur/lucru/rtos/apps/logging/nxscope/Kconfig"
+endmenu # Logging Utilities
diff -Naur apps-12.8.0/lte/Kconfig apps/lte/Kconfig
--- apps-12.8.0/lte/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/lte/Kconfig	2025-11-04 11:04:39.968968198 +0200
@@ -0,0 +1,11 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "LTE Libraries and NSH Add-Ons"
+source "/home/laur/lucru/rtos/apps/lte/alt1250/Kconfig"
+source "/home/laur/lucru/rtos/apps/lte/lapi/Kconfig"
+endmenu # LTE Libraries and NSH Add-Ons
diff -Naur apps-12.8.0/math/Kconfig apps/math/Kconfig
--- apps-12.8.0/math/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/math/Kconfig	2025-11-04 11:04:41.293179638 +0200
@@ -0,0 +1,13 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Math Library Support"
+source "/home/laur/lucru/rtos/apps/math/gemmlowp/Kconfig"
+source "/home/laur/lucru/rtos/apps/math/kissfft/Kconfig"
+source "/home/laur/lucru/rtos/apps/math/libtommath/Kconfig"
+source "/home/laur/lucru/rtos/apps/math/ruy/Kconfig"
+endmenu # Math Library Support
diff -Naur apps-12.8.0/mlearning/Kconfig apps/mlearning/Kconfig
--- apps-12.8.0/mlearning/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/mlearning/Kconfig	2025-11-04 11:04:40.952378680 +0200
@@ -0,0 +1,14 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Machine Learning Support"
+source "/home/laur/lucru/rtos/apps/mlearning/cmsis/Kconfig"
+source "/home/laur/lucru/rtos/apps/mlearning/cmsis-nn/Kconfig"
+source "/home/laur/lucru/rtos/apps/mlearning/darknet/Kconfig"
+source "/home/laur/lucru/rtos/apps/mlearning/libnnablart/Kconfig"
+source "/home/laur/lucru/rtos/apps/mlearning/tflite-micro/Kconfig"
+endmenu # Machine Learning Support
diff -Naur apps-12.8.0/netutils/Kconfig apps/netutils/Kconfig
--- apps-12.8.0/netutils/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/netutils/Kconfig	2025-11-04 11:04:39.832052717 +0200
@@ -0,0 +1,50 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Network Utilities"
+source "/home/laur/lucru/rtos/apps/netutils/chat/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/cjson/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/codecs/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/connectedhomeip/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/cwebsocket/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/dhcp6c/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/dhcpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/dhcpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/discover/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/esp8266/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/ftpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/ftpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/iperf/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/iptables/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/jsoncpp/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/libcoap/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/libcurl4nx/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/libwebsockets/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/mqttc/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/nanopb/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/netcat/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/netinit/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/netlib/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/nng/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/ntpclient/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/ping/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/pppd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/ptpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/rexecd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/rexec/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/rtptools/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/smtp/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/telnetc/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/telnetd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/tftpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/thttpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/wakaama/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/wakeonlan/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/webclient/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/webserver/Kconfig"
+source "/home/laur/lucru/rtos/apps/netutils/xmlrpc/Kconfig"
+endmenu # Network Utilities
diff -Naur apps-12.8.0/nshlib/Make.dep apps/nshlib/Make.dep
--- apps-12.8.0/nshlib/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/nshlib/Make.dep	2025-11-05 16:00:06.241180543 +0200
@@ -0,0 +1,1205 @@
+# Gen Make.dep automatically
+nsh_init.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_init.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/boardctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/symtab.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ nsh_console.h
+nsh_parse.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_parse.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/version.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/sched_note.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/macro.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/addrenv.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wdog.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/arch.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/net/net.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/tls.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/cache.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atexit.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/arch.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_console.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_console.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_script.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_script.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h
+nsh_system.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_system.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_command.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_command.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/builtin.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_fscmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_fscmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/libgen.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/mount.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/boardctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/drivers/ramdisk.h \
+ /home/laur/lucru/rtos/apps/include/fsutils/mkfatfs.h nsh_console.h
+nsh_ddcmd.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_ddcmd.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_proccmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_proccmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/sysinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/param.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_mmcmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_mmcmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_timcmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_timcmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/timers/rtc.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/time.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/select.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_envcmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_envcmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/libgen.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_syscmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_syscmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/power/pm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wdog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/rpmsg/rpmsg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/rptun/rptun.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/streams.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/boardctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/utsname.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_dbgcmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_dbgcmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_prompt.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_prompt.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h
+nsh_session.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_session.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/termios.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_fsutils.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_fsutils.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_builtin.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_builtin.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/wait.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/builtin.h \
+ /home/laur/lucru/rtos/apps/include/builtin/builtin.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ nsh_console.h /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_mntcmds.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_mntcmds.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/mount.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/netdb.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/nfs.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_consolemain.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_consolemain.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_printf.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_printf.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/libgen.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_test.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_test.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h
+nsh_wait.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_wait.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/addrenv.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wdog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/arch.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/net/net.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/tls.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/cache.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atexit.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/wait.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+nsh_alias.c.home.laur.lucru.rtos.apps.nshlib.o: nsh_alias.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h nsh.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/usb/usbdev_trace.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h nsh_console.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/nshlib/nsh_fsutils.c apps/nshlib/nsh_fsutils.c
--- apps-12.8.0/nshlib/nsh_fsutils.c	2025-01-24 11:45:01.712439187 +0200
+++ apps/nshlib/nsh_fsutils.c	2025-11-04 11:04:40.068907752 +0200
@@ -573,6 +573,7 @@
  ****************************************************************************/
 
 #ifdef NSH_HAVE_IOBUFFER
+char lauriob[255]={0};
 FAR char *nsh_getdirpath(FAR struct nsh_vtbl_s *vtbl,
                          FAR const char *dirpath, FAR const char *path)
 {
@@ -587,6 +588,7 @@
       snprintf(vtbl->iobuffer, IOBUFFERSIZE, "%s/%s", dirpath, path);
     }
 
+  // laur
   return lib_realpath(vtbl->iobuffer, NULL, true);
 }
 #endif
diff -Naur apps-12.8.0/platform/board/dummy.c apps/platform/board/dummy.c
--- apps-12.8.0/platform/board/dummy.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/platform/board/dummy.c	2025-11-04 11:04:40.717519327 +0200
@@ -0,0 +1,25 @@
+/***************************************************************************
+ * apps/platform/dummy/dummy.c
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ***************************************************************************/
+
+/***************************************************************************
+ * Private Functions
+ ***************************************************************************/
diff -Naur apps-12.8.0/platform/board/Kconfig apps/platform/board/Kconfig
--- apps-12.8.0/platform/board/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/platform/board/Kconfig	2025-11-04 11:04:40.717519327 +0200
@@ -0,0 +1,4 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
diff -Naur apps-12.8.0/platform/board/Make.defs apps/platform/board/Make.defs
--- apps-12.8.0/platform/board/Make.defs	1970-01-01 02:00:00.000000000 +0200
+++ apps/platform/board/Make.defs	2025-11-04 11:04:40.717519327 +0200
@@ -0,0 +1,26 @@
+############################################################################
+# apps/platform/dummy/Make.defs
+#
+# SPDX-License-Identifier: Apache-2.0
+#
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.  The
+# ASF licenses this file to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance with the
+# License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+# License for the specific language governing permissions and limitations
+# under the License.
+#
+############################################################################
+
+# Add dummy.c to ensure that we have at least one object.
+# On some platforms like macOS, we can't create an empty archive.
+
+CSRCS += dummy.c
diff -Naur apps-12.8.0/platform/Make.dep apps/platform/Make.dep
--- apps-12.8.0/platform/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/platform/Make.dep	2025-11-05 16:00:06.358132218 +0200
@@ -0,0 +1,4 @@
+# Gen Make.dep automatically
+dummy.c.home.laur.lucru.rtos.apps.platform.o: board/dummy.c
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/sdr/Kconfig apps/sdr/Kconfig
--- apps-12.8.0/sdr/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/sdr/Kconfig	2025-11-04 11:04:40.058913737 +0200
@@ -0,0 +1,10 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Software Define Radio Libraries"
+source "/home/laur/lucru/rtos/apps/sdr/liquid_dsp/Kconfig"
+endmenu # Software Define Radio Libraries
diff -Naur apps-12.8.0/system/Kconfig apps/system/Kconfig
--- apps-12.8.0/system/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/system/Kconfig	2025-11-04 11:04:39.643169316 +0200
@@ -0,0 +1,81 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "System Libraries and NSH Add-Ons"
+source "/home/laur/lucru/rtos/apps/system/adb/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/argtable3/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/batterydump/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/cdcacm/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/cfgdata/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/cle/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/composite/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/conntrack/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/coredump/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/critmon/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/cu/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/dd/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/debugpoint/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/dhcp6c/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/dhcpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/dumpstack/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/fastboot/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/fdt/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/flash_eraseall/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/flatbuffers/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/gcov/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/gdbstub/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/gprof/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/hex2bin/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/hexed/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/hostname/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/i2c/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/input/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/iptables/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/libuv/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/lm75/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/lsan/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/lzf/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/mdio/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/netdb/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nsh/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ntpc/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nxcamera/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nxcodec/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nxdiag/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nxlooper/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nxplayer/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/nxrecorder/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ofloader/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ping6/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ping/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/popen/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/psmq/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ptpd/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/readline/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/sched_note/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/sensorscope/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/setlogmask/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/settings/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/spi/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/stackmonitor/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/system/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/taskset/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/tcpdump/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/tee/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/telnetd/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/telnet/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/termcurses/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/trace/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ubloxmodem/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/uniqueid/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/uorb/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/usbmsc/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/vi/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/ymodem/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/zlib/Kconfig"
+source "/home/laur/lucru/rtos/apps/system/zmodem/Kconfig"
+endmenu # System Libraries and NSH Add-Ons
diff -Naur apps-12.8.0/system/nsh/dhrystone.h apps/system/nsh/dhrystone.h
--- apps-12.8.0/system/nsh/dhrystone.h	1970-01-01 02:00:00.000000000 +0200
+++ apps/system/nsh/dhrystone.h	2025-11-04 11:04:39.753101453 +0200
@@ -0,0 +1,432 @@
+// See LICENSE for license details.
+
+#ifndef _DHRYSTONE_H
+#define _DHRYSTONE_H
+
+/****************** "DHRYSTONE" Benchmark Program ***************************/
+#define Version "C, Version 2.2"
+/*  File:       dhry_1.c (part 2 of 3)
+ *  Author:     Reinhold P. Weicker
+ *              Siemens Nixdorf, Paderborn/Germany
+ *              weicker@specbench.org
+ *  Date:       May 25, 1988
+ *  Modified:	Steven Pemberton, CWI, Amsterdam; Steven.Pemberton@cwi.nl
+ *  Date:       October, 1993; March 1995
+ *              Included both files into one source, that gets compiled
+ *              in two passes. Made program auto-compiling, and auto-running,
+ *              and generally made it much easier to use.
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
+ *              are used for execution time measurement. For measurements
+ *              on other systems, these calls have to be changed.
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *              
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 389-8963 (9-17 EST)               
+ *                      Usenet: ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software used.
+ *      Hardware information includes: Machine type, CPU, type and size
+ *      of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states).
+ *      Software information includes: Compiler (and runtime library)
+ *      manufacturer and version, compilation switches, OS version.
+ *      The Operating System version may give an indication about the compiler;
+ *      Dhrystone itself performs no OS calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ ***************************************************************************
+ *
+ * Defines:     The following "Defines" are possible:
+ *      -DREG          (default: Not defined)
+ *              As an approximation to what an average C programmer
+ *              might do, causes the "register" storage class to be applied
+ *              - for local variables, if they are used (dynamically)
+ *                five or more times
+ *              - for parameters if they are used (dynamically)
+ *                six or more times
+ *              Note that an optimal "register" strategy is
+ *              compiler-dependent, and that "register" declarations
+ *              do not necessarily lead to faster execution.
+ *      -DNOSTRUCTASSIGN        (default: Not defined)
+ *              Define if the C compiler does not support
+ *              assignment of structures.
+ *      -DNOENUMS               (default: Not defined)
+ *              Define if the C compiler does not support
+ *              enumeration types.
+ *      -DTIMES                 (default)
+ *      -DTIME
+ *              The "times" function of UNIX (returning process times)
+ *              or the "time" function (returning wallclock time)
+ *              is used for measurement. 
+ *              For single user machines, "time ()" is adequate. For
+ *              multi-user machines where you cannot get single-user
+ *              access, use the "times ()" function. If you have
+ *              neither, use a stopwatch in the dead of night.
+ *              "printf"s are provided marking the points "Start Timer"
+ *              and "Stop Timer". DO NOT use the UNIX "time(1)"
+ *              command, as this will measure the total time to
+ *              run this program, which will (erroneously) include
+ *              the time to allocate storage (malloc) and to perform
+ *              the initialization.
+ *      -DHZ=nnn
+ *              In Berkeley UNIX, the function "times" returns process
+ *              time in 1/HZ seconds, with HZ = 60 for most systems.
+ *              CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
+ *              A VALUE.
+ *
+ ***************************************************************************
+ *
+ *  History:	Version C/2.1 was made for two reasons:
+ *
+ *	1) There was an obvious need for a common C version of
+ *      Dhrystone, since C is at present the most popular system
+ *      programming language for the class of processors
+ *      (microcomputers, minicomputers) where Dhrystone is used most.
+ *      There should be, as far as possible, only one C version of
+ *      Dhrystone such that results can be compared without
+ *      restrictions. In the past, the C versions distributed
+ *      by Rick Richardson (Version 1.1) and by Reinhold Weicker
+ *      had small (though not significant) differences.
+ *
+ *      2) As far as it is possible without changes to the Dhrystone
+ *      statistics, optimizing compilers should be prevented from
+ *      removing significant statements.
+ *
+ *      This C version has been developed in cooperation with
+ *      Rick Richardson (Tinton Falls, NJ), it incorporates many
+ *      ideas from the "Version 1.1" distributed previously by
+ *      him over the UNIX network Usenet.
+ *      I also thank Chaim Benedelac (National Semiconductor),
+ *      David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
+ *      Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
+ *      for their help with comments on earlier versions of the
+ *      benchmark.
+ *
+ *  Changes:    In the initialization part, this version follows mostly
+ *      Rick Richardson's version distributed via Usenet, not the
+ *      version distributed earlier via floppy disk by Reinhold Weicker.
+ *      As a concession to older compilers, names have been made
+ *      unique within the first 8 characters.
+ *      Inside the measurement loop, this version follows the
+ *      version previously distributed by Reinhold Weicker.
+ *
+ *      At several places in the benchmark, code has been added,
+ *      but within the measurement loop only in branches that 
+ *      are not executed. The intention is that optimizing compilers
+ *      should be prevented from moving code out of the measurement
+ *      loop, or from removing code altogether. Since the statements
+ *      that are executed within the measurement loop have NOT been
+ *      changed, the numbers defining the "Dhrystone distribution"
+ *      (distribution of statements, operand types and locality)
+ *      still hold. Except for sophisticated optimizing compilers,
+ *      execution times for this version should be the same as
+ *      for previous versions.
+ *
+ *      Since it has proven difficult to subtract the time for the
+ *      measurement loop overhead in a correct way, the loop check
+ *      has been made a part of the benchmark. This does have
+ *      an impact - though a very minor one - on the distribution
+ *      statistics which have been updated for this version.
+ *
+ *      All changes within the measurement loop are described
+ *      and discussed in the companion paper "Rationale for
+ *      Dhrystone version 2".
+ *
+ *      Because of the self-imposed limitation that the order and
+ *      distribution of the executed statements should not be
+ *      changed, there are still cases where optimizing compilers
+ *      may not generate code for some statements. To a certain
+ *      degree, this is unavoidable for small synthetic benchmarks.
+ *      Users of the benchmark are advised to check code listings
+ *      whether code is generated for all statements of Dhrystone.
+ *
+ *      Version 2.1 is identical to version 2.0 distributed via
+ *      the UNIX network Usenet in March 1988 except that it corrects
+ *      some minor deficiencies that were found by users of version 2.0.
+ *      The only change within the measurement loop is that a
+ *      non-executed "else" part was added to the "if" statement in
+ *      Func_3, and a non-executed "else" part removed from Proc_3.
+ *
+ * Version C/2.2, Steven Pemberton, October 1993
+ *	Functionally, identical to version 2.2; the changes are in
+ *	how you compile and use it:
+ *	- Everything is in one file now, but compiled in 2 passes
+ *	- Compile (and run) by running the file through the shell: 'sh dhry.c"
+ *	- Uses the system definition of HZ if one can be found
+ *	- HZ must be defined, otherwise it won't compile (no defaults here)
+ *	- The (uninteresting) output is printed to stderr (dhry2 > /dev/null)
+ *	- The number of loops is passed as a parameter, rather than read
+ *	  (dhry2 500000)
+ *	- If the number of loops is insufficient to get a good result,
+ *	  it repeats it with loops*10 until it is enough (rather than just
+ *	  stopping)
+ *	- Output says which sort of clock it is using, and the HZ value
+ *	- You can use -DREG instead of the -DREG=register of previous versions
+ *	- Some stylistic cleanups.
+ *		
+ ***************************************************************************
+ *
+ *  Compilation model and measurement (IMPORTANT):
+ *
+ *  The following "ground rules" apply for measurements:
+ *  - Separate compilation
+ *  - No procedure merging
+ *  - Otherwise, compiler optimizations are allowed but should be indicated
+ *  - Default results are those without register declarations
+ *  See the companion paper "Rationale for Dhrystone Version 2" for a more
+ *  detailed discussion of these ground rules.
+ *
+ *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
+ *  models ("small", "medium", "large" etc.) should be given if possible,
+ *  together with a definition of these models for the compiler system used.
+ *
+ **************************************************************************
+ *
+ *  Dhrystone (C version) statistics:
+ *
+ *  [Comment from the first distribution, updated for version 2.
+ *   Note that because of language differences, the numbers are slightly
+ *   different from the Ada version.]
+ *
+ *  The following program contains statements of a high level programming
+ *  language (here: C) in a distribution considered representative:           
+ *
+ *    assignments                  52 (51.0 %)
+ *    control statements           33 (32.4 %)
+ *    procedure, function calls    17 (16.7 %)
+ *
+ *  103 statements are dynamically executed. The program is balanced with
+ *  respect to the three aspects:                                             
+ *
+ *    - statement type
+ *    - operand type
+ *    - operand locality
+ *         operand global, local, parameter, or constant.                     
+ *
+ *  The combination of these three aspects is balanced only approximately.    
+ *
+ *  1. Statement Type:                                                        
+ *  -----------------             number
+ *
+ *     V1 = V2                     9
+ *       (incl. V1 = F(..)
+ *     V = Constant               12
+ *     Assignment,                 7
+ *       with array element
+ *     Assignment,                 6
+ *       with record component
+ *                                --
+ *                                34       34
+ *
+ *     X = Y +|-|"&&"|"|" Z        5
+ *     X = Y +|-|"==" Constant     6
+ *     X = X +|- 1                 3
+ *     X = Y *|/ Z                 2
+ *     X = Expression,             1
+ *           two operators
+ *     X = Expression,             1
+ *           three operators
+ *                                --
+ *                                18       18
+ *
+ *     if ....                    14
+ *       with "else"      7
+ *       without "else"   7
+ *           executed        3
+ *           not executed    4
+ *     for ...                     7  |  counted every time
+ *     while ...                   4  |  the loop condition
+ *     do ... while                1  |  is evaluated
+ *     switch ...                  1
+ *     break                       1
+ *     declaration with            1
+ *       initialization
+ *                                --
+ *                                34       34
+ *
+ *     P (...)  procedure call    11
+ *       user procedure      10
+ *       library procedure    1
+ *     X = F (...)
+ *             function  call      6
+ *       user function        5                                         
+ *       library function     1                                               
+ *                                --                                          
+ *                                17       17
+ *                                        ---
+ *                                        103
+ *
+ *    The average number of parameters in procedure or function calls
+ *    is 1.82 (not counting the function values aX *
+ *
+ *  2. Operators
+ *  ------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *    Arithmetic             32          50.8                                 
+ *
+ *       +                     21          33.3                              
+ *       -                      7          11.1                              
+ *       *                      3           4.8
+ *       / (int div)            1           1.6
+ *
+ *    Comparison             27           42.8
+ *
+ *       ==                     9           14.3
+ *       /=                     4            6.3
+ *       >                      1            1.6
+ *       <                      3            4.8
+ *       >=                     1            1.6
+ *       <=                     9           14.3
+ *
+ *    Logic                   4            6.3
+ *
+ *       && (AND-THEN)          1            1.6
+ *       |  (OR)                1            1.6
+ *       !  (NOT)               2            3.2
+ * 
+ *                           --          -----
+ *                           63          100.1
+ *
+ *
+ *  3. Operand Type (counted once per operand reference):
+ *  ---------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *     Integer               175        72.3 %
+ *     Character              45        18.6 %
+ *     Pointer                12         5.0 %
+ *     String30                6         2.5 %
+ *     Array                   2         0.8 %
+ *     Record                  2         0.8 %
+ *                           ---       -------
+ *                           242       100.0 %
+ *
+ *  When there is an access path leading to the final operand (e.g. a record
+ *  component), only the final data type on the access path is counted.       
+ *
+ *
+ *  4. Operand Locality:                                                      
+ *  -------------------
+ *                                number    approximate
+ *                                          percentage
+ *
+ *     local variable              114        47.1 %
+ *     global variable              22         9.1 %
+ *     parameter                    45        18.6 %
+ *        value                        23         9.5 %
+ *        reference                    22         9.1 %
+ *     function result               6         2.5 %
+ *     constant                     55        22.7 %
+ *                                 ---       -------
+ *                                 242       100.0 %
+ *
+ *  The program does not compute anything meaningful, but it is syntactically
+ *  and semantically correct. All variables have a value assigned to them
+ *  before they are used as a source operand.
+ *
+ *  There has been no explicit effort to account for the effects of a
+ *  cache, or to balance the use of long or short displacements for code or
+ *  data.
+ *
+ ***************************************************************************
+ */
+
+/* Compiler and system dependent definitions: */
+
+/* variables for time measurement: */
+
+#define HZ 1000000
+#define Too_Small_Time 1
+#define CLOCK_TYPE "rdcycle()"
+#define Start_Timer() Begin_Time = read_csr(mcycle)
+#define Stop_Timer() End_Time = read_csr(mcycle)
+
+
+
+#define Mic_secs_Per_Second     1000000
+#define NUMBER_OF_RUNS		500 /* Default number of runs */
+
+#ifdef  NOSTRUCTASSIGN
+#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
+#else
+#define structassign(d, s)      d = s
+#endif
+
+#ifdef  NOENUM
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+  typedef int   Enumeration;
+#else
+  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+#endif
+        /* for boolean and enumeration types in Ada, Pascal */
+
+/* General definitions: */
+
+#include <stdio.h>
+#include <string.h>
+                /* for strcpy, strcmp */
+
+#define Null 0 
+                /* Value of a Null pointer */
+#ifndef true
+#define true  1
+#endif
+#ifndef false
+#define false 0
+#endif
+
+typedef int     One_Thirty;
+typedef int     One_Fifty;
+typedef char    Capital_Letter;
+typedef int     Boolean;
+typedef char    Str_30 [31];
+typedef int     Arr_1_Dim [50];
+typedef int     Arr_2_Dim [50] [50];
+
+typedef struct record 
+    {
+    struct record *Ptr_Comp;
+    Enumeration    Discr;
+    union {
+          struct {
+                  Enumeration Enum_Comp;
+                  int         Int_Comp;
+                  char        Str_Comp [31];
+                  } var_1;
+          struct {
+                  Enumeration E_Comp_2;
+                  char        Str_2_Comp [31];
+                  } var_2;
+          struct {
+                  char        Ch_1_Comp;
+                  char        Ch_2_Comp;
+                  } var_3;
+          } variant;
+      } Rec_Type, *Rec_Pointer;
+
+#endif
diff -Naur apps-12.8.0/system/nsh/Make.dep apps/system/nsh/Make.dep
--- apps-12.8.0/system/nsh/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/system/nsh/Make.dep	2025-11-05 16:00:06.507070676 +0200
@@ -0,0 +1,82 @@
+# Gen Make.dep automatically
+nsh_main.c.home.laur.lucru.rtos.apps.system.nsh.o: nsh_main.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/boardctl.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/stat.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h
+sh_main.c.home.laur.lucru.rtos.apps.system.nsh.o: sh_main.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/apps/include/nshlib/nshlib.h \
+ /home/laur/lucru/rtos/nuttx/include/arpa/inet.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/netinet/in.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/socket.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/endian.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/endian.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/system/nsh/nsh_main-orig.c apps/system/nsh/nsh_main-orig.c
--- apps-12.8.0/system/nsh/nsh_main-orig.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/system/nsh/nsh_main-orig.c	2025-11-04 11:04:39.753101453 +0200
@@ -0,0 +1,87 @@
+/****************************************************************************
+ * apps/system/nsh/nsh_main.c
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#include <errno.h>
+#include <sched.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <sys/boardctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "nshlib/nshlib.h"
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: nsh_main
+ *
+ * Description:
+ *   This is the main logic for the case of the NSH task.  It will perform
+ *   one-time NSH initialization and start an interactive session on the
+ *   current console device.
+ *
+ ****************************************************************************/
+
+int main(int argc, FAR char *argv[])
+{
+  struct sched_param param;
+  int ret = 0;
+
+  /* Check the task priority that we were started with */
+
+  sched_getparam(0, &param);
+  if (param.sched_priority != CONFIG_SYSTEM_NSH_PRIORITY)
+    {
+      /* If not then set the priority to the configured priority */
+
+      param.sched_priority = CONFIG_SYSTEM_NSH_PRIORITY;
+      sched_setparam(0, &param);
+    }
+
+  /* Initialize the NSH library */
+
+  nsh_initialize();
+
+#ifdef CONFIG_NSH_CONSOLE
+  /* If the serial console front end is selected, run it on this thread */
+
+  ret = nsh_consolemain(argc, argv);
+
+  /* nsh_consolemain() should not return.  So if we get here, something
+   * is wrong.
+   */
+
+  dprintf(STDERR_FILENO, "ERROR: nsh_consolemain() returned: %d\n", ret);
+  ret = 1;
+#endif
+
+  return ret;
+}
diff -Naur apps-12.8.0/system/readline/Make.dep apps/system/readline/Make.dep
--- apps-12.8.0/system/readline/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/system/readline/Make.dep	2025-11-05 16:00:06.707987656 +0200
@@ -0,0 +1,237 @@
+# Gen Make.dep automatically
+readline.c.home.laur.lucru.rtos.apps.system.readline.o: readline.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h
+readline_fd.c.home.laur.lucru.rtos.apps.system.readline.o: readline_fd.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/termios.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h readline.h
+readline_stream.c.home.laur.lucru.rtos.apps.system.readline.o: \
+ readline_stream.c /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h
+readline_common.c.home.laur.lucru.rtos.apps.system.readline.o: \
+ readline_common.c /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/ascii.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/vt100.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/builtin.h \
+ /home/laur/lucru/rtos/apps/include/system/readline.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h readline.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/testing/getprime/Make.dep apps/testing/getprime/Make.dep
--- apps-12.8.0/testing/getprime/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/getprime/Make.dep	2025-11-05 16:00:06.836934374 +0200
@@ -0,0 +1,58 @@
+# Gen Make.dep automatically
+getprime_main.c.home.laur.lucru.rtos.apps.testing.getprime.o: \
+ getprime_main.c /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/testing/Kconfig apps/testing/Kconfig
--- apps-12.8.0/testing/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/Kconfig	2025-11-04 11:04:41.258199980 +0200
@@ -0,0 +1,60 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Testing"
+source "/home/laur/lucru/rtos/apps/testing/arch_libc/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/atomic/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/cachetest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/cmocka/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/cpuload/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/crypto/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/cxxsize/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/cxxtest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/drivertest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/epoll/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fatutf8/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fdsantest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fff/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fftest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fmemopen/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fopencookie/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/fstest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/getprime/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/himem_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/iob/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/irtest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/kasantest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/ltp/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/memstress/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/memtester/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/mm/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/monkey/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/mtd_config_fs/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/mtetest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/nand_sim/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/nist-sts/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/nxffs/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/open_memstream/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/ostest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/pcitest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/ramtest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/resmonitor/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/scanftest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/sd_bench/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/sd_stress/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/sensortest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/setest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/smart/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/smart_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/smp/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/stressapptest/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/testsuites/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/timerjitter/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/uclibcxx_test/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/unity/Kconfig"
+source "/home/laur/lucru/rtos/apps/testing/x86-64-ABI/Kconfig"
+endmenu # Testing
diff -Naur apps-12.8.0/testing/ostest/aio.c apps/testing/ostest/aio.c
--- apps-12.8.0/testing/ostest/aio.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/aio.c	2025-11-04 11:04:41.013342380 +0200
@@ -33,6 +33,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -158,30 +159,30 @@
         {
           /* Check if the I/O has completed */
 
-          printf("  list[%d]. result = %zd\n", i, aiocbp->aio_result);
+          _info("  list[%d]. result = %zd\n", i, aiocbp->aio_result);
           if (aiocbp->aio_lio_opcode == LIO_NOP)
             {
-              printf("     NO operation\n");
+              _info("     NO operation\n");
             }
           else if (aiocbp->aio_result == -EINPROGRESS)
             {
               /* No.. return -EINPROGRESS */
 
-              printf("     NOT finished\n");
+              _info("     NOT finished\n");
               return -EINPROGRESS;
             }
           else if (aiocbp->aio_result == -ECANCELED)
             {
               /* No.. return -EINPROGRESS */
 
-              printf("     Cancelled\n");
+              _info("     Cancelled\n");
             }
 
           /* Check for an I/O error */
 
           else if (aiocbp->aio_result < 0)
             {
-              printf("     ERROR: Failed I/O transfer\n");
+              _info("     ERROR: Failed I/O transfer\n");
               ASSERT(false);
             }
 
@@ -189,12 +190,12 @@
 
           else
             {
-              printf("     Successful completion\n");
+              _info("     Successful completion\n");
             }
         }
       else
         {
-          printf("  list[%d]. NULL\n", i);
+          _info("  list[%d]. NULL\n", i);
         }
     }
 
@@ -223,10 +224,10 @@
         {
           /* Check if the I/O has completed */
 
-          printf("  list[%d]. result = %zd\n", i, aiocbp->aio_result);
+          _info("  list[%d]. result = %zd\n", i, aiocbp->aio_result);
           if (aiocbp->aio_lio_opcode == LIO_NOP)
             {
-              printf("     NO operation\n");
+              _info("     NO operation\n");
               g_aiocb[i] = NULL;
               completed++;
             }
@@ -234,13 +235,13 @@
             {
               /* No.. return -EINPROGRESS */
 
-              printf("     NOT finished\n");
+              _info("     NOT finished\n");
             }
           else if (aiocbp->aio_result == -ECANCELED)
             {
               /* No.. return -EINPROGRESS */
 
-              printf("     Cancelled\n");
+              _info("     Cancelled\n");
               g_aiocb[i] = NULL;
               completed++;
             }
@@ -249,7 +250,7 @@
 
           else if (aiocbp->aio_result < 0)
             {
-              printf("     ERROR: Failed I/O transfer\n");
+              _info("     ERROR: Failed I/O transfer\n");
               ASSERT(false);
               g_aiocb[i] = NULL;
               completed++;
@@ -259,14 +260,14 @@
 
           else
             {
-              printf("     Successful completion\n");
+              _info("     Successful completion\n");
               g_aiocb[i] = NULL;
               completed++;
             }
         }
       else
         {
-          printf("  list[%d]. NULL\n", i);
+          _info("  list[%d]. NULL\n", i);
         }
     }
 
@@ -289,7 +290,7 @@
   int ret;
   int i;
 
-  /* Block all signals except for SIGUSR1 and SIGALRM (for sleep) */
+  /* Block all signals except for SIGUSR1 and SIGALRM (for usleep) */
 
   sigfillset(&set);
   sigdelset(&set, SIGUSR1);
@@ -298,11 +299,11 @@
 
   /* Case 1: Poll for transfer complete */
 
-  printf("AIO test case 1: Poll for transfer complete\n");
+  _info("AIO test case 1: Poll for transfer complete\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
              AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -312,7 +313,7 @@
   ret = lio_listio(LIO_NOWAIT, g_aiocb, AIO_NCTRLBLKS, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -335,11 +336,11 @@
 
   usleep(500 * 1000);
 
-  printf("AIO test case 2: Use LIO_WAIT for transfer complete\n");
+  _info("AIO test case 2: Use LIO_WAIT for transfer complete\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
              AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -349,7 +350,7 @@
   ret = lio_listio(LIO_WAIT, g_aiocb, AIO_NCTRLBLKS, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -357,7 +358,7 @@
   ret = check_done();
   if (ret < 0)
     {
-      printf("aio_test: ERROR: Not done\n");
+      _info("aio_test: ERROR: Not done\n");
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -373,11 +374,11 @@
 
   usleep(500 * 1000);
 
-  printf("AIO test case 3: Use aio_suspend for transfer complete\n");
+  _info("AIO test case 3: Use aio_suspend for transfer complete\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
               AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -387,7 +388,7 @@
   ret = lio_listio(LIO_NOWAIT, g_aiocb, AIO_NCTRLBLKS, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -395,12 +396,12 @@
   total = 1; /* One entry was initially NULL */
   for (i = 1; i <= AIO_NCTRLBLKS; i++)
     {
-      printf("  Calling aio_suspend #%d\n", i);
+      _info("  Calling aio_suspend #%d\n", i);
       ret = aio_suspend((FAR const struct aiocb *const *)g_aiocb,
                          AIO_NCTRLBLKS, NULL);
       if (ret < 0)
         {
-          printf("aio_test: ERROR: aio_suspend failed: %d\n", errno);
+          _info("aio_test: ERROR: aio_suspend failed: %d\n", errno);
           ASSERT(false);
           goto errout_with_fildes;
         }
@@ -408,13 +409,13 @@
       completed = remove_done();
       if (completed < 1)
         {
-          printf("aio_test: ERROR: Signalled, but no I/O completed\n");
+          _info("aio_test: ERROR: Signalled, but no I/O completed\n");
           ASSERT(false);
           goto errout_with_fildes;
         }
 
       total += completed;
-      printf("  Completed=%d\n", total);
+      _info("  Completed=%d\n", total);
 
       if (total >= AIO_NCTRLBLKS)
         {
@@ -424,7 +425,7 @@
 
   if (total != AIO_NCTRLBLKS)
     {
-      printf("aio_test: ERROR: Total is %d, should be %d\n",
+      _info("aio_test: ERROR: Total is %d, should be %d\n",
               total, AIO_NCTRLBLKS);
       ASSERT(false);
       goto errout_with_fildes;
@@ -441,11 +442,11 @@
 
   usleep(500 * 1000);
 
-  printf("AIO test case 4: Use individual signals for transfer complete\n");
+  _info("AIO test case 4: Use individual signals for transfer complete\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
               AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -456,7 +457,7 @@
   ret = lio_listio(LIO_NOWAIT, g_aiocb, AIO_NCTRLBLKS, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -475,11 +476,11 @@
               int errcode = errno;
               if (errcode == EINTR)
                 {
-                  printf("  Interrupted by a signal)\n");
+                  _info("  Interrupted by a signal)\n");
                 }
               else
                 {
-                  printf("aio_test: ERROR: sigwaitinfo failed: %d\n",
+                  _info("aio_test: ERROR: sigwaitinfo failed: %d\n",
                           errcode);
                   ASSERT(false);
                   goto errout_with_fildes;
@@ -487,7 +488,7 @@
             }
           else
             {
-              printf("  Received signal %d\n", status);
+              _info("  Received signal %d\n", status);
             }
         }
     }
@@ -504,12 +505,12 @@
 
   usleep(500 * 1000);
 
-  printf("AIO test case 5:"
+  _info("AIO test case 5:"
          " Use list complete signal for transfer complete\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
               AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -524,7 +525,7 @@
   ret = lio_listio(LIO_NOWAIT, g_aiocb, AIO_NCTRLBLKS, &sig);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -543,11 +544,11 @@
               int errcode = errno;
               if (errcode == EINTR)
                 {
-                  printf("aio_test: Interrupted by a signal\n");
+                  _info("aio_test: Interrupted by a signal\n");
                 }
               else
                 {
-                  printf("aio_test: ERROR: sigwaitinfo failed: %d\n",
+                  _info("aio_test: ERROR: sigwaitinfo failed: %d\n",
                           errcode);
                   ASSERT(false);
                   goto errout_with_fildes;
@@ -568,11 +569,11 @@
 
   usleep(500 * 1000);
 
-  printf("AIO test case 6: Cancel I/O by AIO control block\n");
+  _info("AIO test case 6: Cancel I/O by AIO control block\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
               AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -582,7 +583,7 @@
   ret = lio_listio(LIO_NOWAIT, g_aiocb, AIO_NCTRLBLKS, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -590,12 +591,12 @@
   ret = aio_cancel(g_fildes, g_aiocb[2]);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: aio_cancel failed: %d\n", errno);
+      _info("aio_test: ERROR: aio_cancel failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
 
-  printf("  aio_cancel return %d\n", ret);
+  _info("  aio_cancel return %d\n", ret);
 
   do
     {
@@ -615,11 +616,11 @@
 
   usleep(500 * 1000);
 
-  printf("AIO test case 7:Cancel I/O by file descriptor\n");
+  _info("AIO test case 7:Cancel I/O by file descriptor\n");
   g_fildes = open(AIO_FILEPATH, O_RDWR | O_CREAT | O_TRUNC);
   if (g_fildes < 0)
     {
-      printf("aio_test: ERROR: Failed to open %s: %d\n",
+      _info("aio_test: ERROR: Failed to open %s: %d\n",
               AIO_FILEPATH, errno);
       ASSERT(false);
       goto errout_with_procmask;
@@ -629,7 +630,7 @@
   ret = lio_listio(LIO_NOWAIT, g_aiocb, AIO_NCTRLBLKS, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: lio_listio failed: %d\n", errno);
+      _info("aio_test: ERROR: lio_listio failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
@@ -637,12 +638,12 @@
   ret = aio_cancel(g_fildes, NULL);
   if (ret < 0)
     {
-      printf("aio_test: ERROR: aio_cancel failed: %d\n", errno);
+      _info("aio_test: ERROR: aio_cancel failed: %d\n", errno);
       ASSERT(false);
       goto errout_with_fildes;
     }
 
-  printf("  aio_cancel return %d\n", ret);
+  _info("  aio_cancel return %d\n", ret);
 
   do
     {
@@ -652,7 +653,7 @@
   while (ret < 0);
 
   sigprocmask(SIG_SETMASK, &oset, NULL);
-  printf("aio_test: Test completed successfully\n");
+  _info("aio_test: Test completed successfully\n");
   return;
 
 errout_with_fildes:
@@ -660,7 +661,7 @@
   g_fildes = -1;
 errout_with_procmask:
   sigprocmask(SIG_SETMASK, &oset, NULL);
-  printf("aio_test: ERROR: Test aborted\n");
+  _info("aio_test: ERROR: Test aborted\n");
 }
 
 #endif /* CONFIG_FS_AIO */
diff -Naur apps-12.8.0/testing/ostest/barrier.c apps/testing/ostest/barrier.c
--- apps-12.8.0/testing/ostest/barrier.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/barrier.c	2025-11-04 11:04:41.004347611 +0200
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 #include "ostest.h"
@@ -56,30 +57,30 @@
   int id  = (int)((intptr_t)parameter);
   int status;
 
-  printf("barrier_func: Thread %d started\n",  id);
+  _info("barrier_func: Thread %d started\n",  id);
   usleep(HALF_SECOND);
 
   /* Wait at the barrier until all threads are synchronized. */
 
-  printf("barrier_func: Thread %d calling pthread_barrier_wait()\n",
+  _info("barrier_func: Thread %d calling pthread_barrier_wait()\n",
          id);
   FFLUSH();
   status = pthread_barrier_wait(&barrier);
   if (status == 0)
     {
-      printf("barrier_func: Thread %d, back with "
+      _info("barrier_func: Thread %d, back with "
              "status=0 (I am not special)\n",
              id);
     }
   else if (status == PTHREAD_BARRIER_SERIAL_THREAD)
     {
-      printf("barrier_func: Thread %d, back with "
+      _info("barrier_func: Thread %d, back with "
              "status=PTHREAD_BARRIER_SERIAL_THREAD (I AM SPECIAL)\n",
              id);
     }
   else
     {
-      printf("barrier_func: ERROR thread %d could not get semaphore value\n",
+      _info("barrier_func: ERROR thread %d could not get semaphore value\n",
              id);
       ASSERT(false);
     }
@@ -87,7 +88,7 @@
   FFLUSH();
 
   usleep(HALF_SECOND);
-  printf("barrier_func: Thread %d done\n",  id);
+  _info("barrier_func: Thread %d done\n",  id);
   FFLUSH();
   return NULL;
 }
@@ -109,14 +110,14 @@
   int status;
   int i;
 
-  printf("barrier_test: Initializing barrier\n");
+  _info("barrier_test: Initializing barrier\n");
 
   /* Create the barrier */
 
   status = pthread_barrierattr_init(&barrierattr);
   if (status != OK)
     {
-      printf("barrier_test: pthread_barrierattr_init failed, status=%d\n",
+      _info("barrier_test: pthread_barrierattr_init failed, status=%d\n",
              status);
     }
 
@@ -124,7 +125,7 @@
                                 CONFIG_TESTING_OSTEST_NBARRIER_THREADS);
   if (status != OK)
     {
-      printf("barrier_test: pthread_barrier_init failed, status=%d\n",
+      _info("barrier_test: pthread_barrier_init failed, status=%d\n",
              status);
     }
 
@@ -133,7 +134,7 @@
   status = pthread_attr_init(&attr);
   if (status != OK)
     {
-      printf("barrier_test: pthread_attr_init failed, status=%d\n",
+      _info("barrier_test: pthread_attr_init failed, status=%d\n",
               status);
     }
 
@@ -143,15 +144,15 @@
                               (pthread_addr_t)((uintptr_t)i));
       if (status != 0)
         {
-          printf("barrier_test: ERROR thread %d create, status=%d\n",
+          _info("barrier_test: ERROR thread %d create, status=%d\n",
                  i, status);
-          printf("barrier_test: Test aborted with waiting threads\n");
+          _info("barrier_test: Test aborted with waiting threads\n");
           ASSERT(false);
           goto abort_test;
         }
       else
         {
-          printf("barrier_test: Thread %d created\n", i);
+          _info("barrier_test: Thread %d created\n", i);
         }
     }
 
@@ -164,13 +165,13 @@
       status = pthread_join(barrier_thread[i], &result);
       if (status != 0)
         {
-          printf("barrier_test: ERROR thread %d join, status=%d\n",
+          _info("barrier_test: ERROR thread %d join, status=%d\n",
                  i, status);
           ASSERT(false);
         }
       else
         {
-          printf("barrier_test: Thread %d completed with result=%p\n",
+          _info("barrier_test: Thread %d completed with result=%p\n",
                  i, result);
         }
     }
@@ -181,14 +182,14 @@
   status = pthread_barrier_destroy(&barrier);
   if (status != OK)
     {
-      printf("barrier_test: pthread_barrier_destroy failed, status=%d\n",
+      _info("barrier_test: pthread_barrier_destroy failed, status=%d\n",
              status);
     }
 
   status = pthread_barrierattr_destroy(&barrierattr);
   if (status != OK)
     {
-      printf("barrier_test: pthread_barrierattr_destroy failed, status=%d\n",
+      _info("barrier_test: pthread_barrierattr_destroy failed, status=%d\n",
              status);
     }
 
diff -Naur apps-12.8.0/testing/ostest/cancel.c apps/testing/ostest/cancel.c
--- apps-12.8.0/testing/ostest/cancel.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/cancel.c	2025-11-04 11:04:41.008345286 +0200
@@ -33,6 +33,7 @@
 #include <pthread.h>
 #include <signal.h>
 #include <stdio.h>
+#include <debug.h>
 #include <time.h>
 #include <unistd.h>
 #include <semaphore.h>
@@ -54,7 +55,7 @@
 #if CONFIG_TLS_NCLEANUP > 0
 static void sem_cleaner(FAR void *arg)
 {
-  printf("sem_cleaner #%u\n", (unsigned int)((uintptr_t)arg));
+  _info("sem_cleaner #%u\n", (unsigned int)((uintptr_t)arg));
 }
 #endif
 
@@ -75,27 +76,27 @@
 
   /* Take the mutex */
 
-  printf("sem_waiter: Taking mutex\n");
+  _info("sem_waiter: Taking mutex\n");
   status = pthread_mutex_lock(&mutex);
   if (status != 0)
     {
-       printf("sem_waiter: ERROR pthread_mutex_lock failed, status=%d\n",
+       _info("sem_waiter: ERROR pthread_mutex_lock failed, status=%d\n",
                status);
        ASSERT(false);
     }
 
   sem_post(&sem_thread_started);
-  printf("sem_waiter: Starting wait for condition\n");
+  _info("sem_waiter: Starting wait for condition\n");
 
   /* Are we a non-cancelable thread?   Yes, set the non-cancelable state */
 
   if (!parameter)
     {
-      printf("sem_waiter: Setting non-cancelable\n");
+      _info("sem_waiter: Setting non-cancelable\n");
       status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
       if (status != 0)
         {
-           printf("sem_waiter: "
+           _info("sem_waiter: "
                   "ERROR pthread_setcancelstate failed, status=%d\n",
                    status);
            ASSERT(false);
@@ -109,7 +110,7 @@
   status = pthread_cond_wait(&cond, &mutex);
   if (status != 0)
     {
-      printf("sem_waiter: ERROR pthread_cond_wait failed, status=%d\n",
+      _info("sem_waiter: ERROR pthread_cond_wait failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -118,11 +119,11 @@
     {
       /* Release the mutex */
 
-      printf("sem_waiter: Releasing mutex\n");
+      _info("sem_waiter: Releasing mutex\n");
       status = pthread_mutex_unlock(&mutex);
       if (status != 0)
         {
-          printf("sem_waiter: "
+          _info("sem_waiter: "
                  "ERROR pthread_mutex_unlock failed, status=%d\n",
                   status);
           ASSERT(false);
@@ -130,26 +131,26 @@
 
       /* Set the cancelable state */
 
-      printf("sem_waiter: Setting cancelable\n");
+      _info("sem_waiter: Setting cancelable\n");
       status = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
       if (status != 0)
         {
-          printf("sem_waiter: "
+          _info("sem_waiter: "
                  "ERROR pthread_setcancelstate failed, status=%d\n", status);
           ASSERT(false);
         }
     }
   else
     {
-      printf("sem_waiter: "
+      _info("sem_waiter: "
              "ERROR pthread_cond_wait returned after being cancelled!\n");
       ASSERT(false);
     }
 
   /* Why is this here?  Because pthread_setcancelstate() is not a
-   * cancellation point and printf() may or may not be a cancellation point
-   * (OpenGroup.org allows printf to optionally be a cancellation point).
-   * If printf() is not a cancellation point, then the thread will never
+   * cancellation point and _info() may or may not be a cancellation point
+   * (OpenGroup.org allows _info to optionally be a cancellation point).
+   * If _info() is not a cancellation point, then the thread will never
    * be cancelled in the deferred cancellation mode and will instead exit
    * with no error.  The pthread_testcancel() is needed to correctly test
    * that cancellation has been re-enabled.
@@ -157,7 +158,7 @@
 
   pthread_testcancel();
 
-  printf("sem_waiter: Exit with status 0x12345678\n");
+  _info("sem_waiter: Exit with status 0x12345678\n");
   pthread_exit((pthread_addr_t)0x12345678);
   return NULL;
 }
@@ -168,10 +169,10 @@
 {
   FAR mqd_t *mqcancel = (FAR mqd_t *)arg;
 
-  printf("mqueue_cleaner... closing message queue\n");
+  _info("mqueue_cleaner... closing message queue\n");
   if (mq_close(*mqcancel) < 0)
     {
-      printf("mqueue_cleaner: ERROR mq_close failed\n");
+      _info("mqueue_cleaner: ERROR mq_close failed\n");
       ASSERT(false);
     }
 }
@@ -199,26 +200,26 @@
   mqcancel = mq_open("mqcancel", O_RDONLY | O_CREAT, 0666, &attr);
   if (mqcancel < 0)
     {
-      printf("mqueue_waiter: ERROR mq_open failed\n");
+      _info("mqueue_waiter: ERROR mq_open failed\n");
       ASSERT(false);
       pthread_exit((pthread_addr_t)0xdeadbeef);
     }
 
   /* Now wait for the message that will never come */
 
-  printf("mqueue_waiter: Waiting to receive a message...\n");
+  _info("mqueue_waiter: Waiting to receive a message...\n");
   nbytes = mq_receive(mqcancel, msgbuffer, CONFIG_MQ_MAXMSGSIZE, 0);
 
   pthread_testcancel();
-  printf("mqueue_waiter: Awakened with %d\n", (int)nbytes);
+  _info("mqueue_waiter: Awakened with %d\n", (int)nbytes);
 
   if (mq_close(mqcancel) < 0)
     {
-      printf("mqueue_waiter: ERROR mq_close failed\n");
+      _info("mqueue_waiter: ERROR mq_close failed\n");
       ASSERT(false);
     }
 
-  printf("mqueue_waiter: Exit with status 0x12345678\n");
+  _info("mqueue_waiter: Exit with status 0x12345678\n");
   pthread_exit((pthread_addr_t)0x12345678);
   return NULL;
 }
@@ -233,14 +234,14 @@
 
   /* Wait for a signal that will never be delivered */
 
-  printf("sig_waiter: Waiting to receive signal...\n");
+  _info("sig_waiter: Waiting to receive signal...\n");
 
   sigemptyset(&set);
   ret = sigwaitinfo(&set, &info);
 
   pthread_testcancel();
-  printf("sig_waiter: Awakened with %d\n", ret);
-  printf("sig_waiter: Exit with status 0x12345678\n");
+  _info("sig_waiter: Awakened with %d\n", ret);
+  _info("sig_waiter: Exit with status 0x12345678\n");
   pthread_exit((pthread_addr_t)0x12345678);
   return NULL;
 }
@@ -265,11 +266,11 @@
 
   /* Set the non-cancelable state */
 
-  printf("asynch_waiter: Setting non-cancelable\n");
+  _info("asynch_waiter: Setting non-cancelable\n");
   status = pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, NULL);
   if (status != 0)
     {
-       printf("asynch_waiter: "
+       _info("asynch_waiter: "
               "ERROR pthread_setcancelstate failed, status=%d\n",
                status);
        ASSERT(false);
@@ -277,11 +278,11 @@
 
   /* Set the asynchronous cancellation type */
 
-  printf("asynch_waiter: Setting synchronous cancellation type\n");
+  _info("asynch_waiter: Setting synchronous cancellation type\n");
   status = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
   if (status != 0)
     {
-       printf("asynch_waiter: "
+       _info("asynch_waiter: "
               "ERROR pthread_setcanceltype failed, status=%d\n",
                status);
        ASSERT(false);
@@ -295,16 +296,16 @@
 
   /* We should be canceled when restore the cancelable state. */
 
-  printf("asynch_waiter: Restoring cancelable state\n");
+  _info("asynch_waiter: Restoring cancelable state\n");
 
-  printf("asynch_waiter: Setting cancelable\n");
+  _info("asynch_waiter: Setting cancelable\n");
   status = pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
 
   /* We should not get here!!! */
 
   if (status != 0)
     {
-      printf("asynch_waiter: "
+      _info("asynch_waiter: "
              "ERROR pthread_setcancelstate failed, status=%d\n",
              status);
       ASSERT(false);
@@ -312,7 +313,7 @@
 
   /* Set the cancelable state */
 
-  printf("asynch_waiter: Exit with status 0x12345678\n");
+  _info("asynch_waiter: Exit with status 0x12345678\n");
   pthread_exit((pthread_addr_t)0x12345678);
   return NULL;
 }
@@ -326,22 +327,22 @@
 
   /* Initialize the mutex */
 
-  printf("start_thread: Initializing mutex\n");
+  _info("start_thread: Initializing mutex\n");
   status = pthread_mutex_init(&mutex, NULL);
   if (status != 0)
     {
-      printf("start_thread: "
+      _info("start_thread: "
              "ERROR pthread_mutex_init failed, status=%d\n", status);
       ASSERT(false);
     }
 
   /* Initialize the condition variable */
 
-  printf("start_thread: Initializing cond\n");
+  _info("start_thread: Initializing cond\n");
   status = pthread_cond_init(&cond, NULL);
   if (status != 0)
     {
-      printf("start_thread: ERROR pthread_cond_init failed, status=%d\n",
+      _info("start_thread: ERROR pthread_cond_init failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -351,7 +352,7 @@
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("start_thread: "
+      _info("start_thread: "
              "ERROR pthread_attr_init failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -359,7 +360,7 @@
   status = pthread_attr_setstacksize(&attr, STACKSIZE);
   if (status != 0)
     {
-      printf("start_thread: "
+      _info("start_thread: "
              "ERROR pthread_attr_setstacksize failed, status=%d\n",
               status);
       ASSERT(false);
@@ -367,19 +368,19 @@
 
   /* Start the waiter thread  */
 
-  printf("start_thread: Starting thread\n");
+  _info("start_thread: Starting thread\n");
   status = pthread_create(waiter, &attr, entry,
                           (pthread_addr_t)((uintptr_t)cancelable));
   if (status != 0)
     {
-      printf("start_thread: ERROR pthread_create failed, status=%d\n",
+      _info("start_thread: ERROR pthread_create failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
   /* Make sure that the waiter thread gets a chance to run */
 
-  printf("start_thread: Yielding\n");
+  _info("start_thread: Yielding\n");
   pthread_yield();
 }
 
@@ -390,11 +391,11 @@
 
   /* Destroy the condition variable */
 
-  printf("restart_thread: Destroying cond\n");
+  _info("restart_thread: Destroying cond\n");
   status = pthread_cond_destroy(&cond);
   if (status != 0)
     {
-      printf("restart_thread: "
+      _info("restart_thread: "
              "ERROR pthread_cond_destroy failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -404,18 +405,18 @@
    * is possible to destroy a locked mutex owned by a cancelled thread.
    */
 
-  printf("restart_thread: Destroying mutex\n");
+  _info("restart_thread: Destroying mutex\n");
   status = pthread_mutex_destroy(&mutex);
   if (status != 0)
     {
-      printf("restart_thread: "
+      _info("restart_thread: "
              "ERROR pthread_mutex_destroy failed, status=%d\n", status);
       ASSERT(false);
     }
 
   /* Then restart the thread */
 
-  printf("restart_thread: Re-starting thread\n");
+  _info("restart_thread: Re-starting thread\n");
   start_thread(entry, waiter, cancelable);
 }
 
@@ -439,8 +440,8 @@
 
   /* Start the waiter thread  */
 
-  printf("cancel_test: Test 1a: Normal Cancellation\n");
-  printf("cancel_test: Starting thread\n");
+  _info("cancel_test: Test 1a: Normal Cancellation\n");
+  _info("cancel_test: Starting thread\n");
   start_thread(sem_waiter, &waiter, 1);
 
   /* Then cancel it.  It should be in the usleep now -- wait bit to
@@ -455,11 +456,11 @@
 
   pthread_mutex_unlock(&mutex);
 
-  printf("cancel_test: Canceling thread\n");
+  _info("cancel_test: Canceling thread\n");
   status = pthread_cancel(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cancel failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cancel failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -468,33 +469,33 @@
    * we will have a memory leak!)
    */
 
-  printf("cancel_test: Joining\n");
+  _info("cancel_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_join failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_join failed, status=%d\n",
               status);
       ASSERT(false);
     }
   else
     {
-      printf("cancel_test: waiter exited with result=%p\n", result);
+      _info("cancel_test: waiter exited with result=%p\n", result);
       if (result != PTHREAD_CANCELED)
         {
-          printf("cancel_test: ERROR expected result=%p\n",
+          _info("cancel_test: ERROR expected result=%p\n",
                   PTHREAD_CANCELED);
           ASSERT(false);
         }
       else
         {
-          printf("cancel_test:"
+          _info("cancel_test:"
                  " PASS thread terminated with PTHREAD_CANCELED\n");
         }
     }
 
   /* Test 2: Asynchronous Cancel ********************************************/
 
-  printf("cancel_test: Test 2: Asynchronous Cancellation\n");
+  _info("cancel_test: Test 2: Asynchronous Cancellation\n");
 
 #ifdef CONFIG_CANCELLATION_POINTS
   /* If cancellation points were enabled, then the first test was done
@@ -506,7 +507,7 @@
 
   /* Start the waiter thread  */
 
-  printf("cancel_test: Starting thread\n");
+  _info("cancel_test: Starting thread\n");
   restart_thread(asynch_waiter, &waiter, 1);
 
   /* Then cancel it.  It should be in the pthread_cond_wait now -- wait
@@ -515,11 +516,11 @@
 
   usleep(100 * 1000);
 
-  printf("cancel_test: Canceling thread\n");
+  _info("cancel_test: Canceling thread\n");
   status = pthread_cancel(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cancel failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cancel failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -528,37 +529,37 @@
    * we will have a memory leak!)
    */
 
-  printf("cancel_test: Joining\n");
+  _info("cancel_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_join failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_join failed, status=%d\n",
               status);
       ASSERT(false);
     }
   else
     {
-      printf("cancel_test: waiter exited with result=%p\n", result);
+      _info("cancel_test: waiter exited with result=%p\n", result);
       if (result != PTHREAD_CANCELED)
         {
-          printf("cancel_test: ERROR expected result=%p\n",
+          _info("cancel_test: ERROR expected result=%p\n",
                   PTHREAD_CANCELED);
           ASSERT(false);
         }
       else
         {
-          printf("cancel_test: "
+          _info("cancel_test: "
                  "PASS thread terminated with PTHREAD_CANCELED\n");
         }
     }
 #else
-  printf("... Skipped\n");
+  _info("... Skipped\n");
 #endif
 
   /* Test 3: Cancel Detached Thread *****************************************/
 
-  printf("cancel_test: Test 3: Cancellation of detached thread\n");
-  printf("cancel_test: Re-starting thread\n");
+  _info("cancel_test: Test 3: Cancellation of detached thread\n");
+  _info("cancel_test: Re-starting thread\n");
   restart_thread(sem_waiter, &waiter, 1);
 
   /* Detach the thread */
@@ -566,7 +567,7 @@
   status = pthread_detach(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_detach, status=%d\n", status);
+      _info("cancel_test: ERROR pthread_detach, status=%d\n", status);
       ASSERT(false);
     }
 
@@ -582,11 +583,11 @@
 
   pthread_mutex_unlock(&mutex);
 
-  printf("cancel_test: Canceling thread\n");
+  _info("cancel_test: Canceling thread\n");
   status = pthread_cancel(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cancel failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cancel failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -602,23 +603,23 @@
 
   /* Join should now fail */
 
-  printf("cancel_test: Joining\n");
+  _info("cancel_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status == 0)
     {
-      printf("cancel_test: ERROR pthread_join succeeded\n");
+      _info("cancel_test: ERROR pthread_join succeeded\n");
       ASSERT(false);
     }
   else if (status != ESRCH)
     {
-      printf("cancel_test:"
+      _info("cancel_test:"
              " ERROR pthread_join failed but with wrong status=%d\n",
              status);
       ASSERT(false);
     }
   else
     {
-      printf("cancel_test: PASS pthread_join failed with status=ESRCH\n");
+      _info("cancel_test: PASS pthread_join failed with status=ESRCH\n");
     }
 
   /* Test 4: Non-cancelable threads *****************************************/
@@ -627,8 +628,8 @@
    * could be re-designed so that it does not depend on signals.
    */
 
-  printf("cancel_test: Test 5: Non-cancelable threads\n");
-  printf("cancel_test: Re-starting thread (non-cancelable)\n");
+  _info("cancel_test: Test 5: Non-cancelable threads\n");
+  _info("cancel_test: Re-starting thread (non-cancelable)\n");
   restart_thread(sem_waiter, &waiter, 0);
 
   /* Give the thread a chance to run an to set the non-cancelable state.
@@ -652,11 +653,11 @@
 
   pthread_mutex_unlock(&mutex);
 
-  printf("cancel_test: Canceling thread\n");
+  _info("cancel_test: Canceling thread\n");
   status = pthread_cancel(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cancel failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cancel failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -668,7 +669,7 @@
   status = pthread_mutex_lock(&mutex);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_mutex_lock failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_mutex_lock failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -676,7 +677,7 @@
   status = pthread_cond_signal(&cond);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cond_signal failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cond_signal failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -684,7 +685,7 @@
   status = pthread_mutex_unlock(&mutex);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_mutex_unlock failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_mutex_unlock failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -693,31 +694,31 @@
    * we will have a memory leak!)
    */
 
-  printf("cancel_test: Joining\n");
+  _info("cancel_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_join failed, status=%d\n", status);
+      _info("cancel_test: ERROR pthread_join failed, status=%d\n", status);
       ASSERT(false);
     }
   else
     {
-      printf("cancel_test: waiter exited with result=%p\n", result);
+      _info("cancel_test: waiter exited with result=%p\n", result);
       if (result != PTHREAD_CANCELED)
         {
-          printf("cancel_test: ERROR expected result=%p\n",
+          _info("cancel_test: ERROR expected result=%p\n",
                   PTHREAD_CANCELED);
           ASSERT(false);
         }
       else
         {
-          printf("cancel_test: "
+          _info("cancel_test: "
                  "PASS thread terminated with PTHREAD_CANCELED\n");
         }
     }
 
-  printf("cancel_test: Test 6: Cancel message queue wait\n");
-  printf("cancel_test: Starting thread (cancelable)\n");
+  _info("cancel_test: Test 6: Cancel message queue wait\n");
+  _info("cancel_test: Starting thread (cancelable)\n");
   sem_destroy(&sem_thread_started);
 
 #if !defined(CONFIG_DISABLE_MQUEUE) && defined(CONFIG_CANCELLATION_POINTS)
@@ -732,7 +733,7 @@
   mqcancel = mq_open("mqcancel", O_WRONLY | O_CREAT, 0666, &attr);
   if (mqcancel == (mqd_t)-1)
     {
-      printf("sender_thread: ERROR mq_open failed\n");
+      _info("sender_thread: ERROR mq_open failed\n");
       ASSERT(false);
       pthread_exit((pthread_addr_t)1);
     }
@@ -747,11 +748,11 @@
 
   usleep(75 * 1000);
 
-  printf("cancel_test: Canceling thread\n");
+  _info("cancel_test: Canceling thread\n");
   status = pthread_cancel(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cancel failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cancel failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -760,26 +761,26 @@
    * we will have a memory leak!)
    */
 
-  printf("cancel_test: Joining\n");
+  _info("cancel_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_join failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_join failed, status=%d\n",
              status);
       ASSERT(false);
     }
   else
     {
-      printf("cancel_test: waiter exited with result=%p\n", result);
+      _info("cancel_test: waiter exited with result=%p\n", result);
       if (result != PTHREAD_CANCELED)
         {
-          printf("cancel_test: ERROR expected result=%p\n",
+          _info("cancel_test: ERROR expected result=%p\n",
                  PTHREAD_CANCELED);
           ASSERT(false);
         }
       else
         {
-          printf("cancel_test: "
+          _info("cancel_test: "
                  "PASS thread terminated with PTHREAD_CANCELED\n");
         }
     }
@@ -788,15 +789,15 @@
 
   if (mq_close(mqcancel) < 0)
     {
-      printf("sender_thread: ERROR mq_close failed\n");
+      _info("sender_thread: ERROR mq_close failed\n");
       ASSERT(false);
     }
 #else
-  printf("Skipped\n");
+  _info("Skipped\n");
 #endif
 
-  printf("cancel_test: Test 7: Cancel signal wait\n");
-  printf("cancel_test: Starting thread (cancelable)\n");
+  _info("cancel_test: Test 7: Cancel signal wait\n");
+  _info("cancel_test: Starting thread (cancelable)\n");
 
 #ifdef CONFIG_CANCELLATION_POINTS
   /* Start the sig_waiter thread */
@@ -809,11 +810,11 @@
 
   usleep(75 * 1000);
 
-  printf("cancel_test: Canceling thread\n");
+  _info("cancel_test: Canceling thread\n");
   status = pthread_cancel(waiter);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_cancel failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_cancel failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -822,30 +823,30 @@
    * we will have a memory leak!)
    */
 
-  printf("cancel_test: Joining\n");
+  _info("cancel_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("cancel_test: ERROR pthread_join failed, status=%d\n",
+      _info("cancel_test: ERROR pthread_join failed, status=%d\n",
              status);
       ASSERT(false);
     }
   else
     {
-      printf("cancel_test: waiter exited with result=%p\n", result);
+      _info("cancel_test: waiter exited with result=%p\n", result);
       if (result != PTHREAD_CANCELED)
         {
-          printf("cancel_test: ERROR expected result=%p\n",
+          _info("cancel_test: ERROR expected result=%p\n",
                  PTHREAD_CANCELED);
           ASSERT(false);
         }
       else
         {
-          printf("cancel_test: "
+          _info("cancel_test: "
                  "PASS thread terminated with PTHREAD_CANCELED\n");
         }
     }
 #else
-  printf("Skipped\n");
+  _info("Skipped\n");
 #endif
 }
diff -Naur apps-12.8.0/testing/ostest/cond.c apps/testing/ostest/cond.c
--- apps-12.8.0/testing/ostest/cond.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/cond.c	2025-11-04 11:04:41.014341799 +0200
@@ -28,6 +28,7 @@
 #include <pthread.h>
 #include <sched.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 #include <semaphore.h>
 
@@ -72,7 +73,7 @@
 {
   int status;
 
-  printf("waiter_thread: Started\n");
+  _info("waiter_thread: Started\n");
 
   for (; ; )
     {
@@ -85,7 +86,7 @@
       sem_post(&sem_thread_started);
       if (status != 0)
         {
-          printf("waiter_thread: "
+          _info("waiter_thread: "
                  "ERROR pthread_mutex_lock failed, status=%d\n", status);
           ASSERT(false);
           waiter_nerrors++;
@@ -111,7 +112,7 @@
 
           if (status != 0)
             {
-              printf("waiter_thread: "
+              _info("waiter_thread: "
                      "ERROR pthread_cond_wait failed, status=%d\n",
                      status);
               ASSERT(false);
@@ -125,7 +126,7 @@
 
       if (!data_available)
         {
-          printf("waiter_thread: ERROR data not available after wait\n");
+          _info("waiter_thread: ERROR data not available after wait\n");
           ASSERT(false);
           waiter_nerrors++;
         }
@@ -139,7 +140,7 @@
       status = pthread_mutex_unlock(&mutex);
       if (status != 0)
         {
-          printf("waiter_thread: ERROR waiter: "
+          _info("waiter_thread: ERROR waiter: "
                  "pthread_mutex_unlock failed, status=%d\n", status);
           ASSERT(false);
           waiter_nerrors++;
@@ -156,7 +157,7 @@
   int status;
   int i;
 
-  printf("thread_signaler: Started\n");
+  _info("thread_signaler: Started\n");
   for (i = 0; i < 32; i++)
     {
       /* Take the mutex.  The waiter is higher priority and should
@@ -167,7 +168,7 @@
       status = pthread_mutex_lock(&mutex);
       if (status != 0)
         {
-          printf("thread_signaler: "
+          _info("thread_signaler: "
                  "ERROR pthread_mutex_lock failed, status=%d\n", status);
           ASSERT(false);
           signaler_nerrors++;
@@ -177,14 +178,14 @@
 
       if (waiter_state != COND_WAIT)
         {
-          printf("thread_signaler: "
+          _info("thread_signaler: "
                  "ERROR waiter state = %d != COND_WAITING\n", waiter_state);
           signaler_state++;
         }
 
       if (data_available)
         {
-          printf("thread_signaler: "
+          _info("thread_signaler: "
                  "ERROR data already available, waiter_state=%d\n",
                   waiter_state);
           ASSERT(false);
@@ -197,7 +198,7 @@
       status = pthread_cond_signal(&cond);
       if (status != 0)
         {
-          printf("thread_signaler: "
+          _info("thread_signaler: "
                  "ERROR pthread_cond_signal failed, status=%d\n", status);
           ASSERT(false);
           signaler_nerrors++;
@@ -208,7 +209,7 @@
       status = pthread_mutex_unlock(&mutex);
       if (status != 0)
         {
-          printf("thread_signaler: "
+          _info("thread_signaler: "
                  "ERROR pthread_mutex_unlock failed, status=%d\n", status);
           ASSERT(false);
           signaler_nerrors++;
@@ -233,7 +234,7 @@
       signaler_nloops++;
     }
 
-  printf("thread_signaler: Terminating\n");
+  _info("thread_signaler: Terminating\n");
   pthread_exit(NULL);
   return NULL; /* Non-reachable -- needed for some compilers */
 }
@@ -260,33 +261,33 @@
 
   /* Initialize the mutex */
 
-  printf("cond_test: Initializing mutex\n");
+  _info("cond_test: Initializing mutex\n");
   status = pthread_mutex_init(&mutex, NULL);
   if (status != 0)
     {
-      printf("cond_test: "
+      _info("cond_test: "
              "ERROR pthread_mutex_init failed, status=%d\n", status);
       ASSERT(false);
     }
 
   /* Initialize the condition variable */
 
-  printf("cond_test: Initializing cond\n");
+  _info("cond_test: Initializing cond\n");
   status = pthread_cond_init(&cond, NULL);
   if (status != 0)
     {
-      printf("cond_test: "
+      _info("cond_test: "
              "ERROR pthread_condinit failed, status=%d\n", status);
       ASSERT(false);
     }
 
   /* Start the waiter thread at higher priority */
 
-  printf("cond_test: Starting waiter\n");
+  _info("cond_test: Starting waiter\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("cond_test: pthread_attr_init failed, status=%d\n", status);
+      _info("cond_test: pthread_attr_init failed, status=%d\n", status);
     }
 
   prio_min = sched_get_priority_min(SCHED_FIFO);
@@ -297,47 +298,47 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("cond_test: "
+      _info("cond_test: "
              "pthread_attr_setschedparam failed, status=%d\n", status);
     }
   else
     {
-      printf("cond_test: Set thread 1 priority to %d\n",
+      _info("cond_test: Set thread 1 priority to %d\n",
               sparam.sched_priority);
     }
 
   status = pthread_create(&waiter, &attr, thread_waiter, NULL);
   if (status != 0)
     {
-      printf("cond_test: pthread_create failed, status=%d\n", status);
+      _info("cond_test: pthread_create failed, status=%d\n", status);
     }
 
   sem_wait(&sem_thread_started);
 
-  printf("cond_test: Starting signaler\n");
+  _info("cond_test: Starting signaler\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("cond_test: pthread_attr_init failed, status=%d\n", status);
+      _info("cond_test: pthread_attr_init failed, status=%d\n", status);
     }
 
   sparam.sched_priority = (prio_min + prio_mid) / 2;
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("cond_test: pthread_attr_setschedparam failed, status=%d\n",
+      _info("cond_test: pthread_attr_setschedparam failed, status=%d\n",
               status);
     }
   else
     {
-      printf("cond_test: Set thread 2 priority to %d\n",
+      _info("cond_test: Set thread 2 priority to %d\n",
               sparam.sched_priority);
     }
 
   status = pthread_create(&signaler, &attr, thread_signaler, NULL);
   if (status != 0)
     {
-      printf("cond_test: pthread_create failed, status=%d\n", status);
+      _info("cond_test: pthread_create failed, status=%d\n", status);
     }
 
   /* Wait for the threads to stop */
@@ -347,23 +348,23 @@
 #else
   pthread_join(signaler, NULL);
 #endif
-  printf("cond_test: signaler terminated, now cancel the waiter\n");
+  _info("cond_test: signaler terminated, now cancel the waiter\n");
   pthread_detach(waiter);
   pthread_cancel(waiter);
   pthread_cond_destroy(&cond);
   pthread_mutex_destroy(&mutex);
   sem_destroy(&sem_thread_started);
 
-  printf("cond_test: \tWaiter\tSignaler\n");
-  printf("cond_test: Loops\t%d\t%d\n", waiter_nloops, signaler_nloops);
-  printf("cond_test: Errors\t%d\t%d\n", waiter_nerrors, signaler_nerrors);
-  printf("cond_test:\n");
-  printf("cond_test: %d times, waiter did not have to wait for data\n",
+  _info("cond_test: \tWaiter\tSignaler\n");
+  _info("cond_test: Loops\t%d\t%d\n", waiter_nloops, signaler_nloops);
+  _info("cond_test: Errors\t%d\t%d\n", waiter_nerrors, signaler_nerrors);
+  _info("cond_test:\n");
+  _info("cond_test: %d times, waiter did not have to wait for data\n",
           waiter_nloops - waiter_waits);
-  printf("cond_test: %d times, "
+  _info("cond_test: %d times, "
          "data was already available when the signaler run\n",
           signaler_already);
-  printf("cond_test: %d times, "
+  _info("cond_test: %d times, "
          "the waiter was in an unexpected state when the signaler ran\n",
          signaler_state);
 }
diff -Naur apps-12.8.0/testing/ostest/dev_null.c apps/testing/ostest/dev_null.c
--- apps-12.8.0/testing/ostest/dev_null.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/dev_null.c	2025-11-04 11:04:41.004347611 +0200
@@ -29,6 +29,7 @@
 #include <assert.h>
 #include <fcntl.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 #include "ostest.h"
@@ -51,7 +52,7 @@
   fd = open("/dev/null", O_RDWR);
   if (fd < 0)
     {
-      printf("dev_null: ERROR Failed to open /dev/null\n");
+      _info("dev_null: ERROR Failed to open /dev/null\n");
       ASSERT(false);
       return -1;
     }
@@ -59,24 +60,24 @@
   nbytes = read(fd, buffer, 1024);
   if (nbytes < 0)
     {
-      printf("dev_null: ERROR Failed to read from /dev/null\n");
+      _info("dev_null: ERROR Failed to read from /dev/null\n");
       ASSERT(false);
       close(fd);
       return -1;
     }
 
-  printf("dev_null: Read %d bytes from /dev/null\n", nbytes);
+  _info("dev_null: Read %d bytes from /dev/null\n", nbytes);
 
   nbytes = write(fd, buffer, 1024);
   if (nbytes < 0)
     {
-      printf("dev_null: ERROR Failed to write to /dev/null\n");
+      _info("dev_null: ERROR Failed to write to /dev/null\n");
       ASSERT(false);
       close(fd);
       return -1;
     }
 
-  printf("dev_null: Wrote %d bytes to /dev/null\n", nbytes);
+  _info("dev_null: Wrote %d bytes to /dev/null\n", nbytes);
 
   close(fd);
   return 0;
diff -Naur apps-12.8.0/testing/ostest/fpu.c apps/testing/ostest/fpu.c
--- apps-12.8.0/testing/ostest/fpu.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/fpu.c	2025-11-04 11:04:41.011343543 +0200
@@ -31,6 +31,7 @@
 #include <assert.h>
 #include <inttypes.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
@@ -145,26 +146,26 @@
   int j;
   int k;
 
-  printf("%s (%p):\n", msg, buffer);
+  _info("%s (%p):\n", msg, buffer);
   for (i = 0; i < XCPTCONTEXT_REGS; i += 8)
     {
-      printf("    %04x: ", i);
+      _info("    %04x: ", i);
       for (j = 0; j < 8; j++)
         {
           k = i + j;
 
           if (k < XCPTCONTEXT_REGS)
             {
-              printf("%" PRIxREG " ", buffer[k]);
+              _info("%" PRIxREG " ", buffer[k]);
             }
           else
             {
-              printf("\n");
+              _info("\n");
               break;
             }
         }
 
-      printf("\n");
+      _info("\n");
     }
 }
 
@@ -197,7 +198,7 @@
 
   for (i = 0; i < CONFIG_TESTING_OSTEST_FPULOOPS; i++)
     {
-      printf("FPU#%d: pass %d\n", id, i + 1);
+      _info("FPU#%d: pass %d\n", id, i + 1);
       fflush(stdout);
 
       /* Set the FPU register save arrays to a known-but-illogical values so
@@ -249,14 +250,14 @@
       up_saveusercontext(fpu->save2);
       if (!up_fpucmp(fpu->save1, fpu->save2))
         {
-          printf("ERROR FPU#%d: save1 and save2 do not match\n", id);
+          _info("ERROR FPU#%d: save1 and save2 do not match\n", id);
           fpu_dump(fpu->save1, "Values after math operations (save1)");
           fpu_dump(fpu->save2, "Values after verify re-read (save2)");
           ASSERT(false);
           return EXIT_FAILURE;
         }
 
-      /* Now unlock and sleep for a while -- this should result in some
+      /* Now unlock and usleep for a while -- this should result in some
        * context switches
        */
 
@@ -270,7 +271,7 @@
       up_saveusercontext(fpu->save2);
       if (!up_fpucmp(fpu->save1, fpu->save2))
         {
-          printf("ERROR FPU#%d: save1 and save2 do not match\n", id);
+          _info("ERROR FPU#%d: save1 and save2 do not match\n", id);
           fpu_dump(fpu->save1, "Values before waiting (save1)");
           fpu_dump(fpu->save2, "Values after waiting (save2)");
           ASSERT(false);
@@ -278,7 +279,7 @@
         }
     }
 
-  printf("FPU#%d: Succeeded\n", id);
+  _info("FPU#%d: Succeeded\n", id);
   fflush(stdout);
   return EXIT_SUCCESS;
 }
@@ -298,33 +299,33 @@
   /* Start two two tasks */
 
   g_fpuno = 0;
-  printf("Starting task FPU#1\n");
+  _info("Starting task FPU#1\n");
   task1 = task_create("FPU#1", CONFIG_TESTING_OSTEST_FPUPRIORITY,
                       CONFIG_TESTING_OSTEST_FPUSTACKSIZE, fpu_task, NULL);
   if (task1 < 0)
     {
-      printf("fpu_test: ERROR Failed to start task FPU#1\n");
+      _info("fpu_test: ERROR Failed to start task FPU#1\n");
       ASSERT(false);
     }
   else
     {
-      printf("fpu_test: Started task FPU#1 at PID=%d\n", task1);
+      _info("fpu_test: Started task FPU#1 at PID=%d\n", task1);
     }
 
   fflush(stdout);
   usleep(250);
 
-  printf("Starting task FPU#2\n");
+  _info("Starting task FPU#2\n");
   task2 = task_create("FPU#2", CONFIG_TESTING_OSTEST_FPUPRIORITY,
                       CONFIG_TESTING_OSTEST_FPUSTACKSIZE, fpu_task, NULL);
   if (task2 < 0)
     {
-      printf("fpu_test: ERROR Failed to start task FPU#1\n");
+      _info("fpu_test: ERROR Failed to start task FPU#1\n");
       ASSERT(false);
     }
   else
     {
-      printf("fpu_test: Started task FPU#2 at PID=%d\n", task2);
+      _info("fpu_test: Started task FPU#2 at PID=%d\n", task2);
     }
 
   /* Wait for each task to complete */
@@ -334,8 +335,8 @@
   waitpid(task2, &statloc, 0);
 
 #else
-  printf("fpu_test: ERROR: The FPU test is not properly configured\n");
+  _info("fpu_test: ERROR: The FPU test is not properly configured\n");
   ASSERT(false);
 #endif
-  printf("fpu_test: Returning\n");
+  _info("fpu_test: Returning\n");
 }
diff -Naur apps-12.8.0/testing/ostest/getopt.c apps/testing/ostest/getopt.c
--- apps-12.8.0/testing/ostest/getopt.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/getopt.c	2025-11-04 11:04:41.011343543 +0200
@@ -29,6 +29,7 @@
 #include <assert.h>
 #include <getopt.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 
 #include "ostest.h"
@@ -202,7 +203,7 @@
 
       if (optind < 1 || optind > argc)
         {
-          printf("ERROR: optind=%d\n", optind);
+          _info("ERROR: optind=%d\n", optind);
           ASSERT(false);
         }
 
@@ -214,7 +215,7 @@
         {
           if (expected[ndx].ret != ret)
             {
-              printf("ERROR: arg %d:  ret=%d (expected %d)\n",
+              _info("ERROR: arg %d:  ret=%d (expected %d)\n",
                      ndx + 1, ret, expected[ndx].ret);
               ASSERT(false);
             }
@@ -224,7 +225,7 @@
               (expected[ndx].arg != NULL &&
                strcmp(expected[ndx].arg, optarg) != 0))
             {
-              printf("ERROR: arg %d:  optarg=%s (expected %s)\n",
+              _info("ERROR: arg %d:  optarg=%s (expected %s)\n",
                      ndx + 1, optarg == NULL ? "null" : optarg,
                      expected[ndx].arg == NULL ? "null" :
                      expected[ndx].arg);
@@ -241,7 +242,7 @@
 
   if (ndx != noptions && ndx != noptions + 1)
     {
-      printf("ERROR: ndx=%d (expected %d)\n", ndx, noptions);
+      _info("ERROR: ndx=%d (expected %d)\n", ndx, noptions);
       ASSERT(false);
     }
 
@@ -271,7 +272,7 @@
 
       if (optind < 1 || optind > argc)
         {
-          printf("ERROR: optind=%d\n", optind);
+          _info("ERROR: optind=%d\n", optind);
           ASSERT(false);
         }
 
@@ -283,14 +284,14 @@
         {
           if (expected[ndx].ret != ret)
             {
-              printf("ERROR: arg %d:  ret=%d (expected %d)\n",
+              _info("ERROR: arg %d:  ret=%d (expected %d)\n",
                      ndx + 1, ret, expected[ndx].ret);
               ASSERT(false);
             }
 
           if (expected[ndx].flag != g_flag)
             {
-              printf("ERROR: arg %d;  flag=%d (expected %d)\n",
+              _info("ERROR: arg %d;  flag=%d (expected %d)\n",
                      ndx + 1, expected[ndx].flag, g_flag);
               ASSERT(false);
             }
@@ -300,7 +301,7 @@
               (expected[ndx].arg != NULL &&
                strcmp(expected[ndx].arg, optarg) != 0))
             {
-              printf("ERROR: arg %d:  optarg=%s (expected %s)\n",
+              _info("ERROR: arg %d:  optarg=%s (expected %s)\n",
                      ndx + 1, optarg == NULL ? "null" : optarg,
                      expected[ndx].arg == NULL ? "null" :
                      expected[ndx].arg);
@@ -318,7 +319,7 @@
 
   if (ndx != noptions && ndx != noptions + 1)
     {
-      printf("ERROR: ndx=%d (expected %d)\n", ndx, noptions);
+      _info("ERROR: ndx=%d (expected %d)\n", ndx, noptions);
       ASSERT(false);
     }
 
@@ -348,7 +349,7 @@
 
       if (optind < 1 || optind > argc)
         {
-          printf("ERROR: optind=%d\n", optind);
+          _info("ERROR: optind=%d\n", optind);
           ASSERT(false);
         }
 
@@ -360,14 +361,14 @@
         {
           if (expected[ndx].ret != ret)
             {
-              printf("ERROR: arg %d:  ret=%d (expected %d)\n",
+              _info("ERROR: arg %d:  ret=%d (expected %d)\n",
                      ndx + 1, ret, expected[ndx].ret);
               ASSERT(false);
             }
 
           if (expected[ndx].flag != g_flag)
             {
-              printf("ERROR: arg %d;  flag=%d (expected %d)\n",
+              _info("ERROR: arg %d;  flag=%d (expected %d)\n",
                      ndx + 1, expected[ndx].flag, g_flag);
               ASSERT(false);
             }
@@ -377,7 +378,7 @@
               (expected[ndx].arg != NULL &&
                strcmp(expected[ndx].arg, optarg) != 0))
             {
-              printf("ERROR: arg %d:  optarg=%s (expected %s)\n",
+              _info("ERROR: arg %d:  optarg=%s (expected %s)\n",
                      ndx + 1, optarg == NULL ? "null" : optarg,
                      expected[ndx].arg == NULL ? "null" :
                      expected[ndx].arg);
@@ -395,7 +396,7 @@
 
   if (ndx != noptions && ndx != noptions + 1)
     {
-      printf("ERROR: ndx=%d (expected %d)\n", ndx, noptions);
+      _info("ERROR: ndx=%d (expected %d)\n", ndx, noptions);
       ASSERT(false);
     }
 
@@ -412,7 +413,7 @@
   struct result_s results[5];
   FAR char *argv[10];
 
-  printf("getopt():  Simple test\n");
+  _info("getopt():  Simple test\n");
 
   argv[0] = NULL;
   argv[1] = "-a";
@@ -431,7 +432,7 @@
 
   getopt_short_test(4, 8, argv, g_optstring, results);
 
-  printf("getopt():  Invalid argument\n");
+  _info("getopt():  Invalid argument\n");
 
   argv[0] = NULL;
   argv[1] = "-a";
@@ -455,7 +456,7 @@
   argv[8] = NULL;
   getopt_short_test(5, 8, argv, g_optstring, results);
 
-  printf("getopt():  Missing optional argument\n");
+  _info("getopt():  Missing optional argument\n");
 
   argv[0] = NULL;
   argv[1] = "-a";
@@ -473,7 +474,7 @@
 
   getopt_short_test(4, 7, argv, g_optstring, results);
 
-  printf("getopt_long():  Simple test\n");
+  _info("getopt_long():  Simple test\n");
 
   argv[0] = NULL;
   argv[1] = "--OptionA";
@@ -499,12 +500,12 @@
   getopt_long_test(4, 8, argv, g_optstring, long_options, NULL,
                    results);
 
-  printf("getopt_long():  No short options\n");
+  _info("getopt_long():  No short options\n");
 
   getopt_long_test(4, 8, argv, NULL, long_options, NULL,
                    results);
 
-  printf("getopt_long():  Argument for --option=argument\n");
+  _info("getopt_long():  Argument for --option=argument\n");
 
   argv[0] = NULL;
   argv[1] = "--OptionA";
@@ -528,7 +529,7 @@
   getopt_long_test(4, 6, argv, g_optstring, long_options, NULL,
                    results);
 
-  printf("getopt_long():  Invalid long option\n");
+  _info("getopt_long():  Invalid long option\n");
 
   argv[0] = NULL;
   argv[1] = "--OptionA";
@@ -560,7 +561,7 @@
   getopt_long_test(5, 8, argv, g_optstring, long_options, NULL,
                    results);
 
-  printf("getopt_long():  Mixed long and short options\n");
+  _info("getopt_long():  Mixed long and short options\n");
 
   argv[0] = NULL;
   argv[1] = "--OptionA";
@@ -584,7 +585,7 @@
   getopt_long_test(4, 8, argv, g_optstring, long_options, NULL,
                    results);
 
-  printf("getopt_long():  Invalid short option\n");
+  _info("getopt_long():  Invalid short option\n");
 
   argv[0] = NULL;
   argv[1] = "--OptionA";
@@ -612,7 +613,7 @@
   getopt_long_test(5, 9, argv, g_optstring, long_options, NULL,
                    results);
 
-  printf("getopt_long():  Missing optional arguments\n");
+  _info("getopt_long():  Missing optional arguments\n");
 
   argv[0] = NULL;
   argv[1] = "--OptionA";
@@ -634,7 +635,7 @@
   getopt_long_test(4, 6, argv, g_optstring, long_options, NULL,
                    results);
 
-  printf("getopt_long_only():  Mixed long and short options\n");
+  _info("getopt_long_only():  Mixed long and short options\n");
 
   argv[0] = NULL;
   argv[1] = "-a";
@@ -658,7 +659,7 @@
   getopt_longonly_test(4, 8, argv, g_optstring, long_options, NULL,
                        results);
 
-  printf("getopt_long_only():  Single hyphen long options\n");
+  _info("getopt_long_only():  Single hyphen long options\n");
 
   argv[0] = NULL;
   argv[1] = "-OptionA";
diff -Naur apps-12.8.0/testing/ostest/Make.dep apps/testing/ostest/Make.dep
--- apps-12.8.0/testing/ostest/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/ostest/Make.dep	2025-11-05 16:00:07.691629762 +0200
@@ -0,0 +1,1681 @@
+# Gen Make.dep automatically
+getopt.c.home.laur.lucru.rtos.apps.testing.ostest.o: getopt.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/getopt.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+libc_memmem.c.home.laur.lucru.rtos.apps.testing.ostest.o: libc_memmem.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h ostest.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h
+restart.c.home.laur.lucru.rtos.apps.testing.ostest.o: restart.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+sigprocmask.c.home.laur.lucru.rtos.apps.testing.ostest.o: sigprocmask.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+sighand.c.home.laur.lucru.rtos.apps.testing.ostest.o: sighand.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wdog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/addrenv.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/arch.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/net/net.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/tls.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/cache.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atexit.h ostest.h
+signest.c.home.laur.lucru.rtos.apps.testing.ostest.o: signest.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+sighelper.c.home.laur.lucru.rtos.apps.testing.ostest.o: sighelper.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h ostest.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h
+dev_null.c.home.laur.lucru.rtos.apps.testing.ostest.o: dev_null.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+setvbuf.c.home.laur.lucru.rtos.apps.testing.ostest.o: setvbuf.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+waitpid.c.home.laur.lucru.rtos.apps.testing.ostest.o: waitpid.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/wait.h ostest.h
+cancel.c.home.laur.lucru.rtos.apps.testing.ostest.o: cancel.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/mqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+cond.c.home.laur.lucru.rtos.apps.testing.ostest.o: cond.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+mutex.c.home.laur.lucru.rtos.apps.testing.ostest.o: mutex.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+timedmutex.c.home.laur.lucru.rtos.apps.testing.ostest.o: timedmutex.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+sem.c.home.laur.lucru.rtos.apps.testing.ostest.o: sem.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+semtimed.c.home.laur.lucru.rtos.apps.testing.ostest.o: semtimed.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+barrier.c.home.laur.lucru.rtos.apps.testing.ostest.o: barrier.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+timedwait.c.home.laur.lucru.rtos.apps.testing.ostest.o: timedwait.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+pthread_rwlock.c.home.laur.lucru.rtos.apps.testing.ostest.o: \
+ pthread_rwlock.c /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+pthread_rwlock_cancel.c.home.laur.lucru.rtos.apps.testing.ostest.o: \
+ pthread_rwlock_cancel.c /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+schedlock.c.home.laur.lucru.rtos.apps.testing.ostest.o: schedlock.c \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/wait.h ostest.h
+pthread_exit.c.home.laur.lucru.rtos.apps.testing.ostest.o: pthread_exit.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/wait.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+robust.c.home.laur.lucru.rtos.apps.testing.ostest.o: robust.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+roundrobin.c.home.laur.lucru.rtos.apps.testing.ostest.o: roundrobin.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+mqueue.c.home.laur.lucru.rtos.apps.testing.ostest.o: mqueue.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/mqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+timedmqueue.c.home.laur.lucru.rtos.apps.testing.ostest.o: timedmqueue.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/ctype.h \
+ /home/laur/lucru/rtos/nuttx/include/langinfo.h \
+ /home/laur/lucru/rtos/nuttx/include/nl_types.h \
+ /home/laur/lucru/rtos/nuttx/include/locale.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/fcntl.h \
+ /home/laur/lucru/rtos/nuttx/include/mqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+posixtimer.c.home.laur.lucru.rtos.apps.testing.ostest.o: posixtimer.c \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wdog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/addrenv.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/arch.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/net/net.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/tls.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/cache.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atexit.h ostest.h
+vfork.c.home.laur.lucru.rtos.apps.testing.ostest.o: vfork.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h ostest.h
+wdog.c.home.laur.lucru.rtos.apps.testing.ostest.o: wdog.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/arch.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/arch.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/cache.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/addrenv.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wqueue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/wdog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/net/net.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/tls.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atexit.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+ostest_main.c.home.laur.lucru.rtos.apps.testing.ostest.o: ostest_main.c \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/wait.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/init.h ostest.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/testing/ostest/mqueue.c apps/testing/ostest/mqueue.c
--- apps-12.8.0/testing/ostest/mqueue.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/mqueue.c	2025-11-04 11:04:41.007345868 +0200
@@ -34,6 +34,7 @@
 #include <pthread.h>
 #include <sched.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -78,7 +79,7 @@
   int nerrors = 0;
   int i;
 
-  printf("sender_thread: Starting\n");
+  _info("sender_thread: Starting\n");
 
   /* Fill in attributes for message queue */
 
@@ -100,7 +101,7 @@
   g_send_mqfd = mq_open("mqueue", O_WRONLY | O_CREAT, 0666, &attr);
   if (g_send_mqfd == (mqd_t)-1)
     {
-      printf("sender_thread: ERROR mq_open failed, errno=%d\n", errno);
+      _info("sender_thread: ERROR mq_open failed, errno=%d\n", errno);
       ASSERT(false);
       pthread_exit((pthread_addr_t)1);
     }
@@ -116,7 +117,7 @@
       status = mq_send(g_send_mqfd, msg_buffer, TEST_MSGLEN, 42);
       if (status < 0)
         {
-          printf("sender_thread: ERROR mq_send failure=%d on msg %d, "
+          _info("sender_thread: ERROR mq_send failure=%d on msg %d, "
                  "errno=%d\n",
                  status, i, errno);
           ASSERT(false);
@@ -124,7 +125,7 @@
         }
       else
         {
-          printf("sender_thread: mq_send succeeded on msg %d\n", i);
+          _info("sender_thread: mq_send succeeded on msg %d\n", i);
         }
     }
 
@@ -132,7 +133,7 @@
 
   if (mq_close(g_send_mqfd) < 0)
     {
-      printf("sender_thread: ERROR mq_close failed, errno=%d\n", errno);
+      _info("sender_thread: ERROR mq_close failed, errno=%d\n", errno);
       ASSERT(false);
     }
   else
@@ -140,7 +141,7 @@
       g_send_mqfd = 0;
     }
 
-  printf("sender_thread: returning nerrors=%d\n", nerrors);
+  _info("sender_thread: returning nerrors=%d\n", nerrors);
   return (pthread_addr_t)((uintptr_t)nerrors);
 }
 
@@ -152,7 +153,7 @@
   int nerrors = 0;
   int i;
 
-  printf("receiver_thread: Starting\n");
+  _info("receiver_thread: Starting\n");
 
   /* Fill in attributes for message queue */
 
@@ -174,7 +175,7 @@
   g_recv_mqfd = mq_open("mqueue", O_RDONLY | O_CREAT, 0666, &attr);
   if (g_recv_mqfd == (mqd_t)-1)
     {
-      printf("receiver_thread: ERROR mq_open failed, errno=%d\n", errno);
+      _info("receiver_thread: ERROR mq_open failed, errno=%d\n", errno);
       ASSERT(false);
       pthread_exit((pthread_addr_t)1);
     }
@@ -193,19 +194,19 @@
 
           if (errno != EINTR)
             {
-              printf("receiver_thread: ERROR mq_receive failure on msg %d, "
+              _info("receiver_thread: ERROR mq_receive failure on msg %d, "
                      "errno=%d\n", i, errno);
               ASSERT(false);
               nerrors++;
             }
           else
             {
-              printf("receiver_thread: mq_receive interrupted!\n");
+              _info("receiver_thread: mq_receive interrupted!\n");
             }
         }
       else if (nbytes != TEST_MSGLEN)
         {
-          printf("receiver_thread: "
+          _info("receiver_thread: "
                  "ERROR mq_receive return bad size %d on msg %d\n",
                  nbytes, i);
           ASSERT(false);
@@ -215,33 +216,33 @@
         {
           int j;
 
-          printf("receiver_thread: "
+          _info("receiver_thread: "
                  "mq_receive returned corrupt message on msg %d\n", i);
-          printf("receiver_thread:                  i  Expected Received\n");
+          _info("receiver_thread:                  i  Expected Received\n");
 
           for (j = 0; j < TEST_MSGLEN - 1; j++)
             {
               if (isprint(msg_buffer[j]))
                 {
-                 printf("receiver_thread:                  "
+                 _info("receiver_thread:                  "
                         "%2d %02x (%c) %02x (%c)\n",
                          j, TEST_MESSAGE[j], TEST_MESSAGE[j],
                          msg_buffer[j], msg_buffer[j]);
                 }
               else
                 {
-                  printf("receiver_thread:                  "
+                  _info("receiver_thread:                  "
                          "%2d %02x (%c) %02x\n",
                          j, TEST_MESSAGE[j], TEST_MESSAGE[j], msg_buffer[j]);
                 }
             }
 
-          printf("receiver_thread:                  %2d 00      %02x\n",
+          _info("receiver_thread:                  %2d 00      %02x\n",
                   j, msg_buffer[j]);
         }
       else
         {
-          printf("receiver_thread: mq_receive succeeded on msg %d\n", i);
+          _info("receiver_thread: mq_receive succeeded on msg %d\n", i);
         }
     }
 
@@ -249,7 +250,7 @@
 
   if (mq_close(g_recv_mqfd) < 0)
     {
-      printf("receiver_thread: ERROR mq_close failed\n");
+      _info("receiver_thread: ERROR mq_close failed\n");
       ASSERT(false);
       nerrors++;
     }
@@ -258,7 +259,7 @@
       g_recv_mqfd = 0;
     }
 
-  printf("receiver_thread: returning nerrors=%d\n", nerrors);
+  _info("receiver_thread: returning nerrors=%d\n", nerrors);
   pthread_exit((pthread_addr_t)((uintptr_t)nerrors));
   return (pthread_addr_t)((uintptr_t)nerrors);
 }
@@ -283,11 +284,11 @@
 
   /* Start the sending thread at higher priority */
 
-  printf("mqueue_test: Starting receiver\n");
+  _info("mqueue_test: Starting receiver\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("mqueue_test: ERROR pthread_attr_init failed, status=%d\n",
+      _info("mqueue_test: ERROR pthread_attr_init failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -295,7 +296,7 @@
   status = pthread_attr_setstacksize(&attr, STACKSIZE);
   if (status != 0)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_attr_setstacksize failed, status=%d\n",
              status);
       ASSERT(false);
@@ -309,32 +310,32 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_attr_setschedparam failed, status=%d\n",
              status);
       ASSERT(false);
     }
   else
     {
-      printf("mqueue_test: Set receiver priority to %d\n",
+      _info("mqueue_test: Set receiver priority to %d\n",
              sparam.sched_priority);
     }
 
   status = pthread_create(&receiver, &attr, receiver_thread, NULL);
   if (status != 0)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_create failed, status=%d\n", status);
       ASSERT(false);
     }
 
   /* Start the sending thread at lower priority */
 
-  printf("mqueue_test: Starting sender\n");
+  _info("mqueue_test: Starting sender\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_attr_init failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -342,7 +343,7 @@
   status = pthread_attr_setstacksize(&attr, STACKSIZE);
   if (status != 0)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_attr_setstacksize failed, status=%d\n",
              status);
       ASSERT(false);
@@ -352,37 +353,37 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_attr_setschedparam failed, status=%d\n",
              status);
       ASSERT(false);
     }
   else
     {
-      printf("mqueue_test: Set sender thread priority to %d\n",
+      _info("mqueue_test: Set sender thread priority to %d\n",
              sparam.sched_priority);
     }
 
   status = pthread_create(&sender, &attr, sender_thread, NULL);
   if (status != 0)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR pthread_create failed, status=%d\n", status);
       ASSERT(false);
     }
 
-  printf("mqueue_test: Waiting for sender to complete\n");
+  _info("mqueue_test: Waiting for sender to complete\n");
   pthread_join(sender, &result);
   if (result != (FAR void *)0)
     {
-      printf("mqueue_test: ERROR sender thread exited with %d errors\n",
+      _info("mqueue_test: ERROR sender thread exited with %d errors\n",
              (int)((intptr_t)result));
       ASSERT(false);
     }
 
   /* Wake up the receiver thread with a signal */
 
-  printf("mqueue_test: Killing receiver\n");
+  _info("mqueue_test: Killing receiver\n");
   pthread_kill(receiver, SIGUSR1);
 
   /* Wait a bit to see if the thread exits on its own */
@@ -391,13 +392,13 @@
 
   /* Then cancel the thread and see if it did */
 
-  printf("mqueue_test: Canceling receiver\n");
+  _info("mqueue_test: Canceling receiver\n");
 
   expected = PTHREAD_CANCELED;
   status = pthread_cancel(receiver);
   if (status == ESRCH)
     {
-      printf("mqueue_test: receiver has already terminated\n");
+      _info("mqueue_test: receiver has already terminated\n");
       expected = (FAR void *)0;
     }
 
@@ -409,10 +410,10 @@
   pthread_join(receiver, &result);
   if (result != expected)
     {
-      printf("mqueue_test: "
+      _info("mqueue_test: "
              "ERROR receiver thread should have exited with %p\n",
              expected);
-      printf("             ERROR Instead exited with nerrors=%d\n",
+      _info("             ERROR Instead exited with nerrors=%d\n",
              (int)((intptr_t)result));
       ASSERT(false);
     }
@@ -427,17 +428,17 @@
     {
       if (mq_close(g_recv_mqfd) < 0)
         {
-          printf("mqueue_test: ERROR mq_close failed\n");
+          _info("mqueue_test: ERROR mq_close failed\n");
           ASSERT(false);
         }
     }
   else if (result != PTHREAD_CANCELED && g_recv_mqfd)
     {
-      printf("mqueue_test: ERROR send mqd_t left open\n");
+      _info("mqueue_test: ERROR send mqd_t left open\n");
       ASSERT(false);
       if (mq_close(g_recv_mqfd) < 0)
         {
-          printf("mqueue_test: ERROR mq_close failed\n");
+          _info("mqueue_test: ERROR mq_close failed\n");
           ASSERT(false);
         }
     }
@@ -446,11 +447,11 @@
 
   if (g_send_mqfd)
     {
-      printf("mqueue_test: ERROR receiver mqd_t left open\n");
+      _info("mqueue_test: ERROR receiver mqd_t left open\n");
       ASSERT(false);
       if (mq_close(g_send_mqfd) < 0)
         {
-          printf("sender_thread: ERROR mq_close failed\n");
+          _info("sender_thread: ERROR mq_close failed\n");
           ASSERT(false);
         }
     }
@@ -459,7 +460,7 @@
 
   if (mq_unlink("mqueue") < 0)
     {
-      printf("mqueue_test: ERROR mq_unlink failed\n");
+      _info("mqueue_test: ERROR mq_unlink failed\n");
       ASSERT(false);
     }
 }
diff -Naur apps-12.8.0/testing/ostest/mutex.c apps/testing/ostest/mutex.c
--- apps-12.8.0/testing/ostest/mutex.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/mutex.c	2025-11-04 11:04:41.014341799 +0200
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 
 #include "ostest.h"
 
@@ -68,14 +69,14 @@
       int status = pthread_mutex_lock(&mut);
       if (status != 0)
         {
-          printf("ERROR thread %d: pthread_mutex_lock failed, status=%d\n",
+          _info("ERROR thread %d: pthread_mutex_lock failed, status=%d\n",
                   id, status);
           ASSERT(false);
         }
 
       if (my_mutex == 1)
         {
-          printf("ERROR thread=%d: "
+          _info("ERROR thread=%d: "
                  "my_mutex should be zero, instead my_mutex=%d\n",
                   id, my_mutex);
           ASSERT(false);
@@ -93,7 +94,7 @@
       status = pthread_mutex_unlock(&mut);
       if (status != 0)
         {
-          printf("ERROR thread %d: pthread_mutex_unlock failed, status=%d\n",
+          _info("ERROR thread %d: pthread_mutex_unlock failed, status=%d\n",
                  id, status);
           ASSERT(false);
         }
@@ -120,12 +121,12 @@
 
   /* Initialize the mutex */
 
-  printf("Initializing mutex\n");
+  _info("Initializing mutex\n");
   pthread_mutex_init(&mut, NULL);
 
   /* Start two thread instances */
 
-  printf("Starting thread 1\n");
+  _info("Starting thread 1\n");
 #ifdef SDCC
   pthread_attr_init(&attr);
   status = pthread_create(&thread1, &attr, thread_func, (pthread_addr_t)1);
@@ -134,11 +135,11 @@
 #endif
   if (status != 0)
     {
-      printf("ERROR in thread#1 creation\n");
+      _info("ERROR in thread#1 creation\n");
       ASSERT(false);
     }
 
-  printf("Starting thread 2\n");
+  _info("Starting thread 2\n");
 #ifdef SDCC
   status = pthread_create(&thread2, &attr, thread_func, (pthread_addr_t)2);
 #else
@@ -146,7 +147,7 @@
 #endif
   if (status != 0)
     {
-      printf("ERROR in thread#2 creation\n");
+      _info("ERROR in thread#2 creation\n");
       ASSERT(false);
     }
 
@@ -160,7 +161,7 @@
 
   pthread_mutex_destroy(&mut);
 
-  printf("\t\tThread1\tThread2\n");
-  printf("\tLoops\t%lu\t%lu\n", nloops[0], nloops[1]);
-  printf("\tErrors\t%lu\t%lu\n", nerrors[0], nerrors[1]);
+  _info("\t\tThread1\tThread2\n");
+  _info("\tLoops\t%lu\t%lu\n", nloops[0], nloops[1]);
+  _info("\tErrors\t%lu\t%lu\n", nerrors[0], nerrors[1]);
 }
diff -Naur apps-12.8.0/testing/ostest/nsem.c apps/testing/ostest/nsem.c
--- apps-12.8.0/testing/ostest/nsem.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/nsem.c	2025-11-04 11:04:41.018339474 +0200
@@ -31,6 +31,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 
 #include "ostest.h"
 
@@ -60,38 +61,38 @@
    * nsem_test().
    */
 
-  printf("nsem_peer: Open semaphore 1\n");
+  _info("nsem_peer: Open semaphore 1\n");
   sem1 = sem_open(SEM1_NAME, 0);
   if (sem1 == SEM_FAILED)
     {
       int errcode = errno;
-      printf("nsem_peer: ERROR: sem_open(1) failed: %d\n", errcode);
+      _info("nsem_peer: ERROR: sem_open(1) failed: %d\n", errcode);
       ASSERT(false);
       return NULL;
     }
 
   /* Open semaphore 2.  We will create that one */
 
-  printf("nsem_peer: Create semaphore 2 with value == 0\n");
+  _info("nsem_peer: Create semaphore 2 with value == 0\n");
   sem2 = sem_open(SEM2_NAME, O_CREAT | O_EXCL, 0644, 0);
   if (sem1 == SEM_FAILED)
     {
       int errcode = errno;
-      printf("nsem_peer: ERROR: sem_open(2) failed: %d\n", errcode);
+      _info("nsem_peer: ERROR: sem_open(2) failed: %d\n", errcode);
       ASSERT(false);
       return NULL;
     }
 
   /* Post and discard semaphore 1 */
 
-  printf("nsem_peer: Post, close, and unlink semaphore 1\n");
+  _info("nsem_peer: Post, close, and unlink semaphore 1\n");
   sem_post(sem1);
   sem_close(sem1);
   sem_unlink(SEM1_NAME);
 
   /* Now post and close semaphore 2 */
 
-  printf("nsem_peer: Post and close semaphore 2\n");
+  _info("nsem_peer: Post and close semaphore 2\n");
   sem_post(sem2);
   sem_close(sem2);
   return NULL;
@@ -118,23 +119,23 @@
 
   /* Open semaphore 2.  We will create that one */
 
-  printf("nsem_test: Create semaphore 1 with value == 0\n");
+  _info("nsem_test: Create semaphore 1 with value == 0\n");
   sem1 = sem_open(SEM1_NAME, O_CREAT | O_EXCL, 0644, 0);
   if (sem1 == SEM_FAILED)
     {
       int errcode = errno;
-      printf("nsem_peer: ERROR: sem_open(1) failed: %d\n", errcode);
+      _info("nsem_peer: ERROR: sem_open(1) failed: %d\n", errcode);
       ASSERT(false);
       return;
     }
 
   /* Start the peer thread */
 
-  printf("nsem_test: Starting peer peer\n");
+  _info("nsem_test: Starting peer peer\n");
   status = pthread_attr_init(&attr);
   if (status != OK)
     {
-      printf("nsem_test: pthread_attr_init failed, status=%d\n",  status);
+      _info("nsem_test: pthread_attr_init failed, status=%d\n",  status);
     }
 
   prio_min = sched_get_priority_min(SCHED_FIFO);
@@ -145,32 +146,32 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("nsem_test: "
+      _info("nsem_test: "
              "ERROR: pthread_attr_setschedparam failed, status=%d\n",
               status);
       ASSERT(false);
     }
   else
     {
-      printf("nsem_test: Set peer priority to %d\n",  sparam.sched_priority);
+      _info("nsem_test: Set peer priority to %d\n",  sparam.sched_priority);
     }
 
   status = pthread_create(&peer, &attr, nsem_peer, NULL);
   if (status != 0)
     {
-      printf("nsem_test: ERROR: Peer thread creation failed: %d\n",  status);
+      _info("nsem_test: ERROR: Peer thread creation failed: %d\n",  status);
       ASSERT(false);
       return;
     }
 
   /* Wait for the peer to post semaphore 1 */
 
-  printf("nsem_test: Wait on semaphore 1\n");
+  _info("nsem_test: Wait on semaphore 1\n");
   status = sem_wait(sem1);
   if (status < 0)
     {
       int errcode = errno;
-      printf("nsem_test: ERROR: sem_wait(1) failed: %d\n",  errcode);
+      _info("nsem_test: ERROR: sem_wait(1) failed: %d\n",  errcode);
       ASSERT(false);
       pthread_cancel(peer);
       return;
@@ -178,19 +179,19 @@
 
   /* Close sem1.  It should already have been unlinked by the nsem_peer */
 
-  printf("nsem_test: Close semaphore 1\n");
+  _info("nsem_test: Close semaphore 1\n");
   sem_close(sem1);
 
   /* Open semaphore 2.  This should have already been created by
    * nsem_peer().
    */
 
-  printf("nsem_test: Open semaphore 2\n");
+  _info("nsem_test: Open semaphore 2\n");
   sem2 = sem_open(SEM2_NAME, 0);
   if (sem2 == SEM_FAILED)
     {
       int errcode = errno;
-      printf("nsem_test: ERROR: sem_open(2) failed: %d\n", errcode);
+      _info("nsem_test: ERROR: sem_open(2) failed: %d\n", errcode);
       ASSERT(false);
       pthread_cancel(peer);
       return;
@@ -198,12 +199,12 @@
 
   /* Wait for the peer to post semaphore 2 */
 
-  printf("nsem_test: Wait on semaphore 2\n");
+  _info("nsem_test: Wait on semaphore 2\n");
   status = sem_wait(sem2);
   if (status < 0)
     {
       int errcode = errno;
-      printf("nsem_test: ERROR: sem_wait(1) failed: %d\n",  errcode);
+      _info("nsem_test: ERROR: sem_wait(1) failed: %d\n",  errcode);
       ASSERT(false);
       pthread_cancel(peer);
       return;
@@ -211,7 +212,7 @@
 
   /* Close and unlink semaphore 2 */
 
-  printf("nsem_test: Close and unlink semaphore 2\n");
+  _info("nsem_test: Close and unlink semaphore 2\n");
   sem_close(sem2);
   sem_unlink(SEM2_NAME);
 
diff -Naur apps-12.8.0/testing/ostest/nxevent.c apps/testing/ostest/nxevent.c
--- apps-12.8.0/testing/ostest/nxevent.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/nxevent.c	2025-11-04 11:04:41.018339474 +0200
@@ -28,6 +28,7 @@
 #include <nuttx/event.h>
 
 #include <stdio.h>
+#include <debug.h>
 #include <sched.h>
 #include <pthread.h>
 
@@ -37,7 +38,7 @@
     ret = expr; \
     if (ret != value) \
       { \
-        printf("ERROR nxevent test failed, line=%d ret=%x\n", __LINE__, ret); \
+        _info("ERROR nxevent test failed, line=%d ret=%x\n", __LINE__, ret); \
         ASSERT(false); \
       }
 
diff -Naur apps-12.8.0/testing/ostest/ostest_main.c apps/testing/ostest/ostest_main.c
--- apps-12.8.0/testing/ostest/ostest_main.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/ostest_main.c	2025-11-05 16:00:03.758206113 +0200
@@ -34,6 +34,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
@@ -52,7 +53,7 @@
 
 #define PRIORITY         100
 #define NARGS              4
-#define HALF_SECOND_USEC 500000L
+#define HALF_SECOND_USEC 10 //500000L
 
 /****************************************************************************
  * Private Data
@@ -109,13 +110,13 @@
 static void show_memory_usage(struct mallinfo *mmbefore,
                               struct mallinfo *mmafter)
 {
-  printf("VARIABLE  BEFORE   AFTER\n");
-  printf("======== ======== ========\n");
-  printf("arena    %8x %8x\n", mmbefore->arena,    mmafter->arena);
-  printf("ordblks  %8d %8d\n", mmbefore->ordblks,  mmafter->ordblks);
-  printf("mxordblk %8x %8x\n", mmbefore->mxordblk, mmafter->mxordblk);
-  printf("uordblks %8x %8x\n", mmbefore->uordblks, mmafter->uordblks);
-  printf("fordblks %8x %8x\n", mmbefore->fordblks, mmafter->fordblks);
+  _info("VARIABLE  BEFORE   AFTER\n");
+  _info("======== ======== ========\n");
+  _info("arena    %8x %8x\n", mmbefore->arena,    mmafter->arena);
+  _info("ordblks  %8d %8d\n", mmbefore->ordblks,  mmafter->ordblks);
+  _info("mxordblk %8x %8x\n", mmbefore->mxordblk, mmafter->mxordblk);
+  _info("uordblks %8x %8x\n", mmbefore->uordblks, mmafter->uordblks);
+  _info("fordblks %8x %8x\n", mmbefore->fordblks, mmafter->fordblks);
 }
 
 /****************************************************************************
@@ -134,7 +135,7 @@
 
   /* Show the change from the previous time */
 
-  printf("\nEnd of test memory usage:\n");
+  _info("\nEnd of test memory usage:\n");
   show_memory_usage(&g_mmprevious, &g_mmafter);
 
   /* Set up for the next test */
@@ -161,40 +162,40 @@
         {
           if (strcmp(actual_value, exptd_value) == 0)
             {
-              printf("show_variable: Variable=%s has value=%s\n",
+              _info("show_variable: Variable=%s has value=%s\n",
                      var_name, exptd_value);
             }
           else
             {
-              printf("show_variable: ERROR Variable=%s has the wrong "
+              _info("show_variable: ERROR Variable=%s has the wrong "
                      "value\n",
                      var_name);
               ASSERT(false);
-              printf("show_variable:       found=%s expected=%s\n",
+              _info("show_variable:       found=%s expected=%s\n",
                      actual_value, exptd_value);
             }
         }
       else
         {
-          printf("show_variable: ERROR Variable=%s has a value when it "
+          _info("show_variable: ERROR Variable=%s has a value when it "
                  "should not\n",
                  var_name);
           ASSERT(false);
-          printf("show_variable:       value=%s\n",
+          _info("show_variable:       value=%s\n",
                  actual_value);
         }
     }
   else if (var_valid)
     {
-      printf("show_variable: ERROR Variable=%s has no value\n",
+      _info("show_variable: ERROR Variable=%s has no value\n",
              var_name);
       ASSERT(false);
-      printf("show_variable:       Should have had value=%s\n",
+      _info("show_variable:       Should have had value=%s\n",
              exptd_value);
     }
   else
     {
-      printf("show_variable: Variable=%s has no value\n", var_name);
+      _info("show_variable: Variable=%s has no value\n", var_name);
     }
 }
 
@@ -224,28 +225,28 @@
   g_mmbefore = mallinfo();
   g_mmprevious = g_mmbefore;
 
-  printf("\nuser_main: Begin argument test\n");
-  printf("user_main: Started with argc=%d\n", argc);
+  _info("\nuser_main: Begin argument test\n");
+  _info("user_main: Started with argc=%d\n", argc);
 
   /* Verify passed arguments */
 
   if (argc != NARGS + 1)
     {
-      printf("user_main: ERROR expected argc=%d got argc=%d\n",
+      _info("user_main: ERROR expected argc=%d got argc=%d\n",
              NARGS + 1, argc);
       ASSERT(false);
     }
 
   for (i = 0; i <= NARGS; i++)
     {
-      printf("user_main: argv[%d]=\"%s\"\n", i, argv[i]);
+      _info("user_main: argv[%d]=\"%s\"\n", i, argv[i]);
     }
 
   for (i = 1; i <= NARGS; i++)
     {
       if (strcmp(argv[i], g_argv[i - 1]) != 0)
         {
-          printf("user_main: ERROR argv[%d]:  "
+          _info("user_main: ERROR argv[%d]:  "
                  "Expected \"%s\" found \"%s\"\n",
                  i, g_argv[i - 1], argv[i]);
           ASSERT(false);
@@ -258,13 +259,13 @@
    * features.
    */
 
-  printf("\nuser_main: getopt() test\n");
+  _info("\nuser_main: getopt() test\n");
   getopt_test();
   check_test_memory_usage();
 
   /* Test misc libc functions. */
 
-  printf("\nuser_main: libc tests\n");
+  _info("\nuser_main: libc tests\n");
   memmem_test();
   check_test_memory_usage();
 
@@ -288,7 +289,7 @@
       ret = sigaction(SIGCHLD, &sa, NULL);
       if (ret < 0)
         {
-          printf("user_main: ERROR: sigaction failed: %d\n", errno);
+          _info("user_main: ERROR: sigaction failed: %d\n", errno);
           ASSERT(false);
         }
     }
@@ -318,7 +319,7 @@
 #ifdef CONFIG_SCHED_THREAD_LOCAL
   /* Test __thread/thread_local keyword */
 
-  printf("\nuser_main: sched_thread_local test\n");
+  _info("\nuser_main: sched_thread_local test\n");
   sched_thread_local_test();
   check_test_memory_usage();
 #endif
@@ -334,7 +335,7 @@
 #ifndef CONFIG_STDIO_DISABLE_BUFFERING
       /* Checkout setvbuf */
 
-      printf("\nuser_main: setvbuf test\n");
+      _info("\nuser_main: setvbuf test\n");
       setvbuf_test();
       check_test_memory_usage();
 #endif
@@ -342,7 +343,7 @@
       /* Checkout /dev/null */
 
 #ifdef CONFIG_DEV_NULL
-      printf("\nuser_main: /dev/null test\n");
+      _info("\nuser_main: /dev/null test\n");
       dev_null_test();
       check_test_memory_usage();
 #endif
@@ -350,7 +351,7 @@
 #ifdef CONFIG_TESTING_OSTEST_AIO
       /* Check asynchronous I/O */
 
-      printf("\nuser_main: AIO test\n");
+      _info("\nuser_main: AIO test\n");
       aio_test();
       check_test_memory_usage();
 #endif
@@ -359,7 +360,7 @@
     defined(CONFIG_BUILD_FLAT)
       /* Check that the FPU is properly supported during context switching */
 
-      printf("\nuser_main: FPU test\n");
+      _info("\nuser_main: FPU test\n");
       fpu_test();
       check_test_memory_usage();
 #endif
@@ -367,7 +368,7 @@
 #ifndef CONFIG_BUILD_KERNEL
       /* Checkout task_restart() */
 
-      printf("\nuser_main: task_restart test\n");
+      _info("\nuser_main: task_restart test\n");
       restart_test();
       check_test_memory_usage();
 #endif
@@ -375,7 +376,7 @@
 #if defined(CONFIG_SCHED_WAITPID) && !defined(CONFIG_BUILD_KERNEL)
       /* Check waitpid() and friends */
 
-      printf("\nuser_main: waitpid test\n");
+      _info("\nuser_main: waitpid test\n");
       waitpid_test();
       check_test_memory_usage();
 #endif
@@ -384,7 +385,7 @@
     defined(CONFIG_SCHED_WORKQUEUE)
       /* Check work queues */
 
-      printf("\nuser_main: wqueue test\n");
+      _info("\nuser_main: wqueue test\n");
       wqueue_test();
       check_test_memory_usage();
 #endif
@@ -392,11 +393,11 @@
 #ifndef CONFIG_DISABLE_PTHREAD
       /* Verify pthreads and pthread mutex */
 
-      printf("\nuser_main: mutex test\n");
+      _info("\nuser_main: mutex test\n");
       mutex_test();
       check_test_memory_usage();
 
-      printf("\nuser_main: timed mutex test\n");
+      _info("\nuser_main: timed mutex test\n");
       timedmutex_test();
       check_test_memory_usage();
 #endif
@@ -404,7 +405,7 @@
 #if !defined(CONFIG_DISABLE_PTHREAD) && defined(CONFIG_PTHREAD_MUTEX_TYPES)
       /* Verify recursive mutexes */
 
-      printf("\nuser_main: recursive mutex test\n");
+      _info("\nuser_main: recursive mutex test\n");
       recursive_mutex_test();
       check_test_memory_usage();
 #endif
@@ -412,7 +413,7 @@
 #if !defined(CONFIG_DISABLE_PTHREAD) && CONFIG_TLS_NELEM > 0
       /* Verify pthread-specific data */
 
-      printf("\nuser_main: pthread-specific data test\n");
+      _info("\nuser_main: pthread-specific data test\n");
       specific_test();
       check_test_memory_usage();
 #endif
@@ -420,12 +421,12 @@
 #ifndef CONFIG_DISABLE_PTHREAD
       /* Verify pthread cancellation */
 
-      printf("\nuser_main: cancel test\n");
+      _info("\nuser_main: cancel test\n");
       cancel_test();
       check_test_memory_usage();
 
 #ifndef CONFIG_PTHREAD_MUTEX_UNSAFE
-      printf("\nuser_main: robust test\n");
+      _info("\nuser_main: robust test\n");
       robust_test();
       check_test_memory_usage();
 #endif
@@ -434,16 +435,16 @@
 #ifndef CONFIG_DISABLE_PTHREAD
       /* Verify pthreads and semaphores */
 
-      printf("\nuser_main: semaphore test\n");
+      _info("\nuser_main: semaphore test\n");
       sem_test();
       check_test_memory_usage();
 
-      printf("\nuser_main: timed semaphore test\n");
+      _info("\nuser_main: timed semaphore test\n");
       semtimed_test();
       check_test_memory_usage();
 
 #ifdef CONFIG_FS_NAMED_SEMAPHORES
-      printf("\nuser_main: Named semaphore test\n");
+      _info("\nuser_main: Named semaphore test\n");
       nsem_test();
       check_test_memory_usage();
 
@@ -453,9 +454,9 @@
 #ifndef CONFIG_DISABLE_PTHREAD
       /* Verify pthreads and condition variables */
 
-      printf("\nuser_main: condition variable test\n");
+      _info("\nuser_main: condition variable test\n");
 #ifdef CONFIG_PRIORITY_INHERITANCE
-      printf("\n           Skipping, "
+      _info("\n           Skipping, "
              "Test logic incompatible with priority inheritance\n");
 #else
       cond_test();
@@ -465,32 +466,32 @@
 #ifdef CONFIG_SCHED_WAITPID
       /* Verify pthread_exit() and pthread_self() */
 
-      printf("\nuser_main: pthread_exit() test\n");
+      _info("\nuser_main: pthread_exit() test\n");
       pthread_exit_test();
       check_test_memory_usage();
 #endif
 
       /* Verify pthreads rwlock interfaces */
 
-      printf("\nuser_main: pthread_rwlock test\n");
+      _info("\nuser_main: pthread_rwlock test\n");
       pthread_rwlock_test();
       check_test_memory_usage();
 
-      printf("\nuser_main: pthread_rwlock_cancel test\n");
+      _info("\nuser_main: pthread_rwlock_cancel test\n");
       pthread_rwlock_cancel_test();
       check_test_memory_usage();
 
 #if CONFIG_TLS_NCLEANUP > 0
       /* Verify pthread cancellation cleanup handlers */
 
-      printf("\nuser_main: pthread_cleanup test\n");
+      _info("\nuser_main: pthread_cleanup test\n");
       pthread_cleanup_test();
       check_test_memory_usage();
 #endif
 
       /* Verify pthreads and condition variable timed waits */
 
-      printf("\nuser_main: timed wait test\n");
+      _info("\nuser_main: timed wait test\n");
       timedwait_test();
       check_test_memory_usage();
 #endif /* !CONFIG_DISABLE_PTHREAD */
@@ -498,7 +499,7 @@
 #if !defined(CONFIG_DISABLE_MQUEUE) && !defined(CONFIG_DISABLE_PTHREAD)
       /* Verify pthreads and message queues */
 
-      printf("\nuser_main: message queue test\n");
+      _info("\nuser_main: message queue test\n");
       mqueue_test();
       check_test_memory_usage();
 #endif
@@ -506,36 +507,36 @@
 #if !defined(CONFIG_DISABLE_MQUEUE) && !defined(CONFIG_DISABLE_PTHREAD)
       /* Verify pthreads and message queues */
 
-      printf("\nuser_main: timed message queue test\n");
+      _info("\nuser_main: timed message queue test\n");
       timedmqueue_test();
       check_test_memory_usage();
 #endif
 
       /* Verify that we can modify the signal mask */
 
-      printf("\nuser_main: sigprocmask test\n");
+      _info("\nuser_main: sigprocmask test\n");
       sigprocmask_test();
       check_test_memory_usage();
 
       /* Verify signal handlers */
 
-      printf("\nuser_main: signal handler test\n");
+      _info("\nuser_main: signal handler test\n");
       sighand_test();
       check_test_memory_usage();
 
-      printf("\nuser_main: nested signal handler test\n");
+      _info("\nuser_main: nested signal handler test\n");
       signest_test();
       check_test_memory_usage();
 
 #if defined(CONFIG_SIG_SIGSTOP_ACTION) && defined(CONFIG_SIG_SIGKILL_ACTION) && \
     !defined(CONFIG_BUILD_KERNEL)
-      printf("\nuser_main: signal action test\n");
+      _info("\nuser_main: signal action test\n");
       suspend_test();
       check_test_memory_usage();
 #endif
 
 #ifdef CONFIG_BUILD_FLAT
-      printf("\nuser_main: wdog test\n");
+      _info("\nuser_main: wdog test\n");
       wdog_test();
       check_test_memory_usage();
 #endif
@@ -543,14 +544,14 @@
 #ifndef CONFIG_DISABLE_POSIX_TIMERS
       /* Verify posix timers (with SIGEV_SIGNAL) */
 
-      printf("\nuser_main: POSIX timer test\n");
+      _info("\nuser_main: POSIX timer test\n");
       timer_test();
       check_test_memory_usage();
 
 #ifdef CONFIG_SIG_EVTHREAD
       /* Verify posix timers (with SIGEV_THREAD) */
 
-      printf("\nuser_main: SIGEV_THREAD timer test\n");
+      _info("\nuser_main: SIGEV_THREAD timer test\n");
       sigev_thread_test();
       check_test_memory_usage();
 #endif
@@ -559,7 +560,7 @@
 #if !defined(CONFIG_DISABLE_PTHREAD) && CONFIG_RR_INTERVAL > 0
       /* Verify round robin scheduling */
 
-      printf("\nuser_main: round-robin scheduler test\n");
+      _info("\nuser_main: round-robin scheduler test\n");
       rr_test();
       check_test_memory_usage();
 #endif
@@ -567,11 +568,11 @@
 #if !defined(CONFIG_DISABLE_PTHREAD) && defined(CONFIG_SCHED_SPORADIC)
       /* Verify sporadic scheduling */
 
-      printf("\nuser_main: sporadic scheduler test\n");
+      _info("\nuser_main: sporadic scheduler test\n");
       sporadic_test();
       check_test_memory_usage();
 
-      printf("\nuser_main: Dual sporadic thread test\n");
+      _info("\nuser_main: Dual sporadic thread test\n");
       sporadic2_test();
       check_test_memory_usage();
 #endif
@@ -579,7 +580,7 @@
 #ifndef CONFIG_DISABLE_PTHREAD
       /* Verify pthread barriers */
 
-      printf("\nuser_main: barrier test\n");
+      _info("\nuser_main: barrier test\n");
       barrier_test();
       check_test_memory_usage();
 #endif
@@ -587,7 +588,7 @@
 #ifdef CONFIG_ARCH_SETJMP_H
       /* Verify setjmp/longjmp */
 
-      printf("\nuser_main: setjmp test\n");
+      _info("\nuser_main: setjmp test\n");
       setjmp_test();
       check_test_memory_usage();
 #endif
@@ -595,32 +596,32 @@
 #if defined(CONFIG_PRIORITY_INHERITANCE) && !defined(CONFIG_DISABLE_PTHREAD)
       /* Verify priority inheritance */
 
-      printf("\nuser_main: priority inheritance test\n");
+      _info("\nuser_main: priority inheritance test\n");
       priority_inheritance();
       check_test_memory_usage();
 #endif /* CONFIG_PRIORITY_INHERITANCE && !CONFIG_DISABLE_PTHREAD */
 
 #ifndef CONFIG_DISABLE_PTHREAD
-      printf("\nuser_main: scheduler lock test\n");
+      _info("\nuser_main: scheduler lock test\n");
       sched_lock_test();
       check_test_memory_usage();
 #endif
 
 #if defined(CONFIG_ARCH_HAVE_FORK) && defined(CONFIG_SCHED_WAITPID) && \
    !defined(CONFIG_ARCH_SIM)
-      printf("\nuser_main: vfork() test\n");
+      _info("\nuser_main: vfork() test\n");
       vfork_test();
 #endif
 
 #if defined(CONFIG_SMP) && defined(CONFIG_BUILD_FLAT)
-      printf("\nuser_main: smp call test\n");
+      _info("\nuser_main: smp call test\n");
       smp_call_test();
 #endif
 
 #if defined(CONFIG_SCHED_EVENTS) && defined(CONFIG_BUILD_FLAT)
       /* Verify nxevent */
 
-      printf("\nuser_main: nxevent test\n");
+      _info("\nuser_main: nxevent test\n");
       nxevent_test();
       check_test_memory_usage();
 #endif
@@ -635,11 +636,11 @@
 
       g_mmafter = mallinfo();
 
-      printf("\nFinal memory usage:\n");
+      _info("\nFinal memory usage:\n");
       show_memory_usage(&g_mmbefore, &g_mmafter);
     }
 
-  printf("user_main: Exiting\n");
+  _info("user_main: Exiting\n");
   return 0;
 }
 
@@ -652,7 +653,7 @@
   /* Verify that we can communicate */
 
   write(1, write_data1, sizeof(write_data1)-1);
-  printf("stdio_test: Standard I/O Check: printf\n");
+  _info("stdio_test: Standard I/O Check: _info\n");
 
   write(2, write_data2, sizeof(write_data2)-1);
 #ifdef CONFIG_FILE_STREAM
@@ -719,19 +720,19 @@
   /* Set up some environment variables */
 
 #ifndef CONFIG_DISABLE_ENVIRON
-  printf("ostest_main: putenv(%s)\n", g_putenv_value);
+  _info("ostest_main: putenv(%s)\n", g_putenv_value);
   putenv(g_putenv_value);                   /* Varaible1=BadValue3 */
-  printf("ostest_main: setenv(%s, %s, TRUE)\n", g_var1_name, g_var1_value);
+  _info("ostest_main: setenv(%s, %s, TRUE)\n", g_var1_name, g_var1_value);
   setenv(g_var1_name, g_var1_value, TRUE);  /* Variable1=GoodValue1 */
 
-  printf("ostest_main: setenv(%s, %s, FALSE)\n", g_var2_name, g_bad_value1);
+  _info("ostest_main: setenv(%s, %s, FALSE)\n", g_var2_name, g_bad_value1);
   setenv(g_var2_name, g_bad_value1, FALSE); /* Variable2=BadValue1 */
-  printf("ostest_main: setenv(%s, %s, TRUE)\n", g_var2_name, g_var2_value);
+  _info("ostest_main: setenv(%s, %s, TRUE)\n", g_var2_name, g_var2_value);
   setenv(g_var2_name, g_var2_value, TRUE);  /* Variable2=GoodValue2 */
 
-  printf("ostest_main: setenv(%s, %s, FALSE)\n", g_var3_name, g_var3_value);
+  _info("ostest_main: setenv(%s, %s, FALSE)\n", g_var3_name, g_var3_value);
   setenv(g_var3_name, g_var3_value, FALSE); /* Variable3=GoodValue3 */
-  printf("ostest_main: setenv(%s, %s, FALSE)\n", g_var3_name, g_bad_value2);
+  _info("ostest_main: setenv(%s, %s, FALSE)\n", g_var3_name, g_bad_value2);
   setenv(g_var3_name, g_bad_value2, FALSE); /* Variable3=GoodValue3 */
   show_environment(true, true, true);
 #endif
@@ -752,20 +753,20 @@
   if (result == ERROR)
 #endif
     {
-      printf("ostest_main: ERROR Failed to start user_main\n");
+      _info("ostest_main: ERROR Failed to start user_main\n");
       ASSERT(false);
       ostest_result = ERROR;
     }
   else
     {
-      printf("ostest_main: Started user_main at PID=%d\n", result);
+      _info("ostest_main: Started user_main at PID=%d\n", result);
 
 #ifdef CONFIG_TESTING_OSTEST_WAITRESULT
       /* Wait for the test to complete to get the test result */
 
       if (waitpid(result, &ostest_result, 0) != result)
         {
-          printf("ostest_main: ERROR Failed to wait for user_main to "
+          _info("ostest_main: ERROR Failed to wait for user_main to "
                  "terminate\n");
           ASSERT(false);
           ostest_result = ERROR;
@@ -773,7 +774,7 @@
 #endif
     }
 
-  printf("ostest_main: Exiting with status %d\n", ostest_result);
+  _info("ostest_main: Exiting with status %d\n", ostest_result);
 
 #ifdef CONFIG_TESTING_OSTEST_POWEROFF
   /* Power down, providing the test result.  This is really only an
diff -Naur apps-12.8.0/testing/ostest/posixtimer.c apps/testing/ostest/posixtimer.c
--- apps-12.8.0/testing/ostest/posixtimer.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/posixtimer.c	2025-11-04 11:04:41.028333662 +0200
@@ -30,6 +30,7 @@
 #include <semaphore.h>
 #include <signal.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 #include <nuttx/signal.h>
@@ -60,7 +61,7 @@
   sigset_t allsigs;
   int status;
 
-  printf("timer_expiration: Received signal %d\n" , signo);
+  _info("timer_expiration: Received signal %d\n" , signo);
 
   g_nsigreceived++;
 
@@ -68,7 +69,7 @@
 
   if (signo != MY_TIMER_SIGNAL)
     {
-      printf("timer_expiration: ERROR expected signo=%d\n",
+      _info("timer_expiration: ERROR expected signo=%d\n",
              MY_TIMER_SIGNAL);
       ASSERT(false);
     }
@@ -77,36 +78,36 @@
 
   if (info->si_value.sival_int != SIGVALUE_INT)
     {
-      printf("timer_expiration: ERROR sival_int=%d expected %d\n",
+      _info("timer_expiration: ERROR sival_int=%d expected %d\n",
               info->si_value.sival_int, SIGVALUE_INT);
       ASSERT(false);
     }
   else
     {
-      printf("timer_expiration: sival_int=%d\n" , info->si_value.sival_int);
+      _info("timer_expiration: sival_int=%d\n" , info->si_value.sival_int);
     }
 
   if (info->si_signo != MY_TIMER_SIGNAL)
     {
-      printf("timer_expiration: ERROR expected si_signo=%d, got=%d\n",
+      _info("timer_expiration: ERROR expected si_signo=%d, got=%d\n",
                MY_TIMER_SIGNAL, info->si_signo);
       ASSERT(false);
     }
 
   if (info->si_code == SI_TIMER)
     {
-      printf("timer_expiration: si_code=%d (SI_TIMER)\n" , info->si_code);
+      _info("timer_expiration: si_code=%d (SI_TIMER)\n" , info->si_code);
     }
   else
     {
-      printf("timer_expiration: ERROR si_code=%d, expected SI_TIMER=%d\n",
+      _info("timer_expiration: ERROR si_code=%d, expected SI_TIMER=%d\n",
              info->si_code, SI_TIMER);
       ASSERT(false);
     }
 
   /* Check ucontext_t */
 
-  printf("timer_expiration: ucontext=%p\n" , ucontext);
+  _info("timer_expiration: ucontext=%p\n" , ucontext);
 
   /* Check sigprocmask */
 
@@ -114,14 +115,14 @@
   status = sigprocmask(SIG_SETMASK, NULL, &oldset);
   if (status != OK)
     {
-      printf("timer_expiration: ERROR sigprocmask failed, status=%d\n",
+      _info("timer_expiration: ERROR sigprocmask failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
   if (!sigset_isequal(&oldset, &allsigs))
     {
-      printf("timer_expiration: ERROR sigprocmask=" SIGSET_FMT
+      _info("timer_expiration: ERROR sigprocmask=" SIGSET_FMT
              " expected=" SIGSET_FMT "\n",
              SIGSET_ELEM(&oldset), SIGSET_ELEM(&allsigs));
       ASSERT(false);
@@ -143,24 +144,24 @@
   int                status;
   int                i;
 
-  printf("timer_test: Initializing semaphore to 0\n");
+  _info("timer_test: Initializing semaphore to 0\n");
   sem_init(&sem, 0, 0);
 
   /* Start waiter thread  */
 
-  printf("timer_test: Unmasking signal %d\n" , MY_TIMER_SIGNAL);
+  _info("timer_test: Unmasking signal %d\n" , MY_TIMER_SIGNAL);
 
   sigemptyset(&set);
   sigaddset(&set, MY_TIMER_SIGNAL);
   status = sigprocmask(SIG_UNBLOCK, &set, NULL);
   if (status != OK)
     {
-      printf("timer_test: ERROR sigprocmask failed, status=%d\n",
+      _info("timer_test: ERROR sigprocmask failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
-  printf("timer_test: Registering signal handler\n");
+  _info("timer_test: Registering signal handler\n");
   act.sa_sigaction = timer_expiration;
   act.sa_flags  = SA_SIGINFO;
 
@@ -170,19 +171,19 @@
   status = sigaction(MY_TIMER_SIGNAL, &act, &oact);
   if (status != OK)
     {
-      printf("timer_test: ERROR sigaction failed, status=%d\n" , status);
+      _info("timer_test: ERROR sigaction failed, status=%d\n" , status);
       ASSERT(false);
     }
 
 #ifndef SDCC
-  printf("timer_test: oact.sigaction=%p oact.sa_flags=%x "
+  _info("timer_test: oact.sigaction=%p oact.sa_flags=%x "
          "oact.sa_mask=" SIGSET_FMT "\n",
          oact.sa_sigaction, oact.sa_flags, SIGSET_ELEM(&oact.sa_mask));
 #endif
 
   /* Create the POSIX timer */
 
-  printf("timer_test: Creating timer\n");
+  _info("timer_test: Creating timer\n");
 
   notify.sigev_notify            = SIGEV_SIGNAL;
   notify.sigev_signo             = MY_TIMER_SIGNAL;
@@ -195,24 +196,24 @@
   status = timer_create(CLOCK_REALTIME, &notify, &timerid);
   if (status != OK)
     {
-      printf("timer_test: ERROR timer_create failed, errno=%d\n", errno);
+      _info("timer_test: ERROR timer_create failed, errno=%d\n", errno);
       ASSERT(false);
       goto errorout;
     }
 
   /* Start the POSIX timer */
 
-  printf("timer_test: Starting timer\n");
+  _info("timer_test: Starting timer\n");
 
-  timer.it_value.tv_sec     = 2;
-  timer.it_value.tv_nsec    = 0;
-  timer.it_interval.tv_sec  = 2;
-  timer.it_interval.tv_nsec = 0;
+  timer.it_value.tv_sec     = 0;
+  timer.it_value.tv_nsec    = 1000000;
+  timer.it_interval.tv_sec  = 0;
+  timer.it_interval.tv_nsec = 1000000;
 
   status = timer_settime(timerid, 0, &timer, NULL);
   if (status != OK)
     {
-      printf("timer_test: ERROR timer_settime failed, errno=%d\n", errno);
+      _info("timer_test: ERROR timer_settime failed, errno=%d\n", errno);
       ASSERT(false);
       goto errorout;
     }
@@ -221,7 +222,7 @@
 
   for (i = 0; i < 5; i++)
     {
-      printf("timer_test: Waiting on semaphore\n");
+      _info("timer_test: Waiting on semaphore\n");
       FFLUSH();
       status = sem_wait(&sem);
       if (status != 0)
@@ -229,22 +230,22 @@
           int error = errno;
           if (error == EINTR)
             {
-              printf("timer_test: sem_wait() successfully interrupted "
+              _info("timer_test: sem_wait() successfully interrupted "
                      "by signal\n");
             }
           else
             {
-              printf("timer_test: ERROR sem_wait failed, errno=%d\n", error);
+              _info("timer_test: ERROR sem_wait failed, errno=%d\n", error);
               ASSERT(false);
             }
         }
       else
         {
-          printf("timer_test: ERROR awakened with no error!\n");
+          _info("timer_test: ERROR awakened with no error!\n");
           ASSERT(false);
         }
 
-      printf("timer_test: g_nsigreceived=%d\n", g_nsigreceived);
+      _info("timer_test: g_nsigreceived=%d\n", g_nsigreceived);
     }
 
 errorout:
@@ -252,11 +253,11 @@
 
   /* Then delete the timer */
 
-  printf("timer_test: Deleting timer\n");
+  _info("timer_test: Deleting timer\n");
   status = timer_delete(timerid);
   if (status != OK)
     {
-      printf("timer_test: ERROR timer_create failed, errno=%d\n", errno);
+      _info("timer_test: ERROR timer_create failed, errno=%d\n", errno);
       ASSERT(false);
     }
 
@@ -265,6 +266,6 @@
   act.sa_handler = SIG_DFL;
   status = sigaction(MY_TIMER_SIGNAL, &act, &oact);
 
-  printf("timer_test: done\n");
+  _info("timer_test: done\n");
   FFLUSH();
 }
diff -Naur apps-12.8.0/testing/ostest/prioinherit.c apps/testing/ostest/prioinherit.c
--- apps-12.8.0/testing/ostest/prioinherit.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/prioinherit.c	2025-11-04 11:04:41.007345868 +0200
@@ -30,6 +30,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -112,7 +113,7 @@
 
       if (status != 0)
         {
-          printf("priority_inheritance: ERROR sched_getparam failed\n");
+          _info("priority_inheritance: ERROR sched_getparam failed\n");
           ASSERT(false);
         }
 
@@ -120,13 +121,13 @@
         {
           if (g_priority_tracking[n] == 0)
             {
-              printf("priority_inheritance: "
+              _info("priority_inheritance: "
                      "Task%1d initial priority is:%d\n",
                      n, sparam.sched_priority);
             }
           else
             {
-              printf("priority_inheritance: "
+              _info("priority_inheritance: "
                      "Task%1d priority was:%d is:%d\n",
                      n, g_priority_tracking[n], sparam.sched_priority);
             }
@@ -152,12 +153,12 @@
   int hold_delay   = atoi(argv[3]);
 
   sleep_and_display(index, inital_delay);
-  printf("priority_inheritance: "
+  _info("priority_inheritance: "
          "%s Started, waiting %d uS to take count\n", argv[0], inital_delay);
   sem_wait(&g_sem);
   sleep_and_display(index,  hold_delay);
   sem_post(&g_sem);
-  printf("priority_inheritance: %s Posted\n", argv[0]);
+  _info("priority_inheritance: %s Posted\n", argv[0]);
   sleep_and_display(index, 0);
   return 0;
 }
@@ -213,36 +214,36 @@
 
   g_highstate[threadno - 1] = RUNNING;
 
-  printf("highpri_thread-%d: Started\n", threadno);
+  _info("highpri_thread-%d: Started\n", threadno);
   FFLUSH();
-  sleep(1);
+  usleep(1);
 
-  printf("highpri_thread-%d: Calling sem_wait()\n", threadno);
+  _info("highpri_thread-%d: Calling sem_wait()\n", threadno);
   g_highstate[threadno - 1] = WAITING;
   ret                     = sem_wait(&g_sem);
   g_highstate[threadno - 1] = DONE;
 
   if (ret != 0)
     {
-      printf("highpri_thread-%d: "
+      _info("highpri_thread-%d: "
              "ERROR sem_take failed: %d\n", threadno, ret);
       ASSERT(false);
     }
   else if (g_middlestate == RUNNING)
     {
-      printf("highpri_thread-%d: SUCCESS midpri_thread is still running!\n",
+      _info("highpri_thread-%d: SUCCESS midpri_thread is still running!\n",
              threadno);
     }
   else
     {
-      printf("highpri_thread-%d: ERROR --  "
+      _info("highpri_thread-%d: ERROR --  "
              "midpri_thread has already exited!\n",
              threadno);
       ASSERT(false);
     }
 
   sem_post(&g_sem);
-  printf("highpri_thread-%d: Okay... I'm done!\n", threadno);
+  _info("highpri_thread-%d: Okay... I'm done!\n", threadno);
   FFLUSH();
   return NULL;
 }
@@ -266,7 +267,7 @@
   up_idle();
 #else
   /* On real platforms with a real timer interrupt, we really can hog the
-   * CPU.  When the sleep() goes off in priority_inheritance(), it will
+   * CPU.  When the usleep() goes off in priority_inheritance(), it will
    * wake up and start the high priority thread.
    */
 
@@ -281,7 +282,7 @@
 
 static FAR void *medpri_thread(FAR void *parameter)
 {
-  printf("medpri_thread: Started ... I won't let go of the CPU!\n");
+  _info("medpri_thread: Started ... I won't let go of the CPU!\n");
   g_middlestate = RUNNING;
   FFLUSH();
 
@@ -295,7 +296,7 @@
       hog_cpu();
     }
 
-  printf("medpri_thread: Okay... I'm done!\n");
+  _info("medpri_thread: Okay... I'm done!\n");
   FFLUSH();
   g_middlestate = DONE;
   return NULL;
@@ -318,22 +319,22 @@
   int i;
 
   g_lowstate[threadno - 1] = RUNNING;
-  printf("lowpri_thread-%d: Started\n", threadno);
+  _info("lowpri_thread-%d: Started\n", threadno);
 
   ret = pthread_getschedparam(pthread_self(), &policy, &sparam);
   if (ret != 0)
     {
-      printf("lowpri_thread-%d: ERROR pthread_getschedparam failed: %d\n",
+      _info("lowpri_thread-%d: ERROR pthread_getschedparam failed: %d\n",
              threadno, ret);
       ASSERT(false);
     }
   else
     {
-      printf("lowpri_thread-%d: initial priority: %d\n", threadno,
+      _info("lowpri_thread-%d: initial priority: %d\n", threadno,
           sparam.sched_priority);
       if (sparam.sched_priority != g_lowpri)
         {
-          printf("               ERROR should have been %d\n", g_lowpri);
+          _info("               ERROR should have been %d\n", g_lowpri);
           ASSERT(false);
         }
     }
@@ -342,7 +343,7 @@
   ret = sem_wait(&g_sem);
   if (ret != 0)
     {
-      printf("lowpri_thread-%d: ERROR sem_take failed: %d\n", threadno, ret);
+      _info("lowpri_thread-%d: ERROR sem_take failed: %d\n", threadno, ret);
       ASSERT(false);
     }
   else
@@ -352,18 +353,18 @@
       while (g_middlestate == NOTSTARTED &&
              nhighpri_waiting() < NHIGHPRI_THREADS)
         {
-          printf("lowpri_thread-%d: Waiting for the midle pri task to run\n",
+          _info("lowpri_thread-%d: Waiting for the midle pri task to run\n",
                  threadno);
-          printf("    g_middlestate:  %d\n", (int)g_middlestate);
+          _info("    g_middlestate:  %d\n", (int)g_middlestate);
           for (i = 0; i < NHIGHPRI_THREADS; i++)
             {
-              printf("    g_highstate[%d]: %d\n", i, (int)g_highstate[i]);
+              _info("    g_highstate[%d]: %d\n", i, (int)g_highstate[i]);
             }
 
-          printf("    I still have a count on the semaphore\n");
+          _info("    I still have a count on the semaphore\n");
           sem_enumholders(&g_sem);
           FFLUSH();
-          sleep(1);
+          usleep(1);
         }
 
       /* Account for all of the semaphore counts.  At any given time if there
@@ -378,12 +379,12 @@
 
       if (ret < 0)
         {
-          printf("lowpri_thread-%d: ERROR sem_getvalue failed: %d\n",
+          _info("lowpri_thread-%d: ERROR sem_getvalue failed: %d\n",
                  threadno, errno);
           ASSERT(false);
         }
 
-      printf("lowpri_thread-%d: Sem count: %d, No. highpri thread: %d\n",
+      _info("lowpri_thread-%d: Sem count: %d, No. highpri thread: %d\n",
              threadno, count, nwaiting);
 
       /* The middle priority task is running, let go of the semaphore */
@@ -402,15 +403,15 @@
            * priority threads should have already completed.
            */
 
-          printf("lowpri_thread-%d: %s the middle priority task has already"
+          _info("lowpri_thread-%d: %s the middle priority task has already"
                  " exitted!\n",
                  threadno, count >= 0 ? "SUCCESS" : "ERROR");
           ASSERT(count >= 0);
-          printf("               g_middlestate:  %d sem count=%d\n",
+          _info("               g_middlestate:  %d sem count=%d\n",
                  (int)g_middlestate, count);
           for (i = 0; i < NHIGHPRI_THREADS; i++)
             {
-              printf("               g_highstate[%d]: %d\n",
+              _info("               g_highstate[%d]: %d\n",
                      i, (int)g_highstate[i]);
             }
         }
@@ -421,7 +422,7 @@
   sem_post(&g_sem);
   if (ret != 0)
     {
-      printf("lowpri_thread-%d: ERROR pthread_getschedparam failed: %d\n",
+      _info("lowpri_thread-%d: ERROR pthread_getschedparam failed: %d\n",
              threadno, ret);
       ASSERT(false);
     }
@@ -436,14 +437,14 @@
           expected = g_lowpri;
         }
 
-      printf("lowpri_thread-%d: %s priority before sem_post: %d\n",
+      _info("lowpri_thread-%d: %s priority before sem_post: %d\n",
              threadno,
              sparam.sched_priority != expected ? "ERROR" : "SUCCESS",
              sparam.sched_priority);
 
       if (sparam.sched_priority != expected)
         {
-          printf("               ERROR should have been %d\n", expected);
+          _info("               ERROR should have been %d\n", expected);
           ASSERT(false);
         }
     }
@@ -451,27 +452,27 @@
   ret = pthread_getschedparam(pthread_self(), &policy, &sparam);
   if (ret != 0)
     {
-      printf("lowpri_thread-%d: ERROR pthread_getschedparam failed: %d\n",
+      _info("lowpri_thread-%d: ERROR pthread_getschedparam failed: %d\n",
              threadno, ret);
       ASSERT(false);
     }
   else
     {
-      printf("lowpri_thread-%d: %s final priority: %d\n",
+      _info("lowpri_thread-%d: %s final priority: %d\n",
              threadno,
              sparam.sched_priority != g_lowpri ? "ERROR" : "SUCCESS",
              sparam.sched_priority);
 
       if (sparam.sched_priority != g_lowpri)
         {
-          printf("               ERROR should have been %d\n", g_lowpri);
+          _info("               ERROR should have been %d\n", g_lowpri);
           ASSERT(false);
         }
     }
 
   sem_enumholders(&g_sem);
 
-  printf("lowpri_thread-%d: Okay... I'm done!\n", threadno);
+  _info("lowpri_thread-%d: Okay... I'm done!\n", threadno);
   FFLUSH();
   g_lowstate[threadno - 1] = DONE;
   return retval;
@@ -505,7 +506,7 @@
   int priority;
   int restoration_result;
 
-  printf("priority_inheritance: Started\n");
+  _info("priority_inheritance: Started\n");
 
   g_middlestate = NOTSTARTED;
   for (i = 0; i < NHIGHPRI_THREADS; i++) g_highstate[i] = NOTSTARTED;
@@ -514,7 +515,7 @@
   status = sched_getparam(gettid(), &sparam);
   if (status != 0)
     {
-      printf("priority_inheritance: ERROR sched_getparam failed\n");
+      _info("priority_inheritance: ERROR sched_getparam failed\n");
       ASSERT(false);
       sparam.sched_priority = PTHREAD_DEFAULT_PRIORITY;
     }
@@ -535,13 +536,13 @@
   for (i = 0; i < NLOWPRI_THREADS; i++)
     {
       int threadno = i + 1;
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "Starting lowpri_thread-%d (of %d) at %d\n",
              threadno, NLOWPRI_THREADS, g_lowpri);
       status = pthread_attr_init(&attr);
       if (status != 0)
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "ERROR pthread_attr_init failed, status=%d\n",
                  status);
           ASSERT(false);
@@ -551,14 +552,14 @@
       status = pthread_attr_setschedparam(&attr, &sparam);
       if (status != OK)
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "ERROR pthread_attr_setschedparam failed, status=%d\n",
                  status);
           ASSERT(false);
         }
       else
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "Set lowpri_thread-%d priority to %d\n",
                  threadno, sparam.sched_priority);
         }
@@ -567,23 +568,23 @@
                               (FAR void *)((uintptr_t)threadno));
       if (status != 0)
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "ERROR pthread_create failed, status=%d\n", status);
           ASSERT(false);
         }
     }
 
-  printf("priority_inheritance: Waiting...\n");
-  sleep(2);
+  _info("priority_inheritance: Waiting...\n");
+  usleep(2);
   dump_nfreeholders("priority_inheritance:");
 
   /* Start the medium priority thread */
 
-  printf("priority_inheritance: Starting medpri_thread at %d\n", g_medpri);
+  _info("priority_inheritance: Starting medpri_thread at %d\n", g_medpri);
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "ERROR pthread_attr_init failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -592,14 +593,14 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "ERROR pthread_attr_setschedparam failed, status=%d\n",
               status);
       ASSERT(false);
     }
   else
     {
-      printf("priority_inheritance: Set medpri_thread priority to %d\n",
+      _info("priority_inheritance: Set medpri_thread priority to %d\n",
              sparam.sched_priority);
     }
 
@@ -608,14 +609,14 @@
   status = pthread_create(&medpri, &attr, medpri_thread, NULL);
   if (status != 0)
     {
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "ERROR pthread_create failed, status=%d\n",
              status);
       ASSERT(false);
     }
 
-  printf("priority_inheritance: Waiting...\n");
-  sleep(1);
+  _info("priority_inheritance: Waiting...\n");
+  usleep(1);
   dump_nfreeholders("priority_inheritance:");
 
   /* Start the high priority threads */
@@ -623,13 +624,13 @@
   for (i = 0; i < NHIGHPRI_THREADS; i++)
     {
       int threadno = i + 1;
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "Starting highpri_thread-%d (of %d) at %d\n",
              threadno, NHIGHPRI_THREADS, g_highpri);
       status = pthread_attr_init(&attr);
       if (status != 0)
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "ERROR pthread_attr_init failed, status=%d\n", status);
           ASSERT(false);
         }
@@ -638,14 +639,14 @@
       status = pthread_attr_setschedparam(&attr, &sparam);
       if (status != OK)
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "ERROR pthread_attr_setschedparam failed, status=%d\n",
                  status);
           ASSERT(false);
         }
       else
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "Set highpri_thread-%d priority to %d\n",
                  threadno, sparam.sched_priority);
         }
@@ -656,7 +657,7 @@
                               (FAR void *)((uintptr_t)threadno));
       if (status != 0)
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "ERRROR pthread_create failed, status=%d\n", status);
           ASSERT(false);
         }
@@ -669,21 +670,21 @@
 
   for (i = 0; i < NHIGHPRI_THREADS; i++)
     {
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "Waiting for highpri_thread-%d to complete\n", i + 1);
       FFLUSH();
       pthread_join(highpri[i], &result);
       dump_nfreeholders("priority_inheritance:");
     }
 
-  printf("priority_inheritance: Waiting for medpri_thread to complete\n");
+  _info("priority_inheritance: Waiting for medpri_thread to complete\n");
   FFLUSH();
   pthread_join(medpri, &result);
   dump_nfreeholders("priority_inheritance:");
 
   for (i = 0; i < NLOWPRI_THREADS; i++)
     {
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "Waiting for lowpri_thread-%d to complete\n", i + 1);
       FFLUSH();
       pthread_join(lowpri[i], &result);
@@ -692,7 +693,7 @@
 
   /* Perform restoration test */
 
-  printf("priority_inheritance: Restoration Test:\n");
+  _info("priority_inheritance: Restoration Test:\n");
 
   sem_init(&g_sem, 0, 1);
   priority = COMPETING_THREAD_START_PRIORITY;
@@ -718,13 +719,13 @@
   restoration_result = 0;
   for (i = 0; i < NUMBER_OF_COMPETING_THREADS; i++)
     {
-      printf("priority_inheritance: "
+      _info("priority_inheritance: "
              "Waiting for Task-%d to complete\n", i);
 
       waitpid(pids[i], &status, 0);
       if (priority != g_priority_tracking[i])
         {
-          printf("priority_inheritance: "
+          _info("priority_inheritance: "
                  "Task-%d Priority is %d, and was not restored to %d\n",
                   i, g_priority_tracking[i], priority);
 
@@ -736,17 +737,17 @@
 
   if (restoration_result != 0)
     {
-      printf("priority_inheritance: ERROR: FAIL Priorities were not "
+      _info("priority_inheritance: ERROR: FAIL Priorities were not "
              "correctly restored.\n");
       ASSERT(false);
     }
   else
     {
-      printf("priority_inheritance: PASSED Priority were correctly"
+      _info("priority_inheritance: PASSED Priority were correctly"
              " restored.\n");
     }
 
-  printf("priority_inheritance: Finished\n");
+  _info("priority_inheritance: Finished\n");
   sem_destroy(&g_sem);
   dump_nfreeholders("priority_inheritance:");
   FFLUSH();
diff -Naur apps-12.8.0/testing/ostest/pthread_cleanup.c apps/testing/ostest/pthread_cleanup.c
--- apps-12.8.0/testing/ostest/pthread_cleanup.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/pthread_cleanup.c	2025-11-04 11:04:41.008345286 +0200
@@ -28,6 +28,7 @@
 #include <errno.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 /****************************************************************************
@@ -58,7 +59,7 @@
 #ifndef CONFIG_CANCELLATION_POINTS
   if (status == EPERM)
     {
-      printf("pthread_cleanup: thread did not have mutex locked: %d\n",
+      _info("pthread_cleanup: thread did not have mutex locked: %d\n",
               status);
       return;
     }
@@ -66,7 +67,7 @@
 
   if (status != 0)
     {
-      printf("pthread_cleanup:"
+      _info("pthread_cleanup:"
              "ERROR pthread_mutex_unlock in cleanup handler. "
              "Status: %d\n", status);
       ASSERT(false);
@@ -81,7 +82,7 @@
   status = pthread_mutex_lock(&sync->lock);
   if (status != 0)
     {
-      printf("pthread_cleanup: ERROR pthread_mutex_lock, status=%d\n",
+      _info("pthread_cleanup: ERROR pthread_mutex_lock, status=%d\n",
               status);
       ASSERT(false);
       return NULL;
@@ -94,7 +95,7 @@
       status = pthread_cond_wait(&sync->cond, &sync->lock);
       if (status != 0)
         {
-          printf("pthread_cleanup: ERROR wait returned. Status: %d\n",
+          _info("pthread_cleanup: ERROR wait returned. Status: %d\n",
                  status);
           ASSERT(false);
         }
@@ -117,7 +118,7 @@
   status = pthread_create(&thread1, NULL, cleanup_thread, &sync);
   if (status != 0)
     {
-      printf("pthread_cleanup: ERROR pthread_create, status=%d\n", status);
+      _info("pthread_cleanup: ERROR pthread_create, status=%d\n", status);
       ASSERT(false);
       return;
     }
@@ -127,19 +128,19 @@
   status = pthread_cancel(thread1);
   if (status != 0)
     {
-      printf("pthread_cleanup: ERROR pthread_cancel, status=%d\n", status);
+      _info("pthread_cleanup: ERROR pthread_cancel, status=%d\n", status);
       ASSERT(false);
     }
 
   status = pthread_join(thread1, &result);
   if (status != 0)
     {
-      printf("pthread_cleanup: ERROR pthread_join, status=%d\n", status);
+      _info("pthread_cleanup: ERROR pthread_join, status=%d\n", status);
       ASSERT(false);
     }
   else if (result != PTHREAD_CANCELED)
     {
-      printf("pthread_cleanup: "
+      _info("pthread_cleanup: "
              "ERROR pthread_join returned wrong result: %p\n", result);
       ASSERT(false);
     }
@@ -150,7 +151,7 @@
   status = pthread_mutex_trylock(&sync.lock);
   if (status != 0)
     {
-      printf("pthread_cleanup: ERROR pthread_mutex_trylock, status=%d\n",
+      _info("pthread_cleanup: ERROR pthread_mutex_trylock, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -158,7 +159,7 @@
   status = pthread_mutex_unlock(&sync.lock);
   if (status != 0)
     {
-      printf("pthread_cleanup: ERROR pthread_mutex_unlock, status=%d\n",
+      _info("pthread_cleanup: ERROR pthread_mutex_unlock, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -171,6 +172,6 @@
 
 void pthread_cleanup_test(void)
 {
-  printf("pthread_cleanup: Starting test\n");
+  _info("pthread_cleanup: Starting test\n");
   test_cleanup();
 }
diff -Naur apps-12.8.0/testing/ostest/pthread_exit.c apps/testing/ostest/pthread_exit.c
--- apps-12.8.0/testing/ostest/pthread_exit.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/pthread_exit.c	2025-11-04 11:04:40.989356536 +0200
@@ -27,6 +27,7 @@
 #include <nuttx/config.h>
 #include <sys/wait.h>
 #include <stdio.h>
+#include <debug.h>
 #include <sched.h>
 #include <stdlib.h>
 #include <pthread.h>
@@ -51,11 +52,11 @@
 {
   unsigned me = (unsigned)pthread_self();
 
-  printf("pthread_exit_thread %u: Sleeping for 10 second\n", me);
-  sleep(5);
-  printf("pthread_exit_thread %u: Still running...\n", me);
-  sleep(5);
-  printf("pthread_exit_thread %u: Exiting\n", me);
+  _info("pthread_exit_thread %u: Sleeping for 10 second\n", me);
+  usleep(5);
+  _info("pthread_exit_thread %u: Still running...\n", me);
+  usleep(5);
+  _info("pthread_exit_thread %u: Exiting\n", me);
   return NULL;
 }
 
@@ -68,7 +69,7 @@
   unsigned me = (unsigned)pthread_self();
   int ret;
 
-  printf("pthread_exit_main %u: Starting pthread_exit_thread\n", me);
+  _info("pthread_exit_main %u: Starting pthread_exit_thread\n", me);
 #ifdef SDCC
   pthread_attr_init(&attr);
   ret = pthread_create(&child, &attr, pthread_exit_thread, NULL);
@@ -77,17 +78,17 @@
 #endif
   if (ret != 0)
     {
-      printf("Thread creation failed, return code %d", ret);
+      _info("Thread creation failed, return code %d", ret);
     }
 
-  printf("pthread_exit_main %u: Sleeping for 5 seconds\n", me);
+  _info("pthread_exit_main %u: Sleeping for 5 seconds\n", me);
   fflush(stdout);
-  sleep(5);
+  usleep(5);
 
-  printf("pthread_exit_main %u: Calling pthread_exit()\n", me);
+  _info("pthread_exit_main %u: Calling pthread_exit()\n", me);
   pthread_exit(NULL);
 
-  printf("pthread_exit_main %u: ERROR:  Still running\n", me);
+  _info("pthread_exit_main %u: ERROR:  Still running\n", me);
   exit(0);
 
   return NULL;
@@ -111,15 +112,15 @@
   ret = pthread_create(&pid, &attr, pthread_exit_main, NULL);
   if (ret < 0)
     {
-      printf("pthread_exit_test:  ERROR pthread_create Failed\n");
+      _info("pthread_exit_test:  ERROR pthread_create Failed\n");
     }
   else
     {
-      printf("pthread_exit_test: Started pthread_exit_main at PID=%d\n",
+      _info("pthread_exit_test: Started pthread_exit_main at PID=%d\n",
              pid);
       if (pthread_join(pid, NULL) != 0)
         {
-          printf("pthread_exit_test: ERROR Failed to join to terminate\n");
+          _info("pthread_exit_test: ERROR Failed to join to terminate\n");
           ASSERT(false);
         };
     }
diff -Naur apps-12.8.0/testing/ostest/pthread_rwlock.c apps/testing/ostest/pthread_rwlock.c
--- apps-12.8.0/testing/ostest/pthread_rwlock.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/pthread_rwlock.c	2025-11-04 11:04:41.014341799 +0200
@@ -28,6 +28,7 @@
 #include <errno.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 
 /****************************************************************************
  * Private Types
@@ -60,14 +61,14 @@
 
   if (g_race_cond_thread_pos++ != 0)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 0, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 0, got %d",
               g_race_cond_thread_pos);
     }
 
   status = pthread_rwlock_wrlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR Failed to lock for writing\n");
+      _info("pthread_rwlock: ERROR Failed to lock for writing\n");
       ASSERT(false);
     }
 
@@ -78,14 +79,14 @@
 
   if (g_race_cond_thread_pos++ != 2)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 2, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 2, got %d",
               g_race_cond_thread_pos);
     }
 
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to unlock lock held for writing\n");
       ASSERT(false);
     }
@@ -94,7 +95,7 @@
   status = pthread_rwlock_rdlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to open rwlock for reading. Status: %d\n",
              status);
       ASSERT(false);
@@ -106,14 +107,14 @@
 
   if (g_race_cond_thread_pos++ != 4)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 4, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 4, got %d",
               g_race_cond_thread_pos);
     }
 
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to unlock lock held for writing\n");
       ASSERT(false);
     }
@@ -121,7 +122,7 @@
   status = pthread_rwlock_rdlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to open rwlock for reading. Status: %d\n",
              status);
       ASSERT(false);
@@ -134,14 +135,14 @@
 
   if (g_race_cond_thread_pos++ != 6)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 6, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 6, got %d",
               g_race_cond_thread_pos);
     }
 
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to unlock lock held for reading. Status: %d\n",
              status);
       ASSERT(false);
@@ -161,14 +162,14 @@
 
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to wait on semaphore. Status: %d\n", status);
       ASSERT(false);
     }
 
   if (g_race_cond_thread_pos++ != 1)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "Thread order unexpected. Expected 1, got %d",
               g_race_cond_thread_pos);
     }
@@ -176,14 +177,14 @@
   status = pthread_rwlock_tryrdlock(rc->rw_lock);
   if (status != EBUSY)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "Opened rw_lock for rd when locked for writing: %d\n", status);
     }
 
   status = pthread_rwlock_trywrlock(rc->rw_lock);
   if (status != EBUSY)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "Opened rw_lock for wr when locked for writing: %d\n", status);
     }
 
@@ -194,7 +195,7 @@
 
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to open rwlock for reading. Status: %d\n",
              status);
       ASSERT(false);
@@ -203,14 +204,14 @@
   sem_post(rc->sem1);
   if (g_race_cond_thread_pos++ != 3)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 3, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 3, got %d",
              g_race_cond_thread_pos);
     }
 
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to unlock lock held for writing\n");
       ASSERT(false);
     }
@@ -222,7 +223,7 @@
 
   if (g_race_cond_thread_pos++ != 5)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 5, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 5, got %d",
               g_race_cond_thread_pos);
     }
 
@@ -233,7 +234,7 @@
 
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to open rwlock for reading. Status: %d\n",
              status);
       ASSERT(false);
@@ -241,14 +242,14 @@
 
   if (g_race_cond_thread_pos++ != 7)
     {
-      printf("pthread_rwlock: Thread order unexpected. Expected 7, got %d",
+      _info("pthread_rwlock: Thread order unexpected. Expected 7, got %d",
               g_race_cond_thread_pos);
     }
 
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to unlock lock held for writing. Status: %d\n",
              status);
       ASSERT(false);
@@ -270,7 +271,7 @@
   status = pthread_rwlock_init(&rw_lock, NULL);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR pthread_rwlock_init failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -278,14 +279,14 @@
   status = sem_init(&sem1, 0, 0);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
+      _info("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
       ASSERT(false);
     }
 
   status = sem_init(&sem2, 0, 0);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
+      _info("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
       ASSERT(false);
     }
 
@@ -308,7 +309,7 @@
   status = pthread_rwlock_wrlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR Failed to acquire rw_lock. Status: %d\n",
+      _info("pthread_rwlock: ERROR Failed to acquire rw_lock. Status: %d\n",
               status);
       ASSERT(false);
     }
@@ -319,7 +320,7 @@
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR Failed to unlock rw_lock. Status: %d\n",
+      _info("pthread_rwlock: ERROR Failed to unlock rw_lock. Status: %d\n",
               status);
       ASSERT(false);
     }
@@ -336,41 +337,41 @@
   pthread_yield();
 
   status = clock_gettime(CLOCK_REALTIME, &time);
-  time.tv_sec += 2;
+  time.tv_nsec += 2;
 
   status = pthread_rwlock_timedwrlock(rc->rw_lock, &time);
   if (status != ETIMEDOUT)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR Failed to properly timeout write lock\n");
       ASSERT(false);
     }
 
   status = clock_gettime(CLOCK_REALTIME, &time);
-  time.tv_sec += 2;
+  time.tv_nsec += 2;
 
   status = pthread_rwlock_timedrdlock(rc->rw_lock, &time);
   if (status != ETIMEDOUT)
     {
-      printf("pthread_rwlock: ERROR Failed to properly timeout rd lock\n");
+      _info("pthread_rwlock: ERROR Failed to properly timeout rd lock\n");
       ASSERT(false);
     }
 
   status = clock_gettime(CLOCK_REALTIME, &time);
-  time.tv_sec += 2;
+  time.tv_nsec += 2;
 
   sem_post(rc->sem1);
   status = pthread_rwlock_timedrdlock(rc->rw_lock, &time);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR Failed to properly acquire rdlock\n");
+      _info("pthread_rwlock: ERROR Failed to properly acquire rdlock\n");
       ASSERT(false);
     }
 
   status = pthread_rwlock_unlock(rc->rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR Failed to release rdlock\n");
+      _info("pthread_rwlock: ERROR Failed to release rdlock\n");
       ASSERT(false);
     }
 
@@ -390,7 +391,7 @@
   status = pthread_rwlock_init(&rw_lock, NULL);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR pthread_rwlock_init failed, status=%d\n",
+      _info("pthread_rwlock: ERROR pthread_rwlock_init failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -398,14 +399,14 @@
   status = sem_init(&sem1, 0, 0);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
+      _info("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
       ASSERT(false);
     }
 
   status = sem_init(&sem2, 0, 0);
   if (status != 0)
     {
-      printf("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
+      _info("pthread_rwlock: ERROR sem_init failed, status=%d\n", status);
       ASSERT(false);
     }
 
@@ -432,14 +433,14 @@
   pthread_rwlock_t rw_lock;
   int status;
 
-  printf("pthread_rwlock: Initializing rwlock\n");
+  _info("pthread_rwlock: Initializing rwlock\n");
 
   sem_init(&g_sem_thread_started, 0, 0);
 
   status = pthread_rwlock_init(&rw_lock, NULL);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR pthread_rwlock_init failed, status=%d\n",
              status);
       ASSERT(false);
@@ -448,7 +449,7 @@
   status = pthread_rwlock_trywrlock(&rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR pthread_rwlock_trywrlock failed, status=%d\n",
              status);
       ASSERT(false);
@@ -457,7 +458,7 @@
   status = pthread_rwlock_unlock(&rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR pthread_rwlock_unlock failed, status=%d\n",
              status);
       ASSERT(false);
@@ -466,7 +467,7 @@
   status = pthread_rwlock_trywrlock(&rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR pthread_rwlock_trywrlock failed, status=%d\n",
              status);
       ASSERT(false);
@@ -475,7 +476,7 @@
   status = pthread_rwlock_trywrlock(&rw_lock);
   if (status != EBUSY)
     {
-      printf("pthread_rwlock: ERROR "
+      _info("pthread_rwlock: ERROR "
             "able to acquire write lock when write lock already acquired\n");
       ASSERT(false);
     }
@@ -483,7 +484,7 @@
   status = pthread_rwlock_tryrdlock(&rw_lock);
   if (status != EBUSY)
     {
-      printf("pthread_rwlock: ERROR "
+      _info("pthread_rwlock: ERROR "
              "able to acquire read lock when write lock already acquired\n");
       ASSERT(false);
     }
@@ -491,7 +492,7 @@
   status = pthread_rwlock_unlock(&rw_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock: "
+      _info("pthread_rwlock: "
              "ERROR pthread_rwlock_unlock failed, status=%d\n",
              status);
       ASSERT(false);
diff -Naur apps-12.8.0/testing/ostest/pthread_rwlock_cancel.c apps/testing/ostest/pthread_rwlock_cancel.c
--- apps-12.8.0/testing/ostest/pthread_rwlock_cancel.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/pthread_rwlock_cancel.c	2025-11-04 11:04:41.003348192 +0200
@@ -29,6 +29,7 @@
 #include <pthread.h>
 #include <sched.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 /****************************************************************************
@@ -54,12 +55,12 @@
   while (1)
     {
       clock_gettime(CLOCK_REALTIME, &time);
-      time.tv_sec += 1;
+      time.tv_nsec += 1;
 
       status = pthread_rwlock_timedrdlock(sync->write_lock, &time);
       if (status != ETIMEDOUT)
         {
-          printf("pthread_rwlock_cancel: "
+          _info("pthread_rwlock_cancel: "
                  "ERROR Acquired held write_lock. Status: %d\n", status);
           ASSERT(false);
         }
@@ -77,12 +78,12 @@
   while (1)
     {
       clock_gettime(CLOCK_REALTIME, &time);
-      time.tv_sec += 1;
+      time.tv_nsec += 1;
 
       status = pthread_rwlock_timedrdlock(sync->read_lock, &time);
       if (status != 0)
         {
-          printf("pthread_rwlock_cancel: "
+          _info("pthread_rwlock_cancel: "
                  "ERROR Failed to acquire read_lock. Status: %d\n", status);
           ASSERT(false);
         }
@@ -94,7 +95,7 @@
           status = pthread_rwlock_unlock(sync->read_lock);
           if (status != 0)
             {
-              printf("pthread_rwlock_cancel: "
+              _info("pthread_rwlock_cancel: "
                      "ERROR Failed to release read_lock. Status: %d\n",
                      status);
               ASSERT(false);
@@ -102,12 +103,12 @@
         }
 
       clock_gettime(CLOCK_REALTIME, &time);
-      time.tv_sec += 1;
+      time.tv_nsec += 1;
 
       status = pthread_rwlock_timedwrlock(sync->read_lock, &time);
       if (status != ETIMEDOUT)
         {
-          printf("pthread_rwlock_cancel: "
+          _info("pthread_rwlock_cancel: "
                  "ERROR Acquired held read_lock for writing."
                  " Status: %d\n", status);
           ASSERT(false);
@@ -130,7 +131,7 @@
   status = pthread_rwlock_init(&read_lock, NULL);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_init(read_lock), status=%d\n", status);
       ASSERT(false);
     }
@@ -138,7 +139,7 @@
   status = pthread_rwlock_init(&write_lock, NULL);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_init(write_lock), status=%d\n", status);
       ASSERT(false);
     }
@@ -146,7 +147,7 @@
   status = pthread_rwlock_rdlock(&read_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_rdlock, status=%d\n", status);
       ASSERT(false);
     }
@@ -154,7 +155,7 @@
   status = pthread_rwlock_wrlock(&write_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_wrlock, status=%d\n", status);
       ASSERT(false);
     }
@@ -165,7 +166,7 @@
   status = pthread_create(&thread1, NULL, timeout_thread1, &sync);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_create, status=%d\n", status);
       ASSERT(false);
     }
@@ -173,7 +174,7 @@
   status = pthread_create(&thread2, NULL, timeout_thread2, &sync);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_create, status=%d\n", status);
       ASSERT(false);
     }
@@ -186,7 +187,7 @@
   status = pthread_cancel(thread1);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_cancel, status=%d\n", status);
       ASSERT(false);
     }
@@ -194,7 +195,7 @@
   status = pthread_cancel(thread2);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_cancel, status=%d\n", status);
       ASSERT(false);
     }
@@ -210,7 +211,7 @@
   status = pthread_rwlock_trywrlock(&write_lock);
   if (status != EBUSY)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR able to acquire write lock when write lock already "
              "acquired, status=%d\n", status);
       ASSERT(false);
@@ -219,7 +220,7 @@
   status = pthread_rwlock_tryrdlock(&write_lock);
   if (status != EBUSY)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR able to acquire read lock when write lock already "
              "acquired, status=%d\n", status);
       ASSERT(false);
@@ -228,7 +229,7 @@
   status = pthread_rwlock_unlock(&read_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_unlock, status=%d\n", status);
       ASSERT(false);
     }
@@ -236,7 +237,7 @@
   status = pthread_rwlock_unlock(&write_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_unlock, status=%d\n", status);
       ASSERT(false);
     }
@@ -244,7 +245,7 @@
   status = pthread_rwlock_rdlock(&read_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_rdlock, status=%d\n", status);
       ASSERT(false);
     }
@@ -252,7 +253,7 @@
   status = pthread_rwlock_wrlock(&write_lock);
   if (status != 0)
     {
-      printf("pthread_rwlock_cancel: "
+      _info("pthread_rwlock_cancel: "
              "ERROR pthread_rwlock_wrlock, status=%d\n", status);
       ASSERT(false);
     }
@@ -268,6 +269,6 @@
 
 void pthread_rwlock_cancel_test(void)
 {
-  printf("pthread_rwlock_cancel: Starting test\n");
+  _info("pthread_rwlock_cancel: Starting test\n");
   test_timeout();
 }
diff -Naur apps-12.8.0/testing/ostest/restart.c apps/testing/ostest/restart.c
--- apps-12.8.0/testing/ostest/restart.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/restart.c	2025-11-04 11:04:41.015341218 +0200
@@ -33,6 +33,7 @@
 #include <stdbool.h>
 #include <stdlib.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -79,23 +80,23 @@
 #endif
   int i;
 
-  printf("restart_main: Started with argc=%d\n", argc);
+  _info("restart_main: Started with argc=%d\n", argc);
 
   /* Verify passed arguments */
 
   if (argc != NARGS + 1)
     {
-      printf("restart_main: ERROR: Expected argc=%d got argc=%d\n",
+      _info("restart_main: ERROR: Expected argc=%d got argc=%d\n",
              NARGS + 1, argc);
       ASSERT(false);
     }
 
   for (i = 0; i <= NARGS; i++)
     {
-      printf("restart_main: argv[%d]=\"%s\"\n", i, argv[i]);
+      _info("restart_main: argv[%d]=\"%s\"\n", i, argv[i]);
       if (i > 0 && strcmp(argv[i], g_argv[i - 1]) != 0)
         {
-          printf("restart_main: ERROR: "
+          _info("restart_main: ERROR: "
                  "Expected argv[%d]=\"%s\" got \"%s\"\n",
                  i, argv[i], g_argv[i - 1]);
           ASSERT(false);
@@ -108,21 +109,21 @@
     {
       if (strcmp(actual, g_varvalue) == 0)
         {
-          printf("restart_main: Variable=%s has value=%s\n", g_varname,
+          _info("restart_main: Variable=%s has value=%s\n", g_varname,
                  g_varvalue);
         }
       else
         {
-          printf("restart_main: ERROR Variable=%s has the wrong value\n",
+          _info("restart_main: ERROR Variable=%s has the wrong value\n",
                  g_varname);
-          printf("restart_main:       found=%s expected=%s\n",
+          _info("restart_main:       found=%s expected=%s\n",
                  actual, g_varvalue);
           ASSERT(false);
         }
     }
   else
     {
-      printf("restart_main: ERROR: Variable=%s has no value\n", g_varname);
+      _info("restart_main: ERROR: Variable=%s has no value\n", g_varname);
       ASSERT(false);
     }
 #endif
@@ -134,14 +135,14 @@
       case 0:
         for (; ; )
           {
-            sleep(2);
-            printf("restart_main: I am still here\n");
+            usleep(2);
+            _info("restart_main: I am still here\n");
           }
         break;
       case 1:
         if (sem_wait(&g_sem) != 0)
           {
-            printf("restart_main: ERROR thread sem_wait failed\n");
+            _info("restart_main: ERROR thread sem_wait failed\n");
             ASSERT(false);
           }
         break;
@@ -164,12 +165,12 @@
 
   /* Start the children and wait for first one to complete */
 
-  printf("\nTest task_restart()\n");
+  _info("\nTest task_restart()\n");
 
   /* Set up an environment variables */
 
 #ifndef CONFIG_DISABLE_ENVIRON
-  printf("restart_main: setenv(%s, %s, TRUE)\n", g_varname, g_varvalue);
+  _info("restart_main: setenv(%s, %s, TRUE)\n", g_varname, g_varvalue);
   setenv(g_varname, g_varvalue, TRUE);  /* Variable1=GoodValue1 */
 #endif
 
@@ -183,51 +184,51 @@
   ret = task_create("ostest", PRIORITY, STACKSIZE, restart_main, g_argv);
   if (ret < 0)
     {
-      printf("restart_main: ERROR Failed to start restart_main\n");
+      _info("restart_main: ERROR Failed to start restart_main\n");
       ASSERT(false);
     }
   else
     {
       pid_t pid = ret;
 
-      printf("restart_main: Started restart_main at PID=%d\n", pid);
+      _info("restart_main: Started restart_main at PID=%d\n", pid);
 
       /* Wait a bit and restart the task */
 
-      sleep(5);
+      usleep(5);
 
       g_restartstep = 1;
 
       ret = task_restart(pid);
       if (ret < 0)
         {
-          printf("restart_main:  ERROR: task_restart failed\n");
+          _info("restart_main:  ERROR: task_restart failed\n");
           ASSERT(false);
         }
 
       /* Start the task wait for a semaphore */
 
-      printf("restart_main: Started restart_main at PID=%d\n", pid);
+      _info("restart_main: Started restart_main at PID=%d\n", pid);
 
       /* Wait a bit and restart the task */
 
-      sleep(5);
+      usleep(5);
 
       g_restartstep = 2;
 
       ret = task_restart(pid);
       if (ret < 0)
         {
-          printf("restart_main:  ERROR: task_restart failed\n");
+          _info("restart_main:  ERROR: task_restart failed\n");
           ASSERT(false);
         }
 
-      sleep(1);
+      usleep(1);
     }
 
   sem_destroy(&g_sem);
 
-  printf("restart_main: Exiting\n");
+  _info("restart_main: Exiting\n");
 }
 
 #endif /* !CONFIG_BUILD_KERNEL */
diff -Naur apps-12.8.0/testing/ostest/rmutex.c apps/testing/ostest/rmutex.c
--- apps-12.8.0/testing/ostest/rmutex.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/rmutex.c	2025-11-04 11:04:41.029333081 +0200
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 
 #include "ostest.h"
 
@@ -51,24 +52,24 @@
     {
       /* Take the mutex */
 
-      printf("thread_inner[%d, %d]: Locking\n", id, level);
+      _info("thread_inner[%d, %d]: Locking\n", id, level);
       status = pthread_mutex_lock(&mut);
       if (status != 0)
         {
-          printf("thread_inner[%d, %d]: "
+          _info("thread_inner[%d, %d]: "
                  "ERROR pthread_mutex_lock failed: %d\n",
                   id, level, status);
           ASSERT(false);
         }
 
-      printf("thread_inner[%d, %d]: Locked\n", id, level);
+      _info("thread_inner[%d, %d]: Locked\n", id, level);
 
       /* Try-lock already locked recursive mutex. */
 
       status = pthread_mutex_trylock(&mut);
       if (status != 0)
         {
-          printf("thread_inner[%d, %d]: "
+          _info("thread_inner[%d, %d]: "
                  "ERROR pthread_mutex_trylock failed: %d\n",
                   id, level, status);
           ASSERT(false);
@@ -80,7 +81,7 @@
           status = pthread_mutex_unlock(&mut);
           if (status != 0)
             {
-              printf("thread_inner[%d, %d]: ERROR "
+              _info("thread_inner[%d, %d]: ERROR "
                      "pthread_mutex_unlock after try-lock failed: %d\n",
                       id, level, status);
               ASSERT(false);
@@ -95,17 +96,17 @@
 
       /* Unlock the mutex */
 
-      printf("thread_inner[%d, %d]: Unlocking\n", id, level);
+      _info("thread_inner[%d, %d]: Unlocking\n", id, level);
       status = pthread_mutex_unlock(&mut);
       if (status != 0)
         {
-          printf("thread_inner[%d, %d]: "
+          _info("thread_inner[%d, %d]: "
                  "ERROR pthread_mutex_unlock failed: %d\n",
                  id, level, status);
           ASSERT(false);
         }
 
-      printf("thread_inner[%d, %d]: Unlocked\n", id, level);
+      _info("thread_inner[%d, %d]: Unlocked\n", id, level);
       pthread_yield();
     }
 }
@@ -114,14 +115,14 @@
 {
   int i;
 
-  printf("thread_outer[%d]: Started\n", (int)((intptr_t)parameter));
+  _info("thread_outer[%d]: Started\n", (int)((intptr_t)parameter));
   for (i = 0; i < NLOOPS; i++)
     {
-      printf("thread_outer[%d]: Loop %d\n", (int)((intptr_t)parameter), i);
+      _info("thread_outer[%d]: Loop %d\n", (int)((intptr_t)parameter), i);
       thread_inner((int)((intptr_t)parameter), 0);
     }
 
-  printf("thread_outer[%d]: Exiting\n", (int)((intptr_t)parameter));
+  _info("thread_outer[%d]: Exiting\n", (int)((intptr_t)parameter));
   pthread_exit(NULL);
   return NULL; /* Non-reachable -- needed for some compilers */
 }
@@ -144,7 +145,7 @@
   status = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
   if (status != 0)
     {
-      printf("recursive_mutex_test: "
+      _info("recursive_mutex_test: "
              "ERROR pthread_mutexattr_settype failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -152,25 +153,25 @@
   status = pthread_mutexattr_gettype(&mattr, &type);
   if (status != 0)
     {
-      printf("recursive_mutex_test: "
+      _info("recursive_mutex_test: "
              "ERROR pthread_mutexattr_gettype failed, status=%d\n", status);
       ASSERT(false);
     }
 
   if (type != PTHREAD_MUTEX_RECURSIVE)
     {
-      printf("recursive_mutex_test: "
+      _info("recursive_mutex_test: "
              "ERROR pthread_mutexattr_gettype return type=%d\n", type);
       ASSERT(false);
     }
 
   /* Initialize the mutex */
 
-  printf("recursive_mutex_test: Initializing mutex\n");
+  _info("recursive_mutex_test: Initializing mutex\n");
   status = pthread_mutex_init(&mut, &mattr);
   if (status != 0)
     {
-      printf("recursive_mutex_test: "
+      _info("recursive_mutex_test: "
              "ERROR pthread_mutex_init failed, status=%d\n", status);
       ASSERT(false);
     }
@@ -179,7 +180,7 @@
 
   for (i = 0; i < NTHREADS; i++)
     {
-      printf("recursive_mutex_test: Starting thread %d\n", i + 1);
+      _info("recursive_mutex_test: Starting thread %d\n", i + 1);
 #ifdef SDCC
       pthread_attr_init(&attr);
       status = pthread_create(&thread[i], &attr, thread_outer,
@@ -190,7 +191,7 @@
 #endif
       if (status != 0)
         {
-          printf("recursive_mutex_test: ERROR thread#%d creation: %d\n",
+          _info("recursive_mutex_test: ERROR thread#%d creation: %d\n",
                  i + 1, status);
           ASSERT(false);
         }
@@ -200,7 +201,7 @@
 
   for (i = 0; i < NTHREADS; i++)
     {
-      printf("recursive_mutex_test: Waiting for thread %d\n", i + 1);
+      _info("recursive_mutex_test: Waiting for thread %d\n", i + 1);
 #ifdef SDCC
       pthread_join(thread[i], &result[i]);
 #else
@@ -208,6 +209,6 @@
 #endif
     }
 
-  printf("recursive_mutex_test: Complete\n");
+  _info("recursive_mutex_test: Complete\n");
   pthread_mutex_destroy(&mut);
 }
diff -Naur apps-12.8.0/testing/ostest/robust.c apps/testing/ostest/robust.c
--- apps-12.8.0/testing/ostest/robust.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/robust.c	2025-11-04 11:04:40.989356536 +0200
@@ -30,6 +30,7 @@
 #include <errno.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 #include <time.h>
 #include <unistd.h>
 
@@ -51,27 +52,27 @@
 
   /* Take the mutex */
 
-  printf("robust_waiter: Taking mutex\n");
+  _info("robust_waiter: Taking mutex\n");
   status = pthread_mutex_lock(&g_robust_mutex);
   if (status != 0)
     {
-       printf("thread_waiter: ERROR: pthread_mutex_lock failed, status=%d\n",
+       _info("thread_waiter: ERROR: pthread_mutex_lock failed, status=%d\n",
                status);
        ASSERT(false);
     }
 
   if (status != 0)
     {
-       printf("robust_waiter: ERROR: pthread_mutex_lock failed, status=%d\n",
+       _info("robust_waiter: ERROR: pthread_mutex_lock failed, status=%d\n",
                status);
        ASSERT(false);
     }
   else
     {
-      printf("robust_waiter: Exiting with mutex\n");
+      _info("robust_waiter: Exiting with mutex\n");
     }
 
-  sleep(2);
+  usleep(2);
   return NULL;
 }
 
@@ -90,12 +91,12 @@
 
   /* Initialize the mutex */
 
-  printf("robust_test: Initializing mutex\n");
+  _info("robust_test: Initializing mutex\n");
 
   status = pthread_mutexattr_init(&mattr);
   if (status != 0)
     {
-      printf("robust_test: ERROR: "
+      _info("robust_test: ERROR: "
              "pthread_mutexattr_init failed, status=%d\n",
              status);
       ASSERT(false);
@@ -105,7 +106,7 @@
   status = pthread_mutexattr_setrobust(&mattr, PTHREAD_MUTEX_ROBUST);
   if (status != 0)
     {
-      printf("robust_test: ERROR: "
+      _info("robust_test: ERROR: "
              "pthread_mutexattr_setrobust failed, status=%d\n",
              status);
       ASSERT(false);
@@ -115,7 +116,7 @@
   status = pthread_mutex_init(&g_robust_mutex, &mattr);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_init failed, status=%d\n",
+      _info("robust_test: ERROR: pthread_mutex_init failed, status=%d\n",
              status);
       ASSERT(false);
       nerrors++;
@@ -123,12 +124,12 @@
 
   /* Set up pthread attributes */
 
-  printf("robust_test: Starting thread\n");
+  _info("robust_test: Starting thread\n");
 
   status = pthread_attr_init(&pattr);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_attr_init failed, status=%d\n",
+      _info("robust_test: ERROR: pthread_attr_init failed, status=%d\n",
              status);
       ASSERT(false);
       nerrors++;
@@ -137,23 +138,23 @@
   status = pthread_attr_setstacksize(&pattr, STACKSIZE);
   if (status != 0)
     {
-      printf("robust_test: ERROR: "
+      _info("robust_test: ERROR: "
              "pthread_attr_setstacksize failed, status=%d\n",
              status);
       ASSERT(false);
       nerrors++;
     }
 
-  /* Start the robust waiter thread.  It will take the mutex, sleep for two
+  /* Start the robust waiter thread.  It will take the mutex, usleep for two
    * seconds, and exit holding the mutex.
    */
 
   status = pthread_create(&waiter, &pattr, robust_waiter, NULL);
   if (status != 0)
     {
-      printf("robust_test: ERROR: "
+      _info("robust_test: ERROR: "
              "pthread_create failed, status=%d\n", status);
-      printf("             ERROR: Terminating test\n");
+      _info("             ERROR: Terminating test\n");
       ASSERT(false);
       nerrors++;
       return;
@@ -161,7 +162,7 @@
 
   /* Wait one second.. the robust waiter should still be waiting */
 
-  sleep(1);
+  usleep(1);
 
   /* Now try to take the mutex held by the robust waiter.  This should wait
    * one second there fail with EOWNERDEAD.
@@ -170,15 +171,15 @@
   status = pthread_mutex_lock(&g_robust_mutex);
   if (status == 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_lock succeeded\n");
+      _info("robust_test: ERROR: pthread_mutex_lock succeeded\n");
       ASSERT(false);
       nerrors++;
     }
   else if (status != EOWNERDEAD)
     {
-      printf("robust_test: ERROR: pthread_mutex_lock failed with %d\n",
+      _info("robust_test: ERROR: pthread_mutex_lock failed with %d\n",
               status);
-      printf("             ERROR: expected %d (EOWNERDEAD)\n", EOWNERDEAD);
+      _info("             ERROR: expected %d (EOWNERDEAD)\n", EOWNERDEAD);
       ASSERT(false);
       nerrors++;
     }
@@ -187,19 +188,19 @@
    * this should return immediately, still failing with EOWNERDEAD
    */
 
-  printf("robust_test: Take the lock again\n");
+  _info("robust_test: Take the lock again\n");
   status = pthread_mutex_lock(&g_robust_mutex);
   if (status == 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_lock succeeded\n");
+      _info("robust_test: ERROR: pthread_mutex_lock succeeded\n");
       ASSERT(false);
       nerrors++;
     }
   else if (status != EOWNERDEAD)
     {
-      printf("robust_test: ERROR: pthread_mutex_lock failed with %d\n",
+      _info("robust_test: ERROR: pthread_mutex_lock failed with %d\n",
               status);
-      printf("             ERROR: expected %d (EOWNERDEAD)\n", EOWNERDEAD);
+      _info("             ERROR: expected %d (EOWNERDEAD)\n", EOWNERDEAD);
       ASSERT(false);
       nerrors++;
     }
@@ -208,27 +209,27 @@
 
   do
     {
-      sleep(1);
+      usleep(1);
     }
   while (kill(waiter, 0) == 0 || errno != ESRCH);
 
   /* Make the mutex consistent and try again.  It should succeed this time. */
 
-  printf("robust_test: Make the mutex consistent again.\n");
+  _info("robust_test: Make the mutex consistent again.\n");
   status = pthread_mutex_consistent(&g_robust_mutex);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_consistent failed: %d\n",
+      _info("robust_test: ERROR: pthread_mutex_consistent failed: %d\n",
               status);
       ASSERT(false);
       nerrors++;
     }
 
-  printf("robust_test: Take the lock again\n");
+  _info("robust_test: Take the lock again\n");
   status = pthread_mutex_lock(&g_robust_mutex);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_lock failed with: %d\n",
+      _info("robust_test: ERROR: pthread_mutex_lock failed with: %d\n",
               status);
       ASSERT(false);
       nerrors++;
@@ -238,20 +239,20 @@
    * will have a memory leak!)
    */
 
-  printf("robust_test: Joining\n");
+  _info("robust_test: Joining\n");
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_join failed, status=%d\n", status);
+      _info("robust_test: ERROR: pthread_join failed, status=%d\n", status);
       ASSERT(false);
       nerrors++;
     }
   else
     {
-      printf("robust_test: waiter exited with result=%p\n", result);
+      _info("robust_test: waiter exited with result=%p\n", result);
       if (result != NULL)
         {
-          printf("robust_test: ERROR: expected result=%p\n",
+          _info("robust_test: ERROR: expected result=%p\n",
                   PTHREAD_CANCELED);
           ASSERT(false);
           nerrors++;
@@ -263,7 +264,7 @@
   status = pthread_mutex_unlock(&g_robust_mutex);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_unlock failed, status=%d\n",
+      _info("robust_test: ERROR: pthread_mutex_unlock failed, status=%d\n",
               status);
       ASSERT(false);
       nerrors++;
@@ -272,11 +273,11 @@
   status = pthread_mutex_destroy(&g_robust_mutex);
   if (status != 0)
     {
-      printf("robust_test: ERROR: pthread_mutex_unlock failed, status=%d\n",
+      _info("robust_test: ERROR: pthread_mutex_unlock failed, status=%d\n",
               status);
       ASSERT(false);
       nerrors++;
     }
 
-  printf("robust_test: Test complete with nerrors=%d\n", nerrors);
+  _info("robust_test: Test complete with nerrors=%d\n", nerrors);
 }
diff -Naur apps-12.8.0/testing/ostest/roundrobin.c apps/testing/ostest/roundrobin.c
--- apps-12.8.0/testing/ostest/roundrobin.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/roundrobin.c	2025-11-04 11:04:41.019338893 +0200
@@ -31,6 +31,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdbool.h>
 
 #include "ostest.h"
@@ -104,7 +105,7 @@
           local_count++;
           *last = number;
 #if 0 /* We don't really care what the numbers are */
-          printf(" Prime %d: %d\n", local_count, number);
+          _info(" Prime %d: %d\n", local_count, number);
 #endif
         }
     }
@@ -125,7 +126,7 @@
 
   while (sem_wait(&g_rrsem) < 0);
 
-  printf("get_primes_thread id=%d started, "
+  _info("get_primes_thread id=%d started, "
          "looking for primes < %d, doing %d run(s)\n",
          id, CONFIG_TESTING_OSTEST_RR_RANGE, CONFIG_TESTING_OSTEST_RR_RUNS);
 
@@ -134,7 +135,7 @@
       get_primes(&count, &last);
     }
 
-  printf("get_primes_thread id=%d finished, found %d primes, "
+  _info("get_primes_thread id=%d finished, found %d primes, "
          "last one was %d\n", id, count, last);
 
   pthread_exit(NULL);
@@ -163,7 +164,7 @@
   status = pthread_attr_init(&attr);
   if (status != OK)
     {
-      printf("rr_test: ERROR: pthread_attr_init failed, status=%d\n",
+      _info("rr_test: ERROR: pthread_attr_init failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -172,26 +173,26 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("rr_test: ERROR: pthread_attr_setschedparam failed,"
+      _info("rr_test: ERROR: pthread_attr_setschedparam failed,"
              " status=%d\n", status);
       ASSERT(false);
     }
   else
     {
-      printf("rr_test: Set thread priority to %d\n",
+      _info("rr_test: Set thread priority to %d\n",
              sparam.sched_priority);
     }
 
   status = pthread_attr_setschedpolicy(&attr, SCHED_RR);
   if (status != OK)
     {
-      printf("rr_test: ERROR: pthread_attr_setschedpolicy failed,"
+      _info("rr_test: ERROR: pthread_attr_setschedpolicy failed,"
              " status=%d\n", status);
       ASSERT(false);
     }
   else
     {
-      printf("rr_test: Set thread policy to SCHED_RR\n");
+      _info("rr_test: Set thread policy to SCHED_RR\n");
     }
 
   /* This semaphore will prevent anything from running until we are ready */
@@ -201,33 +202,33 @@
 
   /* Start the threads */
 
-  printf("rr_test: Starting first get_primes_thread\n");
+  _info("rr_test: Starting first get_primes_thread\n");
 
   status = pthread_create(&get_primes1_thread,
                           &attr, get_primes_thread, (FAR void *)1);
   if (status != 0)
     {
-      printf("         ERROR: Thread 1 creation failed: %d\n",  status);
+      _info("         ERROR: Thread 1 creation failed: %d\n",  status);
       ASSERT(false);
     }
 
-  printf("         First get_primes_thread: %d\n", (int)get_primes1_thread);
-  printf("rr_test: Starting second get_primes_thread\n");
+  _info("         First get_primes_thread: %d\n", (int)get_primes1_thread);
+  _info("rr_test: Starting second get_primes_thread\n");
 
   status = pthread_create(&get_primes2_thread,
                           &attr, get_primes_thread, (FAR void *)2);
   if (status != 0)
     {
-      printf("         ERROR: Thread 2 creation failed: %d\n", status);
+      _info("         ERROR: Thread 2 creation failed: %d\n", status);
       ASSERT(false);
     }
 
-  printf("         Second get_primes_thread: %d\n", (int)get_primes2_thread);
-  printf("rr_test: "
+  _info("         Second get_primes_thread: %d\n", (int)get_primes2_thread);
+  _info("rr_test: "
          "Waiting for threads to complete -- this should take awhile\n");
-  printf("         "
+  _info("         "
          "If RR scheduling is working, they should start and complete at\n");
-  printf("         about the same time\n");
+  _info("         about the same time\n");
 
   sem_post(&g_rrsem);
   sem_post(&g_rrsem);
@@ -235,7 +236,7 @@
 
   pthread_join(get_primes2_thread, &result);
   pthread_join(get_primes1_thread, &result);
-  printf("rr_test: Done\n");
+  _info("rr_test: Done\n");
   sem_destroy(&g_rrsem);
 }
 
diff -Naur apps-12.8.0/testing/ostest/schedlock.c apps/testing/ostest/schedlock.c
--- apps-12.8.0/testing/ostest/schedlock.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/schedlock.c	2025-11-04 11:04:41.014341799 +0200
@@ -40,6 +40,7 @@
  ****************************************************************************/
 
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 #include <pthread.h>
 #include <errno.h>
@@ -163,7 +164,7 @@
       status = sched_getparam(0, &sparam);
       if (status != 0)
         {
-          printf("sched_lock: ERROR sched_getparam failed\n");
+          _info("sched_lock: ERROR sched_getparam failed\n");
           ASSERT(false);
           sparam.sched_priority = PTHREAD_DEFAULT_PRIORITY;
         }
@@ -173,11 +174,11 @@
 
       /* Start the low priority thread */
 
-      printf("sched_lock: Starting lowpri_thread at %d\n", lowprio);
+      _info("sched_lock: Starting lowpri_thread at %d\n", lowprio);
       status = pthread_attr_init(&attr);
       if (status != 0)
         {
-          printf("sched_lock: ERROR pthread_attr_init failed, status=%d\n",
+          _info("sched_lock: ERROR pthread_attr_init failed, status=%d\n",
                  status);
           ASSERT(false);
         }
@@ -186,14 +187,14 @@
       status = pthread_attr_setschedparam(&attr, &sparam);
       if (status != OK)
         {
-          printf("sched_lock: "
+          _info("sched_lock: "
                  "ERROR pthread_attr_setschedparam failed, status=%d\n",
                   status);
           ASSERT(false);
         }
       else
         {
-          printf("sched_lock: Set lowpri_thread priority to %d\n",
+          _info("sched_lock: Set lowpri_thread priority to %d\n",
                  sparam.sched_priority);
         }
 
@@ -206,18 +207,18 @@
       status = pthread_create(&g_lowpri, &attr, lowpri_thread, NULL);
       if (status != 0)
         {
-          printf("sched_lock: ERROR pthread_create failed, status=%d\n",
+          _info("sched_lock: ERROR pthread_create failed, status=%d\n",
                  status);
           ASSERT(false);
         }
 
       /* Start the high priority thread */
 
-      printf("sched_lock: Starting highpri_thread at %d\n", highprio);
+      _info("sched_lock: Starting highpri_thread at %d\n", highprio);
       status = pthread_attr_init(&attr);
       if (status != 0)
         {
-          printf("sched_lock: ERROR pthread_attr_init failed, status=%d\n",
+          _info("sched_lock: ERROR pthread_attr_init failed, status=%d\n",
                  status);
           ASSERT(false);
         }
@@ -226,14 +227,14 @@
       status = pthread_attr_setschedparam(&attr, &sparam);
       if (status != OK)
         {
-          printf("sched_lock: "
+          _info("sched_lock: "
                  "ERROR pthread_attr_setschedparam failed, status=%d\n",
                   status);
           ASSERT(false);
         }
       else
         {
-          printf("sched_lock: Set highpri_thread priority to %d\n",
+          _info("sched_lock: Set highpri_thread priority to %d\n",
                  sparam.sched_priority);
         }
 
@@ -247,30 +248,30 @@
                               (FAR void *)(uintptr_t)(i == 0));
       if (status != 0)
         {
-          printf("sched_lock: ERROR pthread_create failed, status=%d\n",
+          _info("sched_lock: ERROR pthread_create failed, status=%d\n",
                  status);
           ASSERT(false);
         }
 
-      printf("sched_lock: Waiting...\n");
-      sleep(1);
+      _info("sched_lock: Waiting...\n");
+      usleep(1);
 
       pthread_join(g_highpri, NULL);
       pthread_join(g_lowpri, NULL);
 
       if (!g_pass)
         {
-          printf("sched_lock: ERROR: FAIL pre-emption occurred "
+          _info("sched_lock: ERROR: FAIL pre-emption occurred "
                  "while scheduler was locked.\n");
           ASSERT(false);
         }
       else
         {
-          printf("sched_lock: PASSED No pre-emption occurred "
+          _info("sched_lock: PASSED No pre-emption occurred "
                  "while scheduler was locked.\n");
         }
     }
 
-  printf("sched_lock: Finished\n");
+  _info("sched_lock: Finished\n");
   FFLUSH();
 }
diff -Naur apps-12.8.0/testing/ostest/sched_thread_local.c apps/testing/ostest/sched_thread_local.c
--- apps-12.8.0/testing/ostest/sched_thread_local.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/sched_thread_local.c	2025-11-04 11:04:41.005347030 +0200
@@ -31,6 +31,7 @@
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 
 #include "ostest.h"
@@ -73,23 +74,23 @@
   status = pthread_barrier_wait(&g_barrier);
   if (status != 0 && status != PTHREAD_BARRIER_SERIAL_THREAD)
     {
-      printf("sched_thread_local_test: ERROR thread %d pthread_barrier_wait "
+      _info("sched_thread_local_test: ERROR thread %d pthread_barrier_wait "
              "failed\n", id);
       ASSERT(false);
     }
 
-  printf("thread_func[%d]: Thread Started\n", id);
+  _info("thread_func[%d]: Thread Started\n", id);
 
-  printf("thread_func[%d]: g_tls_short (at 0x%p) initial value = %d\n",
+  _info("thread_func[%d]: g_tls_short (at 0x%p) initial value = %d\n",
          id, &g_tls_short, value_short);
-  printf("thread_func[%d]: g_tls_int (at 0x%p) initial value = %d\n",
+  _info("thread_func[%d]: g_tls_int (at 0x%p) initial value = %d\n",
          id, &g_tls_int, value_int);
-  printf("thread_func[%d]: g_tls_lld (at 0x%p) initial value = %lld\n",
+  _info("thread_func[%d]: g_tls_lld (at 0x%p) initial value = %lld\n",
          id, &g_tls_lld, value_lld);
 
   if (value_short != INIT_VALUE)
     {
-      printf("thread_func[%d]: "
+      _info("thread_func[%d]: "
              "ERROR value_short value for this thread is different than the "
              "expected initial value (%d): %d\n",
              id, INIT_VALUE, value_short);
@@ -98,7 +99,7 @@
 
   if (value_int != INIT_VALUE)
     {
-      printf("thread_func[%d]: "
+      _info("thread_func[%d]: "
              "ERROR value_int value for this thread is different than the "
              "expected initial value (%d): %d\n",
              id, INIT_VALUE, value_int);
@@ -107,32 +108,32 @@
 
   if (value_lld != -INIT_VALUE)
     {
-      printf("thread_func[%d]: "
+      _info("thread_func[%d]: "
              "ERROR value_lld value for this thread is different than the "
              "expected initial value (%d): %lld\n",
              id, -INIT_VALUE, value_lld);
       ASSERT(false);
     }
 
-  printf("thread_func[%d]: setting value_short (at 0x%p) to %d\n",
+  _info("thread_func[%d]: setting value_short (at 0x%p) to %d\n",
          id, &g_tls_short, value_short + id);
 
   g_tls_short = value_short + id;
   g_tls_variables[id][0] = g_tls_short;
 
-  printf("thread_func[%d]: setting value_int (at 0x%p) to %d\n",
+  _info("thread_func[%d]: setting value_int (at 0x%p) to %d\n",
          id, &g_tls_int, value_int + id);
 
   g_tls_int = value_int + id;
   g_tls_variables[id][1] = g_tls_int;
 
-  printf("thread_func[%d]: setting value_lld (at 0x%p) to %lld\n",
+  _info("thread_func[%d]: setting value_lld (at 0x%p) to %lld\n",
          id, &g_tls_lld, value_lld - id);
 
   g_tls_lld = value_lld - id;
   g_tls_variables[id][2] = g_tls_lld;
 
-  printf("thread_func[%d]: Thread done\n", id);
+  _info("thread_func[%d]: Thread done\n", id);
   return NULL;
 }
 
@@ -150,14 +151,14 @@
   int i;
   int status;
 
-  printf("sched_thread_local_test: g_tls_int value is: %d\n", g_tls_int);
+  _info("sched_thread_local_test: g_tls_int value is: %d\n", g_tls_int);
 
   /* Create the g_barrier */
 
   status = pthread_barrier_init(&g_barrier, NULL, TEST_THREADS);
   if (status != OK)
     {
-      printf("sched_thread_local_test: pthread_barrier_init failed, "
+      _info("sched_thread_local_test: pthread_barrier_init failed, "
              "status=%d\n", status);
     }
 
@@ -165,13 +166,13 @@
     {
       /* Start three thread instances */
 
-      printf("sched_thread_local_test: Starting waiter thread %d\n", i);
+      _info("sched_thread_local_test: Starting waiter thread %d\n", i);
 
       status = pthread_create(&thread[i], NULL,
                               thread_func, (pthread_addr_t)(intptr_t)i);
       if (status != 0)
         {
-          printf("sched_thread_local_test: ERROR: "
+          _info("sched_thread_local_test: ERROR: "
                  "Thread %d creation failed: %d\n", i, status);
           ASSERT(false);
         }
@@ -187,34 +188,34 @@
 
   for (i = 0; i < TEST_THREADS; i++)
     {
-      printf("sched_thread_local_test: "
+      _info("sched_thread_local_test: "
              "g_tls_variables[thread_%d][g_tls_short] = %lld\n",
              i, g_tls_variables[i][0]);
       if (g_tls_variables[i][0] != INIT_VALUE + i)
         {
-          printf("sched_thread_local_test: ERROR: "
+          _info("sched_thread_local_test: ERROR: "
                  "g_tls_variables[thread_%d][g_tls_short] = %lld\n",
                  i, g_tls_variables[i][0]);
           ASSERT(false);
         }
 
-      printf("sched_thread_local_test: "
+      _info("sched_thread_local_test: "
              "g_tls_variables[thread_%d][g_tls_int] = %lld\n",
              i, g_tls_variables[i][1]);
       if (g_tls_variables[i][1] != INIT_VALUE + i)
         {
-          printf("sched_thread_local_test: ERROR: "
+          _info("sched_thread_local_test: ERROR: "
                  "g_tls_variables[thread_%d][g_tls_int] = %lld\n",
                  i, g_tls_variables[i][1]);
           ASSERT(false);
         }
 
-      printf("sched_thread_local_test: "
+      _info("sched_thread_local_test: "
              "g_tls_variables[thread_%d][g_tls_lld] = %lld\n",
              i, g_tls_variables[i][2]);
       if (g_tls_variables[i][2] != -INIT_VALUE - i)
         {
-          printf("sched_thread_local_test: ERROR: "
+          _info("sched_thread_local_test: ERROR: "
                  "g_tls_variables[thread_%d][g_tls_lld] = %lld\n",
                  i, g_tls_variables[i][2]);
           ASSERT(false);
@@ -224,7 +225,7 @@
   status = pthread_barrier_destroy(&g_barrier);
   if (status != OK)
     {
-      printf("sched_thread_local_test: pthread_barrier_destroy failed, "
+      _info("sched_thread_local_test: pthread_barrier_destroy failed, "
              "status=%d\n", status);
     }
 }
diff -Naur apps-12.8.0/testing/ostest/sem.c apps/testing/ostest/sem.c
--- apps-12.8.0/testing/ostest/sem.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/sem.c	2025-11-04 11:04:41.015341218 +0200
@@ -29,6 +29,7 @@
 #include <semaphore.h>
 #include <sched.h>
 #include <stdio.h>
+#include <debug.h>
 
 #include "ostest.h"
 
@@ -52,47 +53,47 @@
   int status;
   int value;
 
-  printf("waiter_func: Thread %d Started\n",  id);
+  _info("waiter_func: Thread %d Started\n",  id);
 
   /* Take the semaphore */
 
   status = sem_getvalue(&sem, &value);
   if (status < 0)
     {
-      printf("waiter_func: "
+      _info("waiter_func: "
              "ERROR thread %d could not get semaphore value\n",  id);
       ASSERT(false);
     }
   else
     {
-      printf("waiter_func: "
+      _info("waiter_func: "
              "Thread %d initial semaphore value = %d\n",  id, value);
     }
 
-  printf("waiter_func: Thread %d waiting on semaphore\n",  id);
+  _info("waiter_func: Thread %d waiting on semaphore\n",  id);
   status = sem_wait(&sem);
   if (status != 0)
     {
-      printf("waiter_func: ERROR thread %d sem_wait failed\n",  id);
+      _info("waiter_func: ERROR thread %d sem_wait failed\n",  id);
       ASSERT(false);
     }
 
-  printf("waiter_func: Thread %d awakened\n",  id);
+  _info("waiter_func: Thread %d awakened\n",  id);
 
   status = sem_getvalue(&sem, &value);
   if (status < 0)
     {
-      printf("waiter_func: "
+      _info("waiter_func: "
              "ERROR thread %d could not get semaphore value\n",  id);
       ASSERT(false);
     }
   else
     {
-      printf("waiter_func: "
+      _info("waiter_func: "
              "Thread %d new semaphore value = %d\n",  id, value);
     }
 
-  printf("waiter_func: Thread %d done\n",  id);
+  _info("waiter_func: Thread %d done\n",  id);
   return NULL;
 }
 
@@ -102,7 +103,7 @@
   int status;
   int value;
 
-  printf("poster_func: Thread %d started\n",  id);
+  _info("poster_func: Thread %d started\n",  id);
 
   /* Take the semaphore */
 
@@ -111,23 +112,23 @@
       status = sem_getvalue(&sem, &value);
       if (status < 0)
         {
-          printf("poster_func: "
+          _info("poster_func: "
                  "ERROR thread %d could not get semaphore value\n",  id);
           ASSERT(false);
         }
       else
         {
-          printf("poster_func: "
+          _info("poster_func: "
                  "Thread %d semaphore value = %d\n",  id, value);
         }
 
       if (value < 0)
         {
-          printf("poster_func: Thread %d posting semaphore\n",  id);
+          _info("poster_func: Thread %d posting semaphore\n",  id);
           status = sem_post(&sem);
           if (status != 0)
             {
-              printf("poster_func: ERROR thread %d sem_wait failed\n",  id);
+              _info("poster_func: ERROR thread %d sem_wait failed\n",  id);
               ASSERT(false);
             }
 
@@ -136,20 +137,20 @@
           status = sem_getvalue(&sem, &value);
           if (status < 0)
             {
-              printf("poster_func: "
+              _info("poster_func: "
                      "ERROR thread %d could not get semaphore value\n",  id);
               ASSERT(false);
             }
           else
             {
-              printf("poster_func: "
+              _info("poster_func: "
                      "Thread %d new semaphore value = %d\n",  id, value);
             }
         }
     }
   while (value < 0);
 
-  printf("poster_func: Thread %d done\n",  id);
+  _info("poster_func: Thread %d done\n",  id);
   return NULL;
 }
 
@@ -172,16 +173,16 @@
   pthread_attr_t attr;
   int status;
 
-  printf("sem_test: Initializing semaphore to 0\n");
+  _info("sem_test: Initializing semaphore to 0\n");
   sem_init(&sem, 0, 0);
 
   /* Start two waiter thread instances */
 
-  printf("sem_test: Starting waiter thread 1\n");
+  _info("sem_test: Starting waiter thread 1\n");
   status = pthread_attr_init(&attr);
   if (status != OK)
     {
-      printf("sem_test: pthread_attr_init failed, status=%d\n",  status);
+      _info("sem_test: pthread_attr_init failed, status=%d\n",  status);
     }
 
   prio_min = sched_get_priority_min(SCHED_FIFO);
@@ -192,13 +193,13 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("sem_test: ERROR: "
+      _info("sem_test: ERROR: "
              "pthread_attr_setschedparam failed, status=%d\n",  status);
       ASSERT(false);
     }
   else
     {
-      printf("sem_test: "
+      _info("sem_test: "
              "Set thread 1 priority to %d\n",  sparam.sched_priority);
     }
 
@@ -206,16 +207,16 @@
                           waiter_func, (pthread_addr_t)1);
   if (status != 0)
     {
-      printf("sem_test: ERROR: "
+      _info("sem_test: ERROR: "
              "Thread 1 creation failed: %d\n",  status);
       ASSERT(false);
     }
 
-  printf("sem_test: Starting waiter thread 2\n");
+  _info("sem_test: Starting waiter thread 2\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("sem_test: ERROR: "
+      _info("sem_test: ERROR: "
              "pthread_attr_init failed, status=%d\n",  status);
       ASSERT(false);
     }
@@ -224,13 +225,13 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("sem_test: ERROR: "
+      _info("sem_test: ERROR: "
              "pthread_attr_setschedparam failed, status=%d\n",  status);
       ASSERT(false);
     }
   else
     {
-      printf("sem_test: "
+      _info("sem_test: "
              "Set thread 2 priority to %d\n",  sparam.sched_priority);
     }
 
@@ -238,7 +239,7 @@
                           waiter_func, (pthread_addr_t)2);
   if (status != 0)
     {
-      printf("sem_test: ERROR: Thread 2 creation failed: %d\n",  status);
+      _info("sem_test: ERROR: Thread 2 creation failed: %d\n",  status);
       ASSERT(false);
     }
 
@@ -251,11 +252,11 @@
     }
   while (status != -2);
 
-  printf("sem_test: Starting poster thread 3\n");
+  _info("sem_test: Starting poster thread 3\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("sem_test: ERROR: "
+      _info("sem_test: ERROR: "
              "pthread_attr_init failed, status=%d\n",  status);
       ASSERT(false);
     }
@@ -264,12 +265,12 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("sem_test: "
+      _info("sem_test: "
              "pthread_attr_setschedparam failed, status=%d\n",  status);
     }
   else
     {
-      printf("sem_test: Set thread 3 priority to %d\n",
+      _info("sem_test: Set thread 3 priority to %d\n",
               sparam.sched_priority);
     }
 
@@ -277,8 +278,8 @@
                            poster_func, (pthread_addr_t)3);
   if (status != 0)
     {
-      printf("sem_test: ERROR: Thread 3 creation failed: %d\n",  status);
-      printf("          Canceling waiter threads\n");
+      _info("sem_test: ERROR: Thread 3 creation failed: %d\n",  status);
+      _info("          Canceling waiter threads\n");
       ASSERT(false);
 
       pthread_cancel(waiter_thread1);
diff -Naur apps-12.8.0/testing/ostest/semtimed.c apps/testing/ostest/semtimed.c
--- apps-12.8.0/testing/ostest/semtimed.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/semtimed.c	2025-11-04 11:04:41.029333081 +0200
@@ -30,6 +30,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 #include <time.h>
 #include <unistd.h>
 
@@ -55,14 +56,14 @@
 
   /* Wait for one second, then post the semaphore */
 
-  printf("poster_func: Waiting for 1 second\n");
-  sleep(1);
+  _info("poster_func: Waiting for 1 second\n");
+  usleep(1000);
 
-  printf("poster_func: Posting\n");
+  _info("poster_func: Posting\n");
   status = sem_post(&sem);
   if (status != OK)
     {
-      printf("poster_func: ERROR: sem_post failed\n");
+      _info("poster_func: ERROR: sem_post failed\n");
       ASSERT(false);
     }
 
@@ -76,17 +77,17 @@
   status = clock_gettime(CLOCK_REALTIME, tp);
   if (status != OK)
     {
-      printf("ostest_gettime: ERROR: clock_gettime failed\n");
+      _info("ostest_gettime: ERROR: clock_gettime failed\n");
       ASSERT(false);
     }
 #ifdef CONFIG_SYSTEM_TIME64
-  else if (tp->tv_sec < 0 || tp->tv_nsec < 0 ||
+  else if (tp->tv_nsec < 0 || tp->tv_nsec < 0 ||
 #else
   else if (tp->tv_nsec < 0 ||
 #endif
            tp->tv_nsec >= 1000 * 1000 * 1000)
     {
-      printf("ostest_gettime: ERROR: clock_gettime returned bogus time\n");
+      _info("ostest_gettime: ERROR: clock_gettime returned bogus time\n");
       ASSERT(false);
     }
 }
@@ -112,11 +113,11 @@
   pthread_attr_t attr;
   int status;
 
-  printf("semtimed_test: Initializing semaphore to 0\n");
+  _info("semtimed_test: Initializing semaphore to 0\n");
   status = sem_init(&sem, 0, 0);
   if (status != OK)
     {
-      printf("semtimed_test: ERROR: sem_init failed\n");
+      _info("semtimed_test: ERROR: sem_init failed\n");
       ASSERT(false);
     }
 
@@ -126,10 +127,10 @@
 
   ostest_gettime(&before);
 
-  abstime.tv_sec  = before.tv_sec + 2;
-  abstime.tv_nsec = before.tv_nsec;
+  abstime.tv_sec  = before.tv_sec;
+  abstime.tv_nsec = before.tv_nsec + 1000000;
 
-  printf("semtimed_test: Waiting for two second timeout\n");
+  _info("semtimed_test: Waiting for two second timeout\n");
   status  = sem_timedwait(&sem, &abstime);
   errcode = errno;
 
@@ -137,27 +138,27 @@
 
   if (status == OK)
     {
-      printf("semtimed_test: ERROR: sem_timedwait succeeded\n");
+      _info("semtimed_test: ERROR: sem_timedwait succeeded\n");
       ASSERT(false);
     }
   else
     {
       if (errcode == ETIMEDOUT)
         {
-          printf("semtimed_test: PASS: first test returned timeout\n");
+          _info("semtimed_test: PASS: first test returned timeout\n");
         }
       else
         {
-          printf("semtimed_test: ERROR: sem_timedwait failed with: %d\n",
+          _info("semtimed_test: ERROR: sem_timedwait failed with: %d\n",
                   errcode);
           ASSERT(false);
         }
     }
 
-  printf("BEFORE: (%lu sec, %lu nsec)\n",
-          (unsigned long)before.tv_sec, (unsigned long)before.tv_nsec);
-  printf("AFTER:  (%lu sec, %lu nsec)\n",
-          (unsigned long)after.tv_sec, (unsigned long)after.tv_nsec);
+  _info("BEFORE: (%lu sec, %lu nsec)\n",
+          (unsigned long)before.tv_nsec, (unsigned long)before.tv_nsec);
+  _info("AFTER:  (%lu sec, %lu nsec)\n",
+          (unsigned long)after.tv_nsec, (unsigned long)after.tv_nsec);
 
   /* Now make sure that the time wait returns successfully if the semaphore
    * is posted
@@ -165,11 +166,11 @@
 
   /* Start a poster thread.  It will wait 1 seconds and post the semaphore */
 
-  printf("semtimed_test: Starting poster thread\n");
+  _info("semtimed_test: Starting poster thread\n");
   status = pthread_attr_init(&attr);
   if (status != OK)
     {
-      printf("semtimed_test: ERROR: pthread_attr_init failed, status=%d\n",
+      _info("semtimed_test: ERROR: pthread_attr_init failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -182,21 +183,21 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("semtimed_test: ERROR: "
+      _info("semtimed_test: ERROR: "
              "pthread_attr_setschedparam failed, status=%d\n",  status);
       ASSERT(false);
     }
   else
     {
-      printf("semtimed_test: Set thread 1 priority to %d\n",
+      _info("semtimed_test: Set thread 1 priority to %d\n",
               sparam.sched_priority);
     }
 
-  printf("semtimed_test: Starting poster thread 3\n");
+  _info("semtimed_test: Starting poster thread 3\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("semtimed_test: ERROR: pthread_attr_init failed, status=%d\n",
+      _info("semtimed_test: ERROR: pthread_attr_init failed, status=%d\n",
               status);
       ASSERT(false);
     }
@@ -205,21 +206,21 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("semtimed_test: "
+      _info("semtimed_test: "
              "ERROR pthread_attr_setschedparam failed, status=%d\n",
               status);
       ASSERT(false);
     }
   else
     {
-      printf("semtimed_test: Set thread 3 priority to %d\n",
+      _info("semtimed_test: Set thread 3 priority to %d\n",
               sparam.sched_priority);
     }
 
   status = pthread_create(&poster_thread, &attr, poster_func, NULL);
   if (status != 0)
     {
-      printf("semtimed_test: ERROR: Poster thread creation failed: %d\n",
+      _info("semtimed_test: ERROR: Poster thread creation failed: %d\n",
               status);
       ASSERT(false);
       sem_destroy(&sem);
@@ -230,10 +231,10 @@
 
   ostest_gettime(&before);
 
-  abstime.tv_sec  = before.tv_sec + 2;
-  abstime.tv_nsec = before.tv_nsec;
+  abstime.tv_sec  = before.tv_nsec;
+  abstime.tv_nsec = before.tv_nsec+1000000;
 
-  printf("semtimed_test: Waiting for two second timeout\n");
+  _info("semtimed_test: Waiting for two second timeout\n");
   status  = sem_timedwait(&sem, &abstime);
   errcode = errno;
 
@@ -241,19 +242,19 @@
 
   if (status < 0)
     {
-      printf("semtimed_test: ERROR: sem_timedwait failed with: %d\n",
+      _info("semtimed_test: ERROR: sem_timedwait failed with: %d\n",
               errcode);
       ASSERT(false);
     }
   else
     {
-      printf("semtimed_test: PASS: sem_timedwait succeeded\n");
+      _info("semtimed_test: PASS: sem_timedwait succeeded\n");
     }
 
-  printf("BEFORE: (%lu sec, %lu nsec)\n",
-          (unsigned long)before.tv_sec, (unsigned long)before.tv_nsec);
-  printf("AFTER:  (%lu sec, %lu nsec)\n",
-          (unsigned long)after.tv_sec, (unsigned long)after.tv_nsec);
+  _info("BEFORE: (%lu sec, %lu nsec)\n",
+          (unsigned long)before.tv_nsec, (unsigned long)before.tv_nsec);
+  _info("AFTER:  (%lu sec, %lu nsec)\n",
+          (unsigned long)after.tv_nsec, (unsigned long)after.tv_nsec);
 
   /* Clean up detritus left by the pthread */
 
diff -Naur apps-12.8.0/testing/ostest/setjmp.c apps/testing/ostest/setjmp.c
--- apps-12.8.0/testing/ostest/setjmp.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/setjmp.c	2025-11-04 11:04:41.007345868 +0200
@@ -29,6 +29,7 @@
 #include <assert.h>
 #include <setjmp.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdbool.h>
 
 /****************************************************************************
@@ -42,7 +43,7 @@
 
   if ((value = setjmp(buf)) == 0)
     {
-      printf("setjmp_test: Try jump\n");
+      _info("setjmp_test: Try jump\n");
 
       if (did_jump)
         {
@@ -50,7 +51,7 @@
         }
 
       did_jump = true;
-      printf("setjmp_test: About to jump, longjmp with ret val: %d\n", ret);
+      _info("setjmp_test: About to jump, longjmp with ret val: %d\n", ret);
       longjmp(buf, ret);
 
       /* Unreachable */
@@ -69,7 +70,7 @@
         }
 
       ASSERT(value == ret);
-      printf("setjmp_test: Jump succeed\n");
+      _info("setjmp_test: Jump succeed\n");
     }
 }
 
@@ -77,7 +78,7 @@
 {
   jmp_buf buf;
 
-  printf("setjmp_test: Initializing jmp_buf\n");
+  _info("setjmp_test: Initializing jmp_buf\n");
 
   jump_with_retval(buf, 123);
 
diff -Naur apps-12.8.0/testing/ostest/setvbuf.c apps/testing/ostest/setvbuf.c
--- apps-12.8.0/testing/ostest/setvbuf.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/setvbuf.c	2025-11-05 15:59:50.843527531 +0200
@@ -28,6 +28,7 @@
 
 #include <assert.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdbool.h>
 
 #ifndef CONFIG_STDIO_DISABLE_BUFFERING
@@ -39,19 +40,18 @@
 /****************************************************************************
  * setvbuf_test
  ****************************************************************************/
-
 int setvbuf_test(void)
 {
   FILE *stream;
-  char buffer[64];
+  char buffer[64]={0};
   int ret;
 
-  printf("setvbuf_test: Test NO buffering\n");
+  _info("setvbuf_test: Test NO buffering\n");
 
   stream = fopen("/dev/console", "w");
   if (stream == NULL)
     {
-      printf("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
+      _info("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
       ASSERT(false);
       return ERROR;
     }
@@ -59,7 +59,7 @@
   ret = setvbuf(stream, NULL, _IONBF, 0);
   if (ret < 0)
     {
-      printf("setvbuf_test ERROR: "
+      _info("setvbuf_test ERROR: "
              "setvbuf(stream, NULL, _IONBF, 0) failed\n");
       ASSERT(false);
     }
@@ -73,12 +73,12 @@
 
   fclose(stream);
 
-  printf("setvbuf_test: Test default FULL buffering\n");
+  _info("setvbuf_test: Test default FULL buffering\n");
 
   stream = fopen("/dev/console", "w");
   if (stream == NULL)
     {
-      printf("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
+      _info("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
       ASSERT(false);
       return ERROR;
     }
@@ -86,7 +86,7 @@
   ret = setvbuf(stream, NULL, _IOFBF, 0);
   if (ret < 0)
     {
-      printf("ssetvbuf_test ERROR: "
+      _info("ssetvbuf_test ERROR: "
              "setvbuf(stream, NULL, _IOFBF, 0) failed\n");
       ASSERT(false);
     }
@@ -100,12 +100,12 @@
 
   fclose(stream);
 
-  printf("setvbuf_test: Test FULL buffering, buffer size 64\n");
+  _info("setvbuf_test: Test FULL buffering, buffer size 64\n");
 
   stream = fopen("/dev/console", "w");
   if (stream == NULL)
     {
-      printf("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
+      _info("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
       ASSERT(false);
       return ERROR;
     }
@@ -113,7 +113,7 @@
   ret = setvbuf(stream, NULL, _IOFBF, 64);
   if (ret < 0)
     {
-      printf("ssetvbuf_test ERROR: "
+      _info("ssetvbuf_test ERROR: "
              "setvbuf(stream, NULL, _IOFBF, 64) failed\n");
       ASSERT(false);
     }
@@ -127,12 +127,12 @@
 
   fclose(stream);
 
-  printf("setvbuf_test: Test FULL buffering, pre-allocated buffer\n");
+  _info("setvbuf_test: Test FULL buffering, pre-allocated buffer=%x\n", buffer);
 
   stream = fopen("/dev/console", "w");
   if (stream == NULL)
     {
-      printf("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
+      _info("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
       ASSERT(false);
       return ERROR;
     }
@@ -140,7 +140,7 @@
   ret = setvbuf(stream, buffer, _IOFBF, 64);
   if (ret < 0)
     {
-      printf("ssetvbuf_test ERROR: "
+      _info("ssetvbuf_test ERROR: "
              "setvbuf(stream, buffer, _IOFBF, 64) failed\n");
       ASSERT(false);
     }
@@ -155,12 +155,12 @@
 
   fclose(stream);
 
-  printf("setvbuf_test: Test LINE buffering, buffer size 64\n");
+  _info("setvbuf_test: Test LINE buffering, buffer size 64\n");
 
   stream = fopen("/dev/console", "w");
   if (stream == NULL)
     {
-      printf("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
+      _info("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
       ASSERT(false);
       return ERROR;
     }
@@ -168,7 +168,7 @@
   ret = setvbuf(stream, NULL, _IOLBF, 64);
   if (ret < 0)
     {
-      printf("setvbuf_test ERROR: "
+      _info("setvbuf_test ERROR: "
              "setvbuf(stream, NULL, _IOLBF, 64) failed\n");
       ASSERT(false);
     }
@@ -182,12 +182,12 @@
 
   fclose(stream);
 
-  printf("setvbuf_test: Test FULL buffering, pre-allocated buffer\n");
+  _info("setvbuf_test: Test FULL buffering, pre-allocated buffer\n");
 
   stream = fopen("/dev/console", "w");
   if (stream == NULL)
     {
-      printf("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
+      _info("setvbuf_test ERROR: fopen(dev/console, rw) failed\n");
       ASSERT(false);
       return ERROR;
     }
@@ -195,7 +195,7 @@
   ret = setvbuf(stream, buffer, _IOLBF, 64);
   if (ret < 0)
     {
-      printf("setvbuf_test ERROR: "
+      _info("setvbuf_test ERROR: "
              "setvbuf(stream, buffer, _IOLBF, 64) failed\n");
       ASSERT(false);
     }
diff -Naur apps-12.8.0/testing/ostest/sigev_thread.c apps/testing/ostest/sigev_thread.c
--- apps-12.8.0/testing/ostest/sigev_thread.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/sigev_thread.c	2025-11-04 11:04:41.013342380 +0200
@@ -30,6 +30,7 @@
 #include <semaphore.h>
 #include <signal.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 #include "ostest.h"
@@ -56,7 +57,7 @@
 {
   int sival_int = value.sival_int;
 
-  printf("sigev_thread_callback: Received value %d\n" , sival_int);
+  _info("sigev_thread_callback: Received value %d\n" , sival_int);
 
   g_value_received = sival_int;
   sem_post(&g_sigev_thread_sem);
@@ -73,13 +74,13 @@
   timer_t timerid;
   int status;
 
-  printf("sigev_thread_test: Initializing semaphore to 0\n");
+  _info("sigev_thread_test: Initializing semaphore to 0\n");
   sem_init(&g_sigev_thread_sem, 0, 0);
   g_value_received = -1;
 
   /* Create the POSIX timer */
 
-  printf("sigev_thread_test: Creating timer\n");
+  _info("sigev_thread_test: Creating timer\n");
 
   notify.sigev_notify            = SIGEV_THREAD;
   notify.sigev_signo             = MY_TIMER_SIGNAL;
@@ -90,7 +91,7 @@
   status = timer_create(CLOCK_REALTIME, &notify, &timerid);
   if (status != OK)
     {
-      printf("sigev_thread_test: "
+      _info("sigev_thread_test: "
              "ERROR timer_create failed, errno=%d\n", errno);
       ASSERT(false);
       goto errorout;
@@ -98,17 +99,17 @@
 
   /* Start the POSIX timer */
 
-  printf("sigev_thread_test: Starting timer\n");
+  _info("sigev_thread_test: Starting timer\n");
 
-  timer.it_value.tv_sec     = 2;
+  timer.it_value.tv_nsec     = 2;
   timer.it_value.tv_nsec    = 0;
-  timer.it_interval.tv_sec  = 2;
+  timer.it_interval.tv_nsec  = 2;
   timer.it_interval.tv_nsec = 0;
 
   status = timer_settime(timerid, 0, &timer, NULL);
   if (status != OK)
     {
-      printf("sigev_thread_test: "
+      _info("sigev_thread_test: "
              "ERROR timer_settime failed, errno=%d\n", errno);
       ASSERT(false);
       goto errorout;
@@ -116,7 +117,7 @@
 
   /* Take the semaphore */
 
-  printf("sigev_thread_test: Waiting on semaphore\n");
+  _info("sigev_thread_test: Waiting on semaphore\n");
 
   do
     {
@@ -126,12 +127,12 @@
           int error = errno;
           if (error == EINTR)
             {
-              printf("sigev_thread_test: sem_wait() interrupted by "
+              _info("sigev_thread_test: sem_wait() interrupted by "
                      "signal\n");
             }
           else
             {
-              printf("sigev_thread_test: ERROR sem_wait failed, errno=%d\n",
+              _info("sigev_thread_test: ERROR sem_wait failed, errno=%d\n",
                      error);
               ASSERT(false);
               goto errorout;
@@ -140,14 +141,14 @@
     }
   while (status < 0);
 
-  printf("sigev_thread_test: Awakened with no error!\n");
+  _info("sigev_thread_test: Awakened with no error!\n");
 
   /* Check sigval */
 
-  printf("sigev_thread_test: g_value_received=%d\n", g_value_received);
+  _info("sigev_thread_test: g_value_received=%d\n", g_value_received);
   if (g_value_received != SIGVALUE_INT)
     {
-      printf("sigev_thread_callback: ERROR sival_int=%d expected %d\n",
+      _info("sigev_thread_callback: ERROR sival_int=%d expected %d\n",
              g_value_received, SIGVALUE_INT);
       ASSERT(false);
     }
@@ -157,14 +158,14 @@
 
   /* Then delete the timer */
 
-  printf("sigev_thread_test: Deleting timer\n");
+  _info("sigev_thread_test: Deleting timer\n");
   status = timer_delete(timerid);
   if (status != OK)
     {
-      printf("sigev_thread_test: "
+      _info("sigev_thread_test: "
              "ERROR timer_create failed, errno=%d\n", errno);
       ASSERT(false);
     }
 
-  printf("sigev_thread_test: Done\n");
+  _info("sigev_thread_test: Done\n");
 }
diff -Naur apps-12.8.0/testing/ostest/sighand.c apps/testing/ostest/sighand.c
--- apps-12.8.0/testing/ostest/sighand.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/sighand.c	2025-11-04 11:04:41.005347030 +0200
@@ -34,6 +34,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <sys/types.h>
 #include <unistd.h>
 
@@ -64,7 +65,7 @@
 #ifdef CONFIG_SCHED_HAVE_PARENT
 static void death_of_child(int signo, siginfo_t *info, void *ucontext)
 {
-  /* Use of printf in a signal handler is NOT safe! It can cause deadlocks!
+  /* Use of _info in a signal handler is NOT safe! It can cause deadlocks!
    * Also, signals are not queued by NuttX.  As a consequence, some
    * notifications will get lost (or the info data can be overwrittedn)!
    * Because POSIX  does not require signals to be queued, I do not think
@@ -73,14 +74,14 @@
 
   if (info)
     {
-      printf("death_of_child: PID %d received signal=%d code=%d "
+      _info("death_of_child: PID %d received signal=%d code=%d "
              "errno=%d pid=%d status=%d\n",
              getpid(), signo, info->si_code, info->si_errno,
              info->si_pid, info->si_status);
     }
   else
     {
-      printf("death_of_child: PID %d received signal=%d (no info?)\n",
+      _info("death_of_child: PID %d received signal=%d (no info?)\n",
              getpid(), signo);
     }
 }
@@ -92,7 +93,7 @@
   sigset_t allsigs;
   int status;
 
-  /* Use of printf in a signal handler is NOT safe! It can cause deadlocks! */
+  /* Use of _info in a signal handler is NOT safe! It can cause deadlocks! */
 
   sigreceived = true;
 
@@ -137,20 +138,20 @@
   struct sigaction oact;
   int status;
 
-  printf("waiter_main: Waiter started\n");
+  _info("waiter_main: Waiter started\n");
 
-  printf("waiter_main: Unmasking signal %d\n" , WAKEUP_SIGNAL);
+  _info("waiter_main: Unmasking signal %d\n" , WAKEUP_SIGNAL);
   sigemptyset(&set);
   sigaddset(&set, WAKEUP_SIGNAL);
   status = sigprocmask(SIG_UNBLOCK, &set, NULL);
   if (status != OK)
     {
-      printf("waiter_main: ERROR sigprocmask failed, status=%d\n",
+      _info("waiter_main: ERROR sigprocmask failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
-  printf("waiter_main: Registering signal handler\n");
+  _info("waiter_main: Registering signal handler\n");
   act.sa_sigaction = wakeup_action;
   act.sa_flags  = SA_SIGINFO;
 
@@ -160,19 +161,19 @@
   status = sigaction(WAKEUP_SIGNAL, &act, &oact);
   if (status != OK)
     {
-      printf("waiter_main: ERROR sigaction failed, status=%d\n" , status);
+      _info("waiter_main: ERROR sigaction failed, status=%d\n" , status);
       ASSERT(false);
     }
 
 #ifndef SDCC
-  printf("waiter_main: oact.sigaction=%p oact.sa_flags=%x "
+  _info("waiter_main: oact.sigaction=%p oact.sa_flags=%x "
          "oact.sa_mask=" SIGSET_FMT "\n",
           oact.sa_sigaction, oact.sa_flags, SIGSET_ELEM(&oact.sa_mask));
 #endif
 
   /* Take the semaphore */
 
-  printf("waiter_main: Waiting on semaphore\n");
+  _info("waiter_main: Waiting on semaphore\n");
   FFLUSH();
 
   status = sem_wait(&sem1);
@@ -181,18 +182,18 @@
       int error = errno;
       if (error == EINTR)
         {
-          printf("waiter_main: sem_wait() successfully interrupted by "
+          _info("waiter_main: sem_wait() successfully interrupted by "
                  "signal\n");
         }
       else
         {
-          printf("waiter_main: ERROR sem_wait failed, errno=%d\n" , error);
+          _info("waiter_main: ERROR sem_wait failed, errno=%d\n" , error);
           ASSERT(false);
         }
     }
   else
     {
-      printf("waiter_main: ERROR awakened with no error!\n");
+      _info("waiter_main: ERROR awakened with no error!\n");
       ASSERT(false);
     }
 
@@ -201,7 +202,7 @@
   act.sa_handler = SIG_DFL;
   sigaction(WAKEUP_SIGNAL, &act, &oact);
 
-  printf("waiter_main: done\n");
+  _info("waiter_main: done\n");
   FFLUSH();
 
   thread1exited = true;
@@ -225,24 +226,24 @@
   pid_t waiterpid;
   int status;
 
-  printf("sighand_test: Initializing semaphore to 0\n");
+  _info("sighand_test: Initializing semaphore to 0\n");
   sem_init(&sem1, 0, 0);
   sem_init(&sem2, 0, 0);
 
 #ifdef CONFIG_SCHED_HAVE_PARENT
-  printf("sighand_test: Unmasking SIGCHLD\n");
+  _info("sighand_test: Unmasking SIGCHLD\n");
 
   sigemptyset(&set);
   sigaddset(&set, SIGCHLD);
   status = sigprocmask(SIG_UNBLOCK, &set, NULL);
   if (status != OK)
     {
-      printf("sighand_test: ERROR sigprocmask failed, status=%d\n",
+      _info("sighand_test: ERROR sigprocmask failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
-  printf("sighand_test: Registering SIGCHLD handler\n");
+  _info("sighand_test: Registering SIGCHLD handler\n");
   act.sa_sigaction = death_of_child;
   act.sa_flags  = SA_SIGINFO;
 
@@ -252,18 +253,18 @@
   status = sigaction(SIGCHLD, &act, &oact);
   if (status != OK)
     {
-      printf("waiter_main: ERROR sigaction failed, status=%d\n" , status);
+      _info("waiter_main: ERROR sigaction failed, status=%d\n" , status);
       ASSERT(false);
     }
 #endif
 
   /* Start waiter thread  */
 
-  printf("sighand_test: Starting waiter task\n");
+  _info("sighand_test: Starting waiter task\n");
   status = sched_getparam (0, &param);
   if (status != OK)
     {
-      printf("sighand_test: ERROR sched_getparam() failed\n");
+      _info("sighand_test: ERROR sched_getparam() failed\n");
       ASSERT(false);
       param.sched_priority = PTHREAD_DEFAULT_PRIORITY;
     }
@@ -274,29 +275,29 @@
   status = pthread_create(&waiterpid, &attr, waiter_main, NULL);
   if (status != 0)
     {
-      printf("sighand_test: ERROR failed to start waiter_main\n");
+      _info("sighand_test: ERROR failed to start waiter_main\n");
       ASSERT(false);
     }
   else
     {
-      printf("sighand_test: Started waiter_main pid=%d\n", waiterpid);
+      _info("sighand_test: Started waiter_main pid=%d\n", waiterpid);
     }
 
   /* Wait a bit */
 
   FFLUSH();
-  sleep(2);
+  usleep(2);
 
   /* Then signal the waiter thread. */
 
-  printf("sighand_test: Signaling pid=%d with signo=%d sigvalue=%d\n",
+  _info("sighand_test: Signaling pid=%d with signo=%d sigvalue=%d\n",
          waiterpid, WAKEUP_SIGNAL, SIGVALUE_INT);
 
   sigvalue.sival_int = SIGVALUE_INT;
   status = sigqueue(waiterpid, WAKEUP_SIGNAL, sigvalue);
   if (status != OK)
     {
-      printf("sighand_test: ERROR sigqueue failed\n");
+      _info("sighand_test: ERROR sigqueue failed\n");
       ASSERT(false);
       pthread_cancel(waiterpid);
     }
@@ -304,23 +305,23 @@
   /* Wait a bit */
 
   FFLUSH();
-  status = sleep(2);
+  status = usleep(2);
   while (status)
     {
-      status = sleep(status);
+      status = usleep(status);
     }
 
   /* Then check the result */
 
   if (!thread1exited)
     {
-      printf("sighand_test: ERROR waiter task did not exit\n");
+      _info("sighand_test: ERROR waiter task did not exit\n");
       ASSERT(false);
     }
 
   if (!sigreceived)
     {
-      printf("sighand_test: ERROR signal handler did not run\n");
+      _info("sighand_test: ERROR signal handler did not run\n");
       ASSERT(false);
     }
 
@@ -331,7 +332,7 @@
   sigaction(SIGCHLD, &act, &oact);
 #endif
 
-  printf("sighand_test: done\n");
+  _info("sighand_test: done\n");
   FFLUSH();
   sem_destroy(&sem2);
   sem_destroy(&sem1);
diff -Naur apps-12.8.0/testing/ostest/signest.c apps/testing/ostest/signest.c
--- apps-12.8.0/testing/ostest/signest.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/signest.c	2025-11-04 11:04:41.029333081 +0200
@@ -34,6 +34,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdlib.h>
 #include <sys/types.h>
 #include <unistd.h>
@@ -127,19 +128,19 @@
   int ret;
   int i;
 
-  printf("waiter_main: Waiter started\n");
-  printf("waiter_main: Setting signal mask\n");
+  _info("waiter_main: Waiter started\n");
+  _info("waiter_main: Setting signal mask\n");
 
   sigemptyset(&set);
   ret = sigprocmask(SIG_SETMASK, &set, NULL);
   if (ret < 0)
     {
-      printf("waiter_main: ERROR sigprocmask failed: %d\n", errno);
+      _info("waiter_main: ERROR sigprocmask failed: %d\n", errno);
       ASSERT(false);
       return NULL;
     }
 
-  printf("waiter_main: Registering signal handler\n");
+  _info("waiter_main: Registering signal handler\n");
 
   act.sa_handler = waiter_action;
   act.sa_flags   = 0;
@@ -160,7 +161,7 @@
           ret = sigaction(i, &act, NULL);
           if (ret < 0)
             {
-              printf("waiter_main: WARNING sigaction failed with %d\n",
+              _info("waiter_main: WARNING sigaction failed with %d\n",
                      errno);
               return NULL;
             }
@@ -169,7 +170,7 @@
 
   /* Now just loop until the test completes */
 
-  printf("waiter_main: Waiting on semaphore\n");
+  _info("waiter_main: Waiting on semaphore\n");
   FFLUSH();
   sem_post(&g_sem_thread_started);
 
@@ -189,7 +190,7 @@
 {
   /* Now just loop staying in the way as much as possible */
 
-  printf("interfere_main: Waiting on semaphore\n");
+  _info("interfere_main: Waiting on semaphore\n");
   FFLUSH();
 
   g_interferer_running = true;
@@ -223,7 +224,7 @@
   while (wait_times > 0)
     {
       clock_gettime(CLOCK_REALTIME, &ts);
-      ts.tv_sec += 2;
+      ts.tv_nsec += 1000000;
       if (sem_timedwait(&g_sem_signal_finish, &ts) != OK)
         {
           sinfo("signest_test wait too long");
@@ -274,7 +275,7 @@
   ret = sched_getparam(0, &param);
   if (ret < 0)
     {
-      printf("signest_test: ERROR sched_getparam() failed\n");
+      _info("signest_test: ERROR sched_getparam() failed\n");
       ASSERT(false);
       param.sched_priority = PTHREAD_DEFAULT_PRIORITY;
     }
@@ -282,7 +283,7 @@
   /* Start waiter thread  */
 
   param.sched_priority++;
-  printf("signest_test: Starting signal waiter task at priority %d\n",
+  _info("signest_test: Starting signal waiter task at priority %d\n",
          param.sched_priority);
   pthread_attr_init(&attr);
   pthread_attr_setschedparam(&attr, &param);
@@ -290,28 +291,28 @@
   ret = pthread_create(&waiterpid, &attr, waiter_main, NULL);
   if (ret != 0)
     {
-      printf("signest_test: ERROR failed to start waiter_main\n");
+      _info("signest_test: ERROR failed to start waiter_main\n");
       ASSERT(false);
       return;
     }
 
-  printf("signest_test: Started waiter_main pid=%d\n", waiterpid);
+  _info("signest_test: Started waiter_main pid=%d\n", waiterpid);
 
   /* Start interfering thread  */
 
   param.sched_priority++;
-  printf("signest_test: Starting interfering task at priority %d\n",
+  _info("signest_test: Starting interfering task at priority %d\n",
          param.sched_priority);
   pthread_attr_setschedparam(&attr, &param);
   ret = pthread_create(&interferepid, &attr, interfere_main, NULL);
   if (ret != 0)
     {
-      printf("signest_test: ERROR failed to start interfere_main\n");
+      _info("signest_test: ERROR failed to start interfere_main\n");
       ASSERT(false);
       goto errout_with_waiter;
     }
 
-  printf("signest_test: Started interfere_main pid=%d\n", interferepid);
+  _info("signest_test: Started interfere_main pid=%d\n", interferepid);
 
   /* Wait a bit */
 
@@ -364,12 +365,12 @@
   total_handled = g_odd_handled + g_even_handled;
   total_nested  = g_odd_nested + g_even_nested;
 
-  printf("signest_test: Simple case:\n");
-  printf("  Total signalled %-3d  Odd=%-3d Even=%-3d\n",
+  _info("signest_test: Simple case:\n");
+  _info("  Total signalled %-3d  Odd=%-3d Even=%-3d\n",
          total_signals, odd_signals, even_signals);
-  printf("  Total handled   %-3d  Odd=%-3d Even=%-3d\n",
+  _info("  Total handled   %-3d  Odd=%-3d Even=%-3d\n",
          total_handled, g_odd_handled, g_even_handled);
-  printf("  Total nested    %-3d  Odd=%-3d Even=%-3d\n",
+  _info("  Total nested    %-3d  Odd=%-3d Even=%-3d\n",
          total_nested, g_odd_nested, g_even_nested);
 
   /* Then signal the waiter thread with two signals pending.  The
@@ -429,12 +430,12 @@
   total_handled = g_odd_handled + g_even_handled;
   total_nested  = g_odd_nested + g_even_nested;
 
-  printf("signest_test: With task locking\n");
-  printf("  Total signalled %-3d  Odd=%-3d Even=%-3d\n",
+  _info("signest_test: With task locking\n");
+  _info("  Total signalled %-3d  Odd=%-3d Even=%-3d\n",
          total_signals, odd_signals, even_signals);
-  printf("  Total handled   %-3d  Odd=%-3d Even=%-3d\n",
+  _info("  Total handled   %-3d  Odd=%-3d Even=%-3d\n",
          total_handled, g_odd_handled, g_even_handled);
-  printf("  Total nested    %-3d  Odd=%-3d Even=%-3d\n",
+  _info("  Total nested    %-3d  Odd=%-3d Even=%-3d\n",
          total_nested, g_odd_nested, g_even_nested);
 
   /* Then do it all over again with the interfering thread. */
@@ -506,52 +507,52 @@
   total_handled = g_odd_handled + g_even_handled;
   total_nested  = g_odd_nested + g_even_nested;
 
-  printf("signest_test: With intefering thread\n");
-  printf("  Total signalled %-3d  Odd=%-3d Even=%-3d\n",
+  _info("signest_test: With intefering thread\n");
+  _info("  Total signalled %-3d  Odd=%-3d Even=%-3d\n",
          total_signals, odd_signals, even_signals);
-  printf("  Total handled   %-3d  Odd=%-3d Even=%-3d\n",
+  _info("  Total handled   %-3d  Odd=%-3d Even=%-3d\n",
          total_handled, g_odd_handled, g_even_handled);
-  printf("  Total nested    %-3d  Odd=%-3d Even=%-3d\n",
+  _info("  Total nested    %-3d  Odd=%-3d Even=%-3d\n",
          total_nested, g_odd_nested, g_even_nested);
 
   /* Check for error */
 
   if (g_waiter_running)
     {
-      printf("signest_test: ERROR waiter is still running\n");
+      _info("signest_test: ERROR waiter is still running\n");
       ASSERT(false);
     }
 
   if (g_interferer_running)
     {
-      printf("signest_test: ERROR interferer is still running\n");
+      _info("signest_test: ERROR interferer is still running\n");
       ASSERT(false);
     }
 
   if (total_signals != total_handled)
     {
-      printf("signest_test: ERROR only %d of %d signals were handled\n",
+      _info("signest_test: ERROR only %d of %d signals were handled\n",
              total_handled, total_signals);
       ASSERT(false);
     }
 
   if (odd_signals != g_odd_handled)
     {
-      printf("signest_test: ERROR only %d of %d ODD signals were handled\n",
+      _info("signest_test: ERROR only %d of %d ODD signals were handled\n",
              g_odd_handled, odd_signals);
       ASSERT(false);
     }
 
   if (even_signals != g_even_handled)
     {
-      printf("signest_test: ERROR only %d of %d EVEN signals were handled\n",
+      _info("signest_test: ERROR only %d of %d EVEN signals were handled\n",
              g_even_handled, even_signals);
       ASSERT(false);
     }
 
   if (g_odd_nested > 0)
     {
-      printf("signest_test: ERROR %d ODD signals were nested\n",
+      _info("signest_test: ERROR %d ODD signals were nested\n",
              g_odd_nested);
       ASSERT(false);
     }
@@ -561,6 +562,6 @@
   sem_destroy(&g_sem_thread_started);
   sem_destroy(&g_sem_signal_finish);
 
-  printf("signest_test: done\n");
+  _info("signest_test: done\n");
   FFLUSH();
 }
diff -Naur apps-12.8.0/testing/ostest/sigprocmask.c apps/testing/ostest/sigprocmask.c
--- apps-12.8.0/testing/ostest/sigprocmask.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/sigprocmask.c	2025-11-04 11:04:41.011343543 +0200
@@ -29,6 +29,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 #include <sys/types.h>
 
@@ -71,7 +72,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout;
     }
@@ -82,7 +83,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigemptyset failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigemptyset failed: %d\n", errcode);
       ASSERT(false);
       goto errout;
     }
@@ -91,7 +92,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -110,7 +111,7 @@
           if (ret != OK)
             {
               int errcode = errno;
-              printf("sigprocmask_test: ERROR sigaddset failed: %d\n",
+              _info("sigprocmask_test: ERROR sigaddset failed: %d\n",
                 errcode);
               ASSERT(false);
               goto errout_with_mask;
@@ -121,7 +122,7 @@
       if (ret != OK)
         {
           int errcode = errno;
-          printf("sigprocmask_test: ERROR sighold failed: %d\n", errcode);
+          _info("sigprocmask_test: ERROR sighold failed: %d\n", errcode);
           ASSERT(false);
           goto errout_with_mask;
         }
@@ -133,7 +134,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -142,7 +143,7 @@
 
   if (memcmp(&currmask, &newmask, sizeof(sigset_t)) != 0)
     {
-      printf("sigprocmask_test: ERROR unexpected sigprocmask\n");
+      _info("sigprocmask_test: ERROR unexpected sigprocmask\n");
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -153,7 +154,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigfillset failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigfillset failed: %d\n", errcode);
       ASSERT(false);
       goto errout;
     }
@@ -162,7 +163,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -177,7 +178,7 @@
       if (ret != OK)
         {
           int errcode = errno;
-          printf("sigprocmask_test: ERROR sigdelset failed: %d\n", errcode);
+          _info("sigprocmask_test: ERROR sigdelset failed: %d\n", errcode);
           ASSERT(false);
           goto errout_with_mask;
         }
@@ -186,7 +187,7 @@
       if (ret != OK)
         {
           int errcode = errno;
-          printf("sigprocmask_test: ERROR sigrelse failed: %d\n", errcode);
+          _info("sigprocmask_test: ERROR sigrelse failed: %d\n", errcode);
           ASSERT(false);
           goto errout_with_mask;
         }
@@ -198,7 +199,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -211,7 +212,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -220,7 +221,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -229,7 +230,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -238,7 +239,7 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -247,7 +248,7 @@
 
   if (memcmp(&currmask, &newmask, sizeof(sigset_t)) != 0)
     {
-      printf("sigprocmask_test: ERROR unexpected sigprocmask\n");
+      _info("sigprocmask_test: ERROR unexpected sigprocmask\n");
       ASSERT(false);
       goto errout_with_mask;
     }
@@ -256,12 +257,12 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout;
     }
 
-  printf("sigprocmask_test: SUCCESS\n");
+  _info("sigprocmask_test: SUCCESS\n");
   FFLUSH();
   return;
 
@@ -270,12 +271,12 @@
   if (ret != OK)
     {
       int errcode = errno;
-      printf("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
+      _info("sigprocmask_test: ERROR sigprocmask failed: %d\n", errcode);
       ASSERT(false);
       goto errout;
     }
 
 errout:
-  printf("sigprocmask_test: Aborting\n");
+  _info("sigprocmask_test: Aborting\n");
   FFLUSH();
 }
diff -Naur apps-12.8.0/testing/ostest/smp_call.c apps/testing/ostest/smp_call.c
--- apps-12.8.0/testing/ostest/smp_call.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/smp_call.c	2025-11-04 11:04:41.011343543 +0200
@@ -28,6 +28,7 @@
 #include <semaphore.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 
 #include <nuttx/sched.h>
 
@@ -77,39 +78,39 @@
       0
     };
 
-  printf("smp_call_test: Test start\n");
+  _info("smp_call_test: Test start\n");
 
   sem_init(&sem, 0, 0);
   nxsched_smp_call_init(&call_data, smp_call_func, &sem);
 
   for (cpu = 0; cpu < CONFIG_SMP_NCPUS; cpu++)
     {
-      printf("smp_call_test: Call cpu %d, nowait\n", cpu);
+      _info("smp_call_test: Call cpu %d, nowait\n", cpu);
 
       nxsched_smp_call_single_async(cpu, &call_data);
 
       status = sem_wait(&sem);
       if (status != 0)
         {
-          printf("smp_call_test: Check smp call error\n");
+          _info("smp_call_test: Check smp call error\n");
           ASSERT(false);
         }
 
-      printf("smp_call_test: Call cpu %d, wait\n", cpu);
+      _info("smp_call_test: Call cpu %d, wait\n", cpu);
 
       nxsched_smp_call_single(cpu, smp_call_func, &sem);
 
       sem_getvalue(&sem, &value);
       if (value != 1)
         {
-          printf("smp_call_test: Check smp call wait error\n");
+          _info("smp_call_test: Check smp call wait error\n");
           ASSERT(false);
         }
 
       nxsem_reset(&sem, 0);
     }
 
-  printf("smp_call_test: Call multi cpu, nowait\n");
+  _info("smp_call_test: Call multi cpu, nowait\n");
 
   sched_getaffinity(0, sizeof(cpu_set_t), &cpuset);
   cpucnt = CPU_COUNT(&cpuset);
@@ -121,12 +122,12 @@
       status = sem_wait(&sem);
       if (status != 0)
         {
-          printf("smp_call_test: Check smp call error\n");
+          _info("smp_call_test: Check smp call error\n");
           ASSERT(false);
         }
     }
 
-  printf("smp_call_test: Call in interrupt, wait\n");
+  _info("smp_call_test: Call in interrupt, wait\n");
 
   memset(&wdog, 0, sizeof(wdog));
   wd_start(&wdog, 0, wdg_wdentry, (wdparm_t)&sem);
@@ -135,24 +136,24 @@
       status = sem_wait(&sem);
       if (status != 0)
         {
-          printf("smp_call_test: smp call in interrupt error\n");
+          _info("smp_call_test: smp call in interrupt error\n");
           ASSERT(false);
         }
     }
 
-  printf("smp_call_test: Call multi cpu, wait\n");
+  _info("smp_call_test: Call multi cpu, wait\n");
 
   nxsched_smp_call(cpuset, smp_call_func, &sem);
 
   sem_getvalue(&sem, &value);
   if (value != cpucnt)
     {
-      printf("smp_call_test: Check smp call wait error\n");
+      _info("smp_call_test: Check smp call wait error\n");
       ASSERT(false);
     }
 
   sem_destroy(&sem);
 
-  printf("smp_call_test: Test success\n");
+  _info("smp_call_test: Test success\n");
 }
 #endif
diff -Naur apps-12.8.0/testing/ostest/specific.c apps/testing/ostest/specific.c
--- apps-12.8.0/testing/ostest/specific.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/specific.c	2025-11-04 11:04:41.008345286 +0200
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 
 #include "ostest.h"
 
@@ -56,7 +57,7 @@
   ret = pthread_setspecific(g_pthread_key, (FAR const void *)0xcafebabe);
   if (ret != 0)
     {
-      printf("ERROR: pthread_setspecific() failed: %d\n", ret);
+      _info("ERROR: pthread_setspecific() failed: %d\n", ret);
       ASSERT(false);
     }
 
@@ -65,7 +66,7 @@
   data = pthread_getspecific(g_pthread_key);
   if (data != (FAR void *)0xcafebabe)
     {
-      printf("ERROR: pthread_getspecific() failed: Returned %p vs %p\n",
+      _info("ERROR: pthread_getspecific() failed: Returned %p vs %p\n",
              data, (FAR void *)0xcafebabe);
       ASSERT(false);
     }
@@ -92,7 +93,7 @@
   ret = pthread_key_create(&g_pthread_key, NULL);
   if (ret != 0)
     {
-      printf("ERROR: pthread_key_create() failed: %d\n", ret);
+      _info("ERROR: pthread_key_create() failed: %d\n", ret);
       ASSERT(false);
     }
 
@@ -101,7 +102,7 @@
   ret = pthread_setspecific(g_pthread_key, (FAR const void *)0xf00dface);
   if (ret != 0)
     {
-      printf("ERROR: pthread_setspecific() failed: %d\n", ret);
+      _info("ERROR: pthread_setspecific() failed: %d\n", ret);
       ASSERT(false);
     }
 
@@ -110,14 +111,14 @@
   data = pthread_getspecific(g_pthread_key);
   if (data != (FAR void *)0xf00dface)
     {
-      printf("ERROR: pthread_getspecific() failed: Returned %p vs %p\n",
+      _info("ERROR: pthread_getspecific() failed: Returned %p vs %p\n",
              data, (FAR void *)0xf00dface);
       ASSERT(false);
     }
 
   /* Start a thread */
 
-  printf("Starting thread\n");
+  _info("Starting thread\n");
 #ifdef SDCC
   pthread_attr_init(&attr);
   ret = pthread_create(&thread, &attr, thread_func, (pthread_addr_t)0);
@@ -126,7 +127,7 @@
 #endif
   if (ret != 0)
     {
-      printf("ERROR: pthread_create() failed: %d\n", ret);
+      _info("ERROR: pthread_create() failed: %d\n", ret);
       ASSERT(false);
     }
 
@@ -143,7 +144,7 @@
   data = pthread_getspecific(g_pthread_key);
   if (data != (FAR void *)0xf00dface)
     {
-      printf("ERROR: pthread_getspecific() failed: Returned %p vs %p\n",
+      _info("ERROR: pthread_getspecific() failed: Returned %p vs %p\n",
              data, (FAR void *)0xf00dface);
       ASSERT(false);
     }
@@ -153,7 +154,7 @@
   ret = pthread_key_delete(g_pthread_key);
   if (ret != 0)
     {
-      printf("ERROR: pthread_key_delete() failed: %d\n", ret);
+      _info("ERROR: pthread_key_delete() failed: %d\n", ret);
       ASSERT(false);
     }
 }
diff -Naur apps-12.8.0/testing/ostest/sporadic2.c apps/testing/ostest/sporadic2.c
--- apps-12.8.0/testing/ostest/sporadic2.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/sporadic2.c	2025-11-04 11:04:41.013342380 +0200
@@ -31,6 +31,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdlib.h>
 #include <sys/param.h>
 #include <time.h>
@@ -123,7 +124,7 @@
           ret = sched_getparam(0, &param);
           if (ret < 0)
             {
-              printf("ERROR: sched_getparam failed\n");
+              _info("ERROR: sched_getparam failed\n");
               ASSERT(false);
               return NULL;
             }
@@ -165,9 +166,9 @@
   int ret;
 
 #if CONFIG_SCHED_SPORADIC_MAXREPL < 5
-  printf("sporadic_test: CONFIG_SCHED_SPORADIC_MAXREPL is small: %d\n",
+  _info("sporadic_test: CONFIG_SCHED_SPORADIC_MAXREPL is small: %d\n",
          CONFIG_SCHED_SPORADIC_MAXREPL);
-  printf("  -- There will some errors in the replenishment interval\n");
+  _info("  -- There will some errors in the replenishment interval\n");
 #endif
 
   sem_init(&g_sporadic_sem, 0, 0);
@@ -182,7 +183,7 @@
   ret = sched_getparam(0, &myparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: sched_getparam failed, ret=%d\n", ret);
+      _info("sporadic_test: ERROR: sched_getparam failed, ret=%d\n", ret);
       ASSERT(false);
     }
 
@@ -192,14 +193,14 @@
   ret = sched_setparam(0, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
+      _info("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
       ASSERT(false);
     }
 
   ret = pthread_attr_init(&attr);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_init failed, ret=%d\n",
+      _info("sporadic_test: ERROR: pthread_attr_init failed, ret=%d\n",
              ret);
       ASSERT(false);
     }
@@ -213,7 +214,7 @@
   ret = pthread_attr_setschedpolicy(&attr, SCHED_SPORADIC);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -221,16 +222,16 @@
 
   sparam.sched_priority               = PRIO_HIGH1;
   sparam.sched_ss_low_priority        = PRIO_LOW1;
-  sparam.sched_ss_repl_period.tv_sec  = 0;
+  sparam.sched_ss_repl_period.tv_nsec  = 0;
   sparam.sched_ss_repl_period.tv_nsec = REPL_INTERVAL;
-  sparam.sched_ss_init_budget.tv_sec  = 0;
+  sparam.sched_ss_init_budget.tv_nsec  = 0;
   sparam.sched_ss_init_budget.tv_nsec = budget_1_ns;
   sparam.sched_ss_max_repl            = CONFIG_SCHED_SPORADIC_MAXREPL;
 
   ret = pthread_attr_setschedparam(&attr, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setsched param failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setsched param failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -240,7 +241,7 @@
                        (pthread_addr_t)g_ms_cnt1);
   if (ret != 0)
     {
-      printf("sporadic_test: ERROR: sporadic thread creation failed: %d\n",
+      _info("sporadic_test: ERROR: sporadic thread creation failed: %d\n",
              ret);
       ASSERT(false);
     }
@@ -248,7 +249,7 @@
   ret = pthread_attr_setschedpolicy(&attr, SCHED_SPORADIC);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -261,7 +262,7 @@
   ret = pthread_attr_setschedparam(&attr, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setsched param failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setsched param failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -271,7 +272,7 @@
                        (pthread_addr_t)g_ms_cnt2);
   if (ret != 0)
     {
-      printf("sporadic_test: ERROR: sporadic thread creation failed: %d\n",
+      _info("sporadic_test: ERROR: sporadic thread creation failed: %d\n",
              ret);
       ASSERT(false);
     }
@@ -279,7 +280,7 @@
   ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -290,7 +291,7 @@
   sem_post(&g_sporadic_sem);
   sem_post(&g_sporadic_sem);
 
-  sleep(100);
+  usleep(100);
 
   ret = pthread_cancel(sporadic_thread1);
   pthread_join(sporadic_thread1, &result);
@@ -302,7 +303,7 @@
   ret = sched_setparam(0, &myparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
+      _info("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
       ASSERT(false);
     }
 }
@@ -317,11 +318,11 @@
   int32_t budget_2_ns = 30 * 1000000;
   int i;
 
-  printf("Sporadic 1: prio high %d, low %d, repl %" PRIi32 " ns\n",
+  _info("Sporadic 1: prio high %d, low %d, repl %" PRIi32 " ns\n",
          PRIO_HIGH1, PRIO_LOW1, REPL_INTERVAL);
-  printf("Sporadic 2: prio high %d, low %d, repl %" PRIi32 " ns\n",
+  _info("Sporadic 2: prio high %d, low %d, repl %" PRIi32 " ns\n",
          PRIO_HIGH2, PRIO_LOW2, REPL_INTERVAL);
-  printf("\n%14s%10s%7s%7s\n", "THREAD", "BUDGET", "HI MS", "LO MS");
+  _info("\n%14s%10s%7s%7s\n", "THREAD", "BUDGET", "HI MS", "LO MS");
 
   for (budget_1_ns = 0, i = 1;
        budget_1_ns <= MAX_BUDGET;
@@ -329,10 +330,10 @@
     {
       sporadic_test_case(budget_1_ns, budget_2_ns);
 
-      printf("%3d Sporadic 1 %09" PRIi32 " %6" PRIi32 " %6" PRIi32 "\n",
+      _info("%3d Sporadic 1 %09" PRIi32 " %6" PRIi32 " %6" PRIi32 "\n",
              i,
              budget_1_ns, g_ms_cnt1[PRIO_HI_NDX], g_ms_cnt1[PRIO_LO_NDX]);
-      printf("    Sporadic 2 %09" PRIi32 " %6" PRIi32 " %6" PRIi32 "\n",
+      _info("    Sporadic 2 %09" PRIi32 " %6" PRIi32 " %6" PRIi32 "\n",
              budget_2_ns, g_ms_cnt2[PRIO_HI_NDX], g_ms_cnt2[PRIO_LO_NDX]);
     }
 
diff -Naur apps-12.8.0/testing/ostest/sporadic.c apps/testing/ostest/sporadic.c
--- apps-12.8.0/testing/ostest/sporadic.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/sporadic.c	2025-11-04 11:04:41.019338893 +0200
@@ -31,6 +31,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 #include <sys/param.h>
 #include <time.h>
 #include <unistd.h>
@@ -117,7 +118,7 @@
           ret = sched_getparam(0, &param);
           if (ret < 0)
             {
-              printf("ERROR: sched_getparam failed\n");
+              _info("ERROR: sched_getparam failed\n");
               ASSERT(false);
               return NULL;
             }
@@ -128,7 +129,7 @@
       while (now == last);
 
       sched_lock(); /* Just to exercise more logic */
-      printf("%4lu FIFO:     %d\n",
+      _info("%4lu FIFO:     %d\n",
              (unsigned long)(now - g_start_time), param.sched_priority);
       last = now;
       sched_unlock();
@@ -155,7 +156,7 @@
           ret = sched_getparam(0, &param);
           if (ret < 0)
             {
-              printf("ERROR: sched_getparam failed\n");
+              _info("ERROR: sched_getparam failed\n");
               ASSERT(false);
               return NULL;
             }
@@ -166,7 +167,7 @@
       while (now == last && prio == param.sched_priority);
 
       sched_lock(); /* Just to exercise more logic */
-      printf("%4lu SPORADIC: %d->%d\n",
+      _info("%4lu SPORADIC: %d->%d\n",
              (unsigned long)(now - g_start_time), prio,
              param.sched_priority);
       prio = param.sched_priority;
@@ -199,12 +200,12 @@
   int ret;
 
 #if CONFIG_SCHED_SPORADIC_MAXREPL < 5
-  printf("sporadic_test: CONFIG_SCHED_SPORADIC_MAXREPL is small: %d\n",
+  _info("sporadic_test: CONFIG_SCHED_SPORADIC_MAXREPL is small: %d\n",
          CONFIG_SCHED_SPORADIC_MAXREPL);
-  printf("  -- There will some errors in the replenishment interval\n");
+  _info("  -- There will some errors in the replenishment interval\n");
 #endif
 
-  printf("sporadic_test: Initializing semaphore to 0\n");
+  _info("sporadic_test: Initializing semaphore to 0\n");
   sem_init(&g_sporadic_sem, 0, 0);
 
   prio_min  = sched_get_priority_min(SCHED_FIFO);
@@ -219,7 +220,7 @@
   ret = sched_getparam(0, &myparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: sched_getparam failed, ret=%d\n", ret);
+      _info("sporadic_test: ERROR: sched_getparam failed, ret=%d\n", ret);
       ASSERT(false);
     }
 
@@ -227,14 +228,14 @@
   ret = sched_setparam(0, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
+      _info("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
       ASSERT(false);
     }
 
   ret = pthread_attr_init(&attr);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_init failed, ret=%d\n",
+      _info("sporadic_test: ERROR: pthread_attr_init failed, ret=%d\n",
              ret);
       ASSERT(false);
     }
@@ -246,12 +247,12 @@
 
   /* Start a FIFO thread at the highest priority (prio_max + 1) */
 
-  printf("sporadic_test: Starting FIFO thread at priority %d\n", prio_mid);
+  _info("sporadic_test: Starting FIFO thread at priority %d\n", prio_mid);
 
   ret = pthread_attr_setschedpolicy(&attr, SCHED_FIFO);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -261,7 +262,7 @@
   ret = pthread_attr_setschedparam(&attr, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedparam failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedparam failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -270,7 +271,7 @@
   ret = pthread_create(&nuisance_thread, &attr, nuisance_func, NULL);
   if (ret != 0)
     {
-      printf("sporadic_test: ERROR: FIFO thread creation failed: %d\n",
+      _info("sporadic_test: ERROR: FIFO thread creation failed: %d\n",
              ret);
       ASSERT(false);
     }
@@ -281,7 +282,7 @@
   ret = pthread_attr_setschedparam(&attr, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedparam failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedparam failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -290,21 +291,21 @@
   ret = pthread_create(&fifo_thread, &attr, fifo_func, NULL);
   if (ret != 0)
     {
-      printf("sporadic_test: ERROR: FIFO thread creation failed: %d\n",
+      _info("sporadic_test: ERROR: FIFO thread creation failed: %d\n",
              ret);
       ASSERT(false);
     }
 
   /* Start a sporadic thread, with the following parameters: */
 
-  printf("sporadic_test: Starting sporadic thread at priority "
+  _info("sporadic_test: Starting sporadic thread at priority "
          "%d (hi) %d (lo)\n",
          prio_high, prio_low);
 
   ret = pthread_attr_setschedpolicy(&attr, SCHED_SPORADIC);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setschedpolicy failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -312,16 +313,16 @@
 
   sparam.sched_priority               = prio_high;
   sparam.sched_ss_low_priority        = prio_low;
-  sparam.sched_ss_repl_period.tv_sec  = 5;
+  sparam.sched_ss_repl_period.tv_nsec  = 5;
   sparam.sched_ss_repl_period.tv_nsec = 0;
-  sparam.sched_ss_init_budget.tv_sec  = 2;
+  sparam.sched_ss_init_budget.tv_nsec  = 2;
   sparam.sched_ss_init_budget.tv_nsec = 0;
   sparam.sched_ss_max_repl            = CONFIG_SCHED_SPORADIC_MAXREPL;
 
   ret = pthread_attr_setschedparam(&attr, &sparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: pthread_attr_setsched param failed, "
+      _info("sporadic_test: ERROR: pthread_attr_setsched param failed, "
              "ret=%d\n",
              ret);
       ASSERT(false);
@@ -331,7 +332,7 @@
                        (pthread_addr_t)1);
   if (ret != 0)
     {
-      printf("sporadic_test: ERROR: sporadic thread creation failed: %d\n",
+      _info("sporadic_test: ERROR: sporadic thread creation failed: %d\n",
              ret);
       ASSERT(false);
     }
@@ -344,30 +345,30 @@
 
   /* Wait a while then kill the FIFO thread */
 
-  sleep(15);
+  usleep(15);
   ret = pthread_cancel(fifo_thread);
   pthread_join(fifo_thread, &result);
 
   /* Wait a bit longer then kill the nuisance thread */
 
-  sleep(10);
+  usleep(10);
   ret = pthread_cancel(nuisance_thread);
   pthread_join(nuisance_thread, &result);
 
   /* Wait a bit longer then kill the sporadic thread */
 
-  sleep(10);
+  usleep(10);
   ret = pthread_cancel(sporadic_thread);
   pthread_join(sporadic_thread, &result);
   sched_unlock();
 
-  printf("sporadic_test: Done\n");
+  _info("sporadic_test: Done\n");
   sem_destroy(&g_sporadic_sem);
 
   ret = sched_setparam(0, &myparam);
   if (ret != OK)
     {
-      printf("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
+      _info("sporadic_test: ERROR: sched_setparam failed, ret=%d\n", ret);
       ASSERT(false);
     }
 }
diff -Naur apps-12.8.0/testing/ostest/suspend.c apps/testing/ostest/suspend.c
--- apps-12.8.0/testing/ostest/suspend.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/suspend.c	2025-11-04 11:04:41.018339474 +0200
@@ -34,6 +34,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <sys/types.h>
 #include <unistd.h>
 
@@ -51,12 +52,12 @@
 
 static int victim_main(int argc, char *argv[])
 {
-  printf("victim_main: Victim started\n");
+  _info("victim_main: Victim started\n");
 
   for (; ; )
     {
-      sleep(3);
-      printf("victim_main: Wasting time\n");
+      usleep(3);
+      _info("victim_main: Wasting time\n");
       FFLUSH();
     }
 
@@ -71,11 +72,11 @@
 
   /* Start victim thread  */
 
-  printf("suspend_test: Starting victim task\n");
+  _info("suspend_test: Starting victim task\n");
   ret = sched_getparam (0, &param);
   if (ret < 0)
     {
-      printf("suspend_test: ERROR sched_getparam() failed\n");
+      _info("suspend_test: ERROR sched_getparam() failed\n");
       ASSERT(false);
       param.sched_priority = PTHREAD_DEFAULT_PRIORITY;
     }
@@ -84,64 +85,64 @@
                            STACKSIZE, victim_main, NULL);
   if (victim == ERROR)
     {
-      printf("suspend_test: ERROR failed to start victim_main\n");
+      _info("suspend_test: ERROR failed to start victim_main\n");
       ASSERT(false);
     }
   else
     {
-      printf("suspend_test: Started victim_main pid=%d\n", victim);
+      _info("suspend_test: Started victim_main pid=%d\n", victim);
     }
 
   /* Wait a bit */
 
-  printf("suspend_test:  Is the victim saying anything?\n");
+  _info("suspend_test:  Is the victim saying anything?\n");
   FFLUSH();
-  sleep(10);
+  usleep(10);
 
   /* Then signal the victim thread. */
 
-  printf("suspend_test: Signaling pid=%d with SIGSTOP\n", victim);
+  _info("suspend_test: Signaling pid=%d with SIGSTOP\n", victim);
   ret = kill(victim, SIGSTOP);
   if (ret < 0)
     {
-      printf("suspend_test: ERROR kill() failed\n");
+      _info("suspend_test: ERROR kill() failed\n");
       ASSERT(false);
     }
 
-  printf("suspend_test:  Is the victim still jabbering?\n");
+  _info("suspend_test:  Is the victim still jabbering?\n");
   FFLUSH();
-  sleep(10);
+  usleep(10);
 
-  printf("suspend_test: Signaling pid=%d with SIGCONT\n", victim);
+  _info("suspend_test: Signaling pid=%d with SIGCONT\n", victim);
   ret = kill(victim, SIGCONT);
   if (ret < 0)
     {
-      printf("suspend_test: ERROR kill() failed\n");
+      _info("suspend_test: ERROR kill() failed\n");
       ASSERT(false);
     }
 
-  printf("suspend_test:  The victim should continue the rant.\n");
+  _info("suspend_test:  The victim should continue the rant.\n");
   FFLUSH();
-  sleep(10);
+  usleep(10);
 
-  printf("suspend_test: Signaling pid=%d with SIGKILL\n", victim);
+  _info("suspend_test: Signaling pid=%d with SIGKILL\n", victim);
   ret = kill(victim, SIGKILL);
   if (ret < 0)
     {
-      printf("suspend_test: ERROR kill() failed\n");
+      _info("suspend_test: ERROR kill() failed\n");
       ASSERT(false);
     }
 
   FFLUSH();
-  sleep(1);
+  usleep(1);
   ret = kill(victim, 0);
   if (ret >= 0)
     {
-      printf("suspend_test: ERROR kill() on the dead victim succeeded!\n");
+      _info("suspend_test: ERROR kill() on the dead victim succeeded!\n");
       ASSERT(false);
     }
 
-  printf("suspend_test: done\n");
+  _info("suspend_test: done\n");
   FFLUSH();
 }
 #endif /* !CONFIG_BUILD_KERNEL */
diff -Naur apps-12.8.0/testing/ostest/timedmqueue.c apps/testing/ostest/timedmqueue.c
--- apps-12.8.0/testing/ostest/timedmqueue.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/timedmqueue.c	2025-11-04 11:04:41.007345868 +0200
@@ -34,6 +34,7 @@
 #include <pthread.h>
 #include <sched.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 #include <unistd.h>
 
@@ -92,7 +93,7 @@
   int nerrors = 0;
   int i;
 
-  printf("sender_thread: Starting\n");
+  _info("sender_thread: Starting\n");
 
   /* Fill in attributes for message queue */
 
@@ -114,7 +115,7 @@
   g_send_mqfd = mq_open("timedmq", O_WRONLY | O_CREAT, 0666, &attr);
   if (g_send_mqfd == (mqd_t)-1)
     {
-        printf("sender_thread: ERROR mq_open failed\n");
+        _info("sender_thread: ERROR mq_open failed\n");
         ASSERT(false);
         pthread_exit((pthread_addr_t)1);
     }
@@ -131,11 +132,11 @@
       status = clock_gettime(CLOCK_REALTIME, &ts);
       if (status != 0)
         {
-          printf("sender_thread: ERROR clock_gettime failed\n");
+          _info("sender_thread: ERROR clock_gettime failed\n");
           ASSERT(false);
         }
 
-      ts.tv_sec += 5;
+      ts.tv_nsec += 5;
 
       /* The first TEST_SEND_NMSGS-1 send should succeed.  The last
        * one should fail with errno == ETIMEDOUT
@@ -146,12 +147,12 @@
         {
           if (i == TEST_SEND_NMSGS - 1 && errno == ETIMEDOUT)
             {
-              printf("sender_thread: mq_timedsend %d "
+              _info("sender_thread: mq_timedsend %d "
                      "timed out as expected\n", i);
             }
           else
             {
-              printf("sender_thread: ERROR mq_timedsend "
+              _info("sender_thread: ERROR mq_timedsend "
                      "failure=%d on msg %d\n", errno, i);
               ASSERT(false);
               nerrors++;
@@ -161,13 +162,13 @@
         {
           if (i == TEST_SEND_NMSGS - 1)
             {
-              printf("sender_thread: ERROR mq_timedsend of msg %d\n", i);
+              _info("sender_thread: ERROR mq_timedsend of msg %d\n", i);
               ASSERT(false);
               nerrors++;
             }
           else
             {
-              printf("sender_thread: mq_timedsend succeeded on msg %d\n", i);
+              _info("sender_thread: mq_timedsend succeeded on msg %d\n", i);
             }
         }
     }
@@ -176,7 +177,7 @@
 
   if (mq_close(g_send_mqfd) < 0)
     {
-      printf("sender_thread: ERROR mq_close failed\n");
+      _info("sender_thread: ERROR mq_close failed\n");
       ASSERT(false);
     }
   else
@@ -184,7 +185,7 @@
       g_send_mqfd = 0;
     }
 
-  printf("sender_thread: returning nerrors=%d\n", nerrors);
+  _info("sender_thread: returning nerrors=%d\n", nerrors);
   FFLUSH();
   return (pthread_addr_t)((uintptr_t)nerrors);
 }
@@ -197,7 +198,7 @@
   int nerrors = 0;
   int i;
 
-  printf("receiver_thread: Starting\n");
+  _info("receiver_thread: Starting\n");
 
   /* Fill in attributes for message queue */
 
@@ -219,7 +220,7 @@
   g_recv_mqfd = mq_open("timedmq", O_RDONLY | O_CREAT, 0666, &attr);
   if (g_recv_mqfd == (mqd_t)-1)
     {
-      printf("receiver_thread: ERROR mq_open failed\n");
+      _info("receiver_thread: ERROR mq_open failed\n");
       ASSERT(false);
       pthread_exit((pthread_addr_t)1);
     }
@@ -232,11 +233,11 @@
       int status = clock_gettime(CLOCK_REALTIME, &ts);
       if (status != 0)
         {
-          printf("sender_thread: ERROR clock_gettime failed\n");
+          _info("sender_thread: ERROR clock_gettime failed\n");
           ASSERT(false);
         }
 
-      ts.tv_sec += 5;
+      ts.tv_nsec += 5;
 
       /* The first TEST_SEND_NMSGS-1 send should succeed.  The last
        * one should fail with errno == ETIMEDOUT
@@ -248,12 +249,12 @@
         {
           if (i == TEST_SEND_NMSGS - 1 && errno == ETIMEDOUT)
             {
-              printf("receiver_thread: Receive %d "
+              _info("receiver_thread: Receive %d "
                      "timed out as expected\n", i);
             }
           else
             {
-              printf("receiver_thread: ERROR mq_timedreceive "
+              _info("receiver_thread: ERROR mq_timedreceive "
                      "failure=%d on msg %d\n", errno, i);
               ASSERT(false);
               nerrors++;
@@ -261,7 +262,7 @@
         }
       else if (nbytes != TEST_MSGLEN)
         {
-          printf("receiver_thread: mq_timedreceive return "
+          _info("receiver_thread: mq_timedreceive return "
                  "ERROR bad size %d on msg %d\n", nbytes, i);
           ASSERT(false);
           nerrors++;
@@ -270,36 +271,36 @@
         {
           int j;
 
-          printf("receiver_thread: mq_timedreceive returned "
+          _info("receiver_thread: mq_timedreceive returned "
                  "corrupt message on msg %d\n", i);
-          printf("receiver_thread:  i  Expected Received\n");
+          _info("receiver_thread:  i  Expected Received\n");
 
           for (j = 0; j < TEST_MSGLEN - 1; j++)
             {
               if (isprint(msg_buffer[j]))
                 {
-                 printf("receiver_thread: %2d %02x (%c) %02x (%c)\n",
+                 _info("receiver_thread: %2d %02x (%c) %02x (%c)\n",
                          j, TEST_MESSAGE[j], TEST_MESSAGE[j],
                          msg_buffer[j], msg_buffer[j]);
                 }
               else
                 {
-                  printf("receiver_thread: %2d %02x (%c) %02x\n",
+                  _info("receiver_thread: %2d %02x (%c) %02x\n",
                          j, TEST_MESSAGE[j], TEST_MESSAGE[j], msg_buffer[j]);
                 }
             }
 
-          printf("receiver_thread: %2d 00 %02x\n", j, msg_buffer[j]);
+          _info("receiver_thread: %2d 00 %02x\n", j, msg_buffer[j]);
         }
       else if (i == TEST_SEND_NMSGS - 1)
         {
-          printf("receiver_thread: ERROR mq_timedreceive of msg %d\n", i);
+          _info("receiver_thread: ERROR mq_timedreceive of msg %d\n", i);
           ASSERT(false);
           nerrors++;
         }
       else
         {
-          printf("receiver_thread: mq_timedreceive succeed on msg %d\n", i);
+          _info("receiver_thread: mq_timedreceive succeed on msg %d\n", i);
         }
     }
 
@@ -307,7 +308,7 @@
 
   if (mq_close(g_recv_mqfd) < 0)
     {
-      printf("receiver_thread: ERROR mq_close failed\n");
+      _info("receiver_thread: ERROR mq_close failed\n");
       ASSERT(false);
       nerrors++;
     }
@@ -316,7 +317,7 @@
       g_recv_mqfd = 0;
     }
 
-  printf("receiver_thread: returning nerrors=%d\n", nerrors);
+  _info("receiver_thread: returning nerrors=%d\n", nerrors);
   FFLUSH();
   pthread_exit((pthread_addr_t)((uintptr_t)nerrors));
   return (pthread_addr_t)((uintptr_t)nerrors);
@@ -332,11 +333,11 @@
 
   /* Start the sending thread at the default priority */
 
-  printf("timedmqueue_test: Starting sender\n");
+  _info("timedmqueue_test: Starting sender\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("timedmqueue_test: ERROR pthread_attr_init failed, status=%d\n",
+      _info("timedmqueue_test: ERROR pthread_attr_init failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -344,7 +345,7 @@
   status = pthread_attr_setstacksize(&attr, STACKSIZE);
   if (status != 0)
     {
-      printf("timedmqueue_test: ERROR pthread_attr_setstacksize failed, "
+      _info("timedmqueue_test: ERROR pthread_attr_setstacksize failed, "
              "status=%d\n", status);
       ASSERT(false);
     }
@@ -352,29 +353,29 @@
   status = pthread_create(&sender, &attr, sender_thread, NULL);
   if (status != 0)
     {
-      printf("timedmqueue_test: ERROR pthread_create failed, status=%d\n",
+      _info("timedmqueue_test: ERROR pthread_create failed, status=%d\n",
              status);
       ASSERT(false);
     }
 
   /* Wait for the sending thread to complete */
 
-  printf("timedmqueue_test: Waiting for sender to complete\n");
+  _info("timedmqueue_test: Waiting for sender to complete\n");
   pthread_join(sender, &result);
   if (result != NULL)
     {
-      printf("timedmqueue_test: ERROR sender thread exited with %d errors\n",
+      _info("timedmqueue_test: ERROR sender thread exited with %d errors\n",
              (int)((intptr_t)result));
       ASSERT(false);
     }
 
   /* Start the receiving thread at the default priority */
 
-  printf("timedmqueue_test: Starting receiver\n");
+  _info("timedmqueue_test: Starting receiver\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("timedmqueue_test: ERROR pthread_attr_init failed, status=%d\n",
+      _info("timedmqueue_test: ERROR pthread_attr_init failed, status=%d\n",
              status);
       ASSERT(false);
     }
@@ -382,7 +383,7 @@
   status = pthread_attr_setstacksize(&attr, STACKSIZE);
   if (status != 0)
     {
-      printf("timedmqueue_test: ERROR pthread_attr_setstacksize failed, "
+      _info("timedmqueue_test: ERROR pthread_attr_setstacksize failed, "
              "status=%d\n", status);
       ASSERT(false);
     }
@@ -390,18 +391,18 @@
   status = pthread_create(&receiver, &attr, receiver_thread, NULL);
   if (status != 0)
     {
-      printf("timedmqueue_test: ERROR pthread_create failed, status=%d\n",
+      _info("timedmqueue_test: ERROR pthread_create failed, status=%d\n",
              status);
       ASSERT(false);
     }
 
   /* Wait for the receiving thread to complete */
 
-  printf("timedmqueue_test: Waiting for receiver to complete\n");
+  _info("timedmqueue_test: Waiting for receiver to complete\n");
   pthread_join(receiver, &result);
   if (result != NULL)
     {
-      printf("timedmqueue_test: ERROR receiver thread exited "
+      _info("timedmqueue_test: ERROR receiver thread exited "
              "with %d errors\n", (int)((intptr_t)result));
       ASSERT(false);
     }
@@ -412,22 +413,22 @@
 
   if (g_send_mqfd)
     {
-      printf("timedmqueue_test: ERROR send mqd_t left open\n");
+      _info("timedmqueue_test: ERROR send mqd_t left open\n");
       ASSERT(false);
       if (mq_close(g_send_mqfd) < 0)
         {
-          printf("timedmqueue_test: ERROR mq_close failed\n");
+          _info("timedmqueue_test: ERROR mq_close failed\n");
           ASSERT(false);
         }
     }
 
   if (g_recv_mqfd)
     {
-      printf("timedmqueue_test: ERROR receive mqd_t left open\n");
+      _info("timedmqueue_test: ERROR receive mqd_t left open\n");
       ASSERT(false);
       if (mq_close(g_recv_mqfd) < 0)
         {
-          printf("timedmqueue_test: ERROR mq_close failed\n");
+          _info("timedmqueue_test: ERROR mq_close failed\n");
           ASSERT(false);
         }
     }
@@ -436,9 +437,9 @@
 
   if (mq_unlink("timedmq") < 0)
     {
-      printf("timedmqueue_test: ERROR mq_unlink failed\n");
+      _info("timedmqueue_test: ERROR mq_unlink failed\n");
       ASSERT(false);
     }
 
-  printf("timedmqueue_test: Test complete\n");
+  _info("timedmqueue_test: Test complete\n");
 }
diff -Naur apps-12.8.0/testing/ostest/timedmutex.c apps/testing/ostest/timedmutex.c
--- apps-12.8.0/testing/ostest/timedmutex.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/timedmutex.c	2025-11-04 11:04:41.029333081 +0200
@@ -29,6 +29,7 @@
 #include <pthread.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <time.h>
 #include <unistd.h>
 
@@ -55,12 +56,12 @@
   struct timespec ts;
   int status;
 
-  printf("pthread:  Started\n");
+  _info("pthread:  Started\n");
   g_running = true;
 
   for (; ; )
     {
-      printf("pthread:  Waiting for lock or timeout\n");
+      _info("pthread:  Waiting for lock or timeout\n");
 
       /* Get the current time */
 
@@ -79,7 +80,7 @@
        * blocked for two seconds here!)
        */
 
-      ts.tv_sec += 2;
+      ts.tv_nsec += 2;
 
       /* Now wait until either we get the lock or until the timeout occurs */
 
@@ -88,7 +89,7 @@
         {
           if (status == ETIMEDOUT)
             {
-              printf("pthread:  Got the timeout.  Terminating\n");
+              _info("pthread:  Got the timeout.  Terminating\n");
             }
           else
             {
@@ -102,12 +103,12 @@
           break;
         }
 
-      printf("pthread:  Got the lock\n");
+      _info("pthread:  Got the lock\n");
 
       /* Release the lock and wait a bit in case the main thread wants it. */
 
       pthread_mutex_unlock(&g_mutex);
-      usleep(500 * 1000);
+      usleep(1000);
     }
 
   g_running = false;
@@ -128,7 +129,7 @@
 
   /* Initialize the mutex */
 
-  printf("mutex_test: Initializing mutex\n");
+  _info("mutex_test: Initializing mutex\n");
   pthread_mutex_init(&g_mutex, NULL);
 
   /* Lock the mutex */
@@ -143,7 +144,7 @@
 
   /* Start a thread */
 
-  printf("mutex_test: Starting thread\n");
+  _info("mutex_test: Starting thread\n");
 #ifdef SDCC
   pthread_attr_init(&attr);
   status = pthread_create(&thread, &attr, thread_func, (pthread_addr_t)0);
@@ -159,18 +160,18 @@
 
   /* Wait a bit to assure that the thread gets a chance to start */
 
-  usleep(500 * 1000);
+  usleep(1000);
 
   /* Then unlock the mutex.  This should wake up the pthread. */
 
-  printf("mutex_test: Unlocking\n");
+  _info("mutex_test: Unlocking\n");
   pthread_mutex_unlock(&g_mutex);
 
   /* Wait a bit to assure that the thread gets a chance to lock the mutex at
    * least once (it may probably loop and retake the mutex several times)
    */
 
-  usleep(500 * 1000);
+  usleep(1000);
 
   /* The re-lock the mutex.  The pthread should now be waiting for the lock
    * or a timeout.
@@ -188,7 +189,7 @@
    * time, the pthread should no longer be running.
    */
 
-  sleep(4);
+  usleep(1000);
 
   /* The pthread should no longer be running and it should have terminated
    * because of EAGAIN.
@@ -207,7 +208,7 @@
     }
   else
     {
-      printf("mutex_test: PASSED\n");
+      _info("mutex_test: PASSED\n");
     }
 
   /* Let's reap any join droppings left from the pthread */
diff -Naur apps-12.8.0/testing/ostest/timedwait.c apps/testing/ostest/timedwait.c
--- apps-12.8.0/testing/ostest/timedwait.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/timedwait.c	2025-11-04 11:04:41.016340637 +0200
@@ -29,6 +29,7 @@
 #include <pthread.h>
 #include <sched.h>
 #include <stdio.h>
+#include <debug.h>
 #include <time.h>
 #include <unistd.h>
 
@@ -56,25 +57,25 @@
 
   /* Take the mutex */
 
-  printf("thread_waiter: Taking mutex\n");
+  _info("thread_waiter: Taking mutex\n");
   status = pthread_mutex_lock(&mutex);
   if (status != 0)
     {
-      printf("thread_waiter: ERROR pthread_mutex_lock failed, status=%d\n",
+      _info("thread_waiter: ERROR pthread_mutex_lock failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
-  printf("thread_waiter: Starting 5 second wait for condition\n");
+  _info("thread_waiter: Starting 5 second wait for condition\n");
 
   status = clock_gettime(CLOCK_REALTIME, &ts);
   if (status != 0)
     {
-      printf("thread_waiter: ERROR clock_gettime failed\n");
+      _info("thread_waiter: ERROR clock_gettime failed\n");
       ASSERT(false);
     }
 
-  ts.tv_sec += 5;
+  ts.tv_nsec += 1000000;
 
   /* The wait -- no-one is ever going to awaken us */
 
@@ -83,18 +84,18 @@
     {
       if (status == ETIMEDOUT)
         {
-          printf("thread_waiter: pthread_cond_timedwait timed out\n");
+          _info("thread_waiter: pthread_cond_timedwait timed out\n");
         }
       else
         {
-          printf("thread_waiter: "
+          _info("thread_waiter: "
                  "ERROR pthread_cond_timedwait failed, status=%d\n", status);
           ASSERT(false);
         }
     }
   else
     {
-      printf("thread_waiter: ERROR "
+      _info("thread_waiter: ERROR "
              "pthread_cond_timedwait returned without timeout, status=%d\n",
               status);
       ASSERT(false);
@@ -102,16 +103,16 @@
 
   /* Release the mutex */
 
-  printf("thread_waiter: Releasing mutex\n");
+  _info("thread_waiter: Releasing mutex\n");
   status = pthread_mutex_unlock(&mutex);
   if (status != 0)
     {
-      printf("thread_waiter: ERROR pthread_mutex_unlock failed, status=%d\n",
+      _info("thread_waiter: ERROR pthread_mutex_unlock failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
-  printf("thread_waiter: Exit with status 0x12345678\n");
+  _info("thread_waiter: Exit with status 0x12345678\n");
   pthread_exit((pthread_addr_t)0x12345678);
   return NULL;
 }
@@ -131,33 +132,33 @@
 
   /* Initialize the mutex */
 
-  printf("thread_waiter: Initializing mutex\n");
+  _info("thread_waiter: Initializing mutex\n");
   status = pthread_mutex_init(&mutex, NULL);
   if (status != 0)
     {
-      printf("timedwait_test: ERROR pthread_mutex_init failed, status=%d\n",
+      _info("timedwait_test: ERROR pthread_mutex_init failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
   /* Initialize the condition variable */
 
-  printf("timedwait_test: Initializing cond\n");
+  _info("timedwait_test: Initializing cond\n");
   status = pthread_cond_init(&cond, NULL);
   if (status != 0)
     {
-      printf("timedwait_test: ERROR pthread_condinit failed, status=%d\n",
+      _info("timedwait_test: ERROR pthread_condinit failed, status=%d\n",
               status);
       ASSERT(false);
     }
 
   /* Start the waiter thread at higher priority */
 
-  printf("timedwait_test: Starting waiter\n");
+  _info("timedwait_test: Starting waiter\n");
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("timedwait_test: pthread_attr_init failed, status=%d\n",
+      _info("timedwait_test: pthread_attr_init failed, status=%d\n",
               status);
     }
 
@@ -165,7 +166,7 @@
   status = sched_getparam (gettid(), &sparam);
   if (status != 0)
     {
-      printf("timedwait_test: sched_getparam failed\n");
+      _info("timedwait_test: sched_getparam failed\n");
       sparam.sched_priority = PTHREAD_DEFAULT_PRIORITY;
     }
 
@@ -173,33 +174,33 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != OK)
     {
-      printf("timedwait_test: "
+      _info("timedwait_test: "
              "pthread_attr_setschedparam failed, status=%d\n",
               status);
     }
   else
     {
-      printf("timedwait_test: Set thread 2 priority to %d\n",
+      _info("timedwait_test: Set thread 2 priority to %d\n",
               sparam.sched_priority);
     }
 
   status = pthread_create(&waiter, &attr, thread_waiter, NULL);
   if (status != 0)
     {
-      printf("timedwait_test: pthread_create failed, status=%d\n", status);
+      _info("timedwait_test: pthread_create failed, status=%d\n", status);
     }
 
-  printf("timedwait_test: Joining\n");
+  _info("timedwait_test: Joining\n");
   FFLUSH();
   status = pthread_join(waiter, &result);
   if (status != 0)
     {
-      printf("timedwait_test: ERROR pthread_join failed, status=%d\n",
+      _info("timedwait_test: ERROR pthread_join failed, status=%d\n",
               status);
       ASSERT(false);
     }
   else
     {
-      printf("timedwait_test: waiter exited with result=%p\n", result);
+      _info("timedwait_test: waiter exited with result=%p\n", result);
     }
 }
diff -Naur apps-12.8.0/testing/ostest/tls.c apps/testing/ostest/tls.c
--- apps-12.8.0/testing/ostest/tls.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/tls.c	2025-11-04 11:04:41.005347030 +0200
@@ -31,6 +31,7 @@
 #include <stdbool.h>
 #include <stdint.h>
 #include <stdio.h>
+#include <debug.h>
 #include <string.h>
 
 #include "ostest.h"
@@ -84,7 +85,7 @@
     {
       if (info->tl_elem[i] != value)
         {
-          printf("tls: ERROR Element %d: Set %lx / read %lx\n",
+          _info("tls: ERROR Element %d: Set %lx / read %lx\n",
                  i, (unsigned long)value,
                  (unsigned long)info->tl_elem[i]);
           ASSERT(false);
@@ -100,7 +101,7 @@
   set_tls_info(value);
   if (!verify_tls_info(value))
     {
-      printf("tls: Successfully set %lx\n", (unsigned long)value);
+      _info("tls: Successfully set %lx\n", (unsigned long)value);
     }
 }
 
diff -Naur apps-12.8.0/testing/ostest/vfork.c apps/testing/ostest/vfork.c
--- apps-12.8.0/testing/ostest/vfork.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/vfork.c	2025-11-04 11:04:41.009344705 +0200
@@ -30,6 +30,7 @@
 #include <errno.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <stdlib.h>
 #include <unistd.h>
 
@@ -64,20 +65,20 @@
     }
   else if (pid < 0)
     {
-      printf("vfork_test: ERROR vfork() failed: %d\n", errno);
+      _info("vfork_test: ERROR vfork() failed: %d\n", errno);
       ASSERT(false);
       return -1;
     }
   else
     {
-      sleep(1);
+      usleep(1);
       if (g_vforkchild)
         {
-          printf("vfork_test: Child %d ran successfully\n", pid);
+          _info("vfork_test: Child %d ran successfully\n", pid);
         }
       else
         {
-          printf("vfork_test: ERROR Child %d did not run\n", pid);
+          _info("vfork_test: ERROR Child %d did not run\n", pid);
           ASSERT(false);
           return -1;
         }
diff -Naur apps-12.8.0/testing/ostest/waitpid.c apps/testing/ostest/waitpid.c
--- apps-12.8.0/testing/ostest/waitpid.c	2025-01-24 11:45:01.810432963 +0200
+++ apps/testing/ostest/waitpid.c	2025-11-04 11:04:40.989356536 +0200
@@ -32,6 +32,7 @@
 #include <signal.h>
 #include <stdbool.h>
 #include <stdio.h>
+#include <debug.h>
 #include <sys/wait.h>
 #include <unistd.h>
 
@@ -65,9 +66,9 @@
 {
   pid_t me = getpid();
 
-  printf("waitpid_main: PID %d Started\n", me);
-  sleep(3);
-  printf("waitpid_main: PID %d exitting with result=%d\n",
+  _info("waitpid_main: PID %d Started\n", me);
+  usleep(3);
+  _info("waitpid_main: PID %d exitting with result=%d\n",
           me, RETURN_STATUS);
   return RETURN_STATUS;
 }
@@ -82,13 +83,13 @@
       ret = task_create("waitpid", PRIORITY, STACKSIZE, waitpid_main, NULL);
       if (ret < 0)
         {
-          printf("waitpid_start_child: "
+          _info("waitpid_start_child: "
                  "ERROR Failed to start waitpid_main\n");
           ASSERT(false);
         }
       else
         {
-          printf("waitpid_start_child: "
+          _info("waitpid_start_child: "
                  "Started waitpid_main at PID=%d\n", ret);
         }
 
@@ -118,12 +119,12 @@
 
   if (pid < 0)
     {
-      printf("waitpid_last: ERROR: Nothing to wait for\n");
+      _info("waitpid_last: ERROR: Nothing to wait for\n");
       ASSERT(false);
       return;
     }
 
-  printf("waitpid_last: Waiting for PID=%d with waitpid()\n",
+  _info("waitpid_last: Waiting for PID=%d with waitpid()\n",
          g_waitpids[NCHILDREN - 1]);
 
   ret = waitpid(g_waitpids[NCHILDREN - 1], &stat_loc, 0);
@@ -139,22 +140,22 @@
 
       if (errcode == ECHILD)
         {
-          printf("waitpid_last: PASS: "
+          _info("waitpid_last: PASS: "
                  "PID %d waitpid failed with ECHILD.  That may be\n",
                  g_waitpids[NCHILDREN - 1]);
-          printf("              acceptable "
+          _info("              acceptable "
                  "because child status is disabled on this thread.\n");
         }
       else
         {
-          printf("waitpid_last: ERROR: PID %d waitpid failed: %d\n",
+          _info("waitpid_last: ERROR: PID %d waitpid failed: %d\n",
                  g_waitpids[NCHILDREN - 1], errcode);
           ASSERT(false);
         }
     }
   else if (WEXITSTATUS(stat_loc) != RETURN_STATUS)
     {
-      printf("waitpid_last: ERROR: "
+      _info("waitpid_last: ERROR: "
              "PID %d return status is %d, expected %d\n",
              g_waitpids[NCHILDREN - 1],
              WEXITSTATUS(stat_loc),
@@ -163,7 +164,7 @@
     }
   else
     {
-      printf("waitpid_last: PASS: "
+      _info("waitpid_last: PASS: "
              "PID %d waitpid succeeded with stat_loc=%04x\n",
              g_waitpids[NCHILDREN - 1], stat_loc);
     }
@@ -183,10 +184,10 @@
 
   /* Start the children and wait for first one to complete */
 
-  printf("\nTest waitpid()\n");
+  _info("\nTest waitpid()\n");
   waitpid_start_children();
 
-  printf("waitpid_test: Waiting for PID=%d with waitpid()\n",
+  _info("waitpid_test: Waiting for PID=%d with waitpid()\n",
           g_waitpids[0]);
   ret = (int)waitpid(g_waitpids[0], &stat_loc, 0);
   if (ret < 0)
@@ -201,35 +202,35 @@
 
       if (errcode == ECHILD)
         {
-          printf("waitpid_test: PASS: "
+          _info("waitpid_test: PASS: "
                  "PID %d waitpid failed with ECHILD.  That may be\n",
                  g_waitpids[NCHILDREN - 1]);
-          printf("              acceptable "
+          _info("              acceptable "
                  "because child status is disabled on this thread.\n");
         }
       else
         {
-          printf("waitpid_test: ERROR: PID %d waitpid failed: %d\n",
+          _info("waitpid_test: ERROR: PID %d waitpid failed: %d\n",
                  g_waitpids[0], errcode);
           ASSERT(false);
         }
     }
   else if (ret != g_waitpids[0])
     {
-      printf("waitpid_test: ERROR: PID %d wait returned PID %d\n",
+      _info("waitpid_test: ERROR: PID %d wait returned PID %d\n",
              g_waitpids[0], ret);
       ASSERT(false);
     }
   else if (WEXITSTATUS(stat_loc) != RETURN_STATUS)
     {
-      printf("waitpid_test: ERROR: "
+      _info("waitpid_test: ERROR: "
              "PID %d return status is %d, expected %d\n",
              g_waitpids[0], WEXITSTATUS(stat_loc), RETURN_STATUS);
       ASSERT(false);
     }
   else
     {
-      printf("waitpid_test: "
+      _info("waitpid_test: "
              "PID %d waitpid succeeded with stat_loc=%04x\n",
              g_waitpids[0], stat_loc);
     }
@@ -237,15 +238,15 @@
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 
 #ifdef CONFIG_SCHED_HAVE_PARENT
   /* Start the children and wait for first one to complete */
 
-  printf("\nTest waitid(P_PID)\n");
+  _info("\nTest waitid(P_PID)\n");
   waitpid_start_children();
 
-  printf("waitpid_test: Waiting for PID=%d with waitid()\n", g_waitpids[0]);
+  _info("waitpid_test: Waiting for PID=%d with waitid()\n", g_waitpids[0]);
   ret = waitid(P_PID, (id_t)g_waitpids[0], &info, WEXITED);
   if (ret < 0)
     {
@@ -259,49 +260,49 @@
 
       if (errcode == ECHILD)
         {
-          printf("waitpid_test: PASS: "
+          _info("waitpid_test: PASS: "
                  "PID %d waitpid failed with ECHILD.  That may be\n",
                  g_waitpids[NCHILDREN - 1]);
-          printf("              acceptable "
+          _info("              acceptable "
                  "because child status is disabled on this thread.\n");
         }
       else
         {
-          printf("waitpid_test: ERROR: PID %d waitid failed: %d\n",
+          _info("waitpid_test: ERROR: PID %d waitid failed: %d\n",
                  g_waitpids[0], errcode);
           ASSERT(false);
         }
     }
   else if (info.si_pid != g_waitpids[0])
     {
-      printf("waitpid_test: ERROR: PID %d waitid returned PID %d\n",
+      _info("waitpid_test: ERROR: PID %d waitid returned PID %d\n",
              g_waitpids[0], info.si_pid);
       ASSERT(false);
     }
   else if (info.si_status != RETURN_STATUS)
     {
-      printf("waitpid_test: ERROR: "
+      _info("waitpid_test: ERROR: "
              "PID %d return status is %d, expected %d\n",
              info.si_pid, info.si_status, RETURN_STATUS);
       ASSERT(false);
     }
   else
     {
-      printf("waitpid_test: waitid PID %d succeeded with si_status=%d\n",
+      _info("waitpid_test: waitid PID %d succeeded with si_status=%d\n",
              info.si_pid, info.si_status);
     }
 
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 
   /* Start the children and wait for any one to complete */
 
-  printf("\nTest waitid(P_ALL)\n");
+  _info("\nTest waitid(P_ALL)\n");
   waitpid_start_children();
 
-  printf("waitpid_test: Waiting for any child with waitid()\n");
+  _info("waitpid_test: Waiting for any child with waitid()\n");
   ret = waitid(P_ALL, 0, &info, WEXITED);
   if (ret < 0)
     {
@@ -315,42 +316,42 @@
 
       if (errcode == ECHILD)
         {
-          printf("waitpid_test: PASS: "
+          _info("waitpid_test: PASS: "
                  "PID %d waitpid failed with ECHILD.  That may be\n",
                  g_waitpids[NCHILDREN - 1]);
-          printf("              acceptable "
+          _info("              acceptable "
                  "because child status is disabled on this thread.\n");
         }
       else
         {
-          printf("waitpid_test: ERROR: waitid failed: %d\n", errcode);
+          _info("waitpid_test: ERROR: waitid failed: %d\n", errcode);
           ASSERT(false);
         }
     }
   else if (info.si_status != RETURN_STATUS)
     {
-      printf("waitpid_test: ERROR: "
+      _info("waitpid_test: ERROR: "
              "PID %d return status is %d, expected %d\n",
              info.si_pid, info.si_status, RETURN_STATUS);
       ASSERT(false);
     }
   else
     {
-      printf("waitpid_test: PID %d waitid succeeded with si_status=%d\n",
+      _info("waitpid_test: PID %d waitid succeeded with si_status=%d\n",
              info.si_pid, info.si_status);
     }
 
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 
   /* Start the children and wait for first one to complete */
 
-  printf("\nTest wait()\n");
+  _info("\nTest wait()\n");
   waitpid_start_children();
 
-  printf("waitpid_test: Waiting for any child with wait()\n");
+  _info("waitpid_test: Waiting for any child with wait()\n");
   ret = (int)wait(&stat_loc);
   if (ret < 0)
     {
@@ -364,35 +365,35 @@
 
       if (errcode == ECHILD)
         {
-          printf("waitpid_test: PASS: "
+          _info("waitpid_test: PASS: "
                  "PID %d waitpid failed with ECHILD.  That may be\n",
                  g_waitpids[NCHILDREN - 1]);
-          printf("              acceptable "
+          _info("              acceptable "
                  "because child status is disabled on this thread.\n");
         }
       else
         {
-          printf("waitpid_test: ERROR: wait failed: %d\n", errcode);
+          _info("waitpid_test: ERROR: wait failed: %d\n", errcode);
           ASSERT(false);
         }
     }
   else if (WEXITSTATUS(stat_loc) != RETURN_STATUS)
     {
-      printf("waitpid_test: ERROR: "
+      _info("waitpid_test: ERROR: "
              "PID %d return status is %d, expected %d\n",
              ret, WEXITSTATUS(stat_loc), RETURN_STATUS);
       ASSERT(false);
     }
   else
     {
-      printf("waitpid_test: PID %d wait succeeded with stat_loc=%04x\n",
+      _info("waitpid_test: PID %d wait succeeded with stat_loc=%04x\n",
              ret, stat_loc);
     }
 
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 #endif
 
   return 0;
diff -Naur apps-12.8.0/testing/ostest/wdog.c apps/testing/ostest/wdog.c
--- apps-12.8.0/testing/ostest/wdog.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/wdog.c	2025-11-04 11:04:40.988357134 +0200
@@ -31,6 +31,7 @@
 #include <assert.h>
 #include <pthread.h>
 #include <stdio.h>
+#include <debug.h>
 #include <syslog.h>
 #include <unistd.h>
 
@@ -358,7 +359,7 @@
       0
     };
 
-  printf("wdog_test start...\n");
+  _info("wdog_test start...\n");
 
   wdtest_assert(pthread_attr_init(&attr) == 0);
 
@@ -378,6 +379,6 @@
 
   wdtest_assert(pthread_attr_destroy(&attr) == 0);
 
-  printf("wdog_test end...\n");
+  _info("wdog_test end...\n");
 }
 #endif
diff -Naur apps-12.8.0/testing/ostest/wqueue.c apps/testing/ostest/wqueue.c
--- apps-12.8.0/testing/ostest/wqueue.c	2025-01-24 11:45:01.811432899 +0200
+++ apps/testing/ostest/wqueue.c	2025-11-04 11:04:41.003348192 +0200
@@ -31,6 +31,7 @@
 #include <sched.h>
 #include <semaphore.h>
 #include <stdio.h>
+#include <debug.h>
 #include <unistd.h>
 
 #include <nuttx/wqueue.h>
@@ -114,7 +115,7 @@
   sem_init(&call_sem, 0, 0);
   memset(&work, 0, sizeof(work));
 
-  /* Queue sleep worker. */
+  /* Queue usleep worker. */
 
   if (val[1] != NULL)
     {
@@ -140,7 +141,7 @@
         }
     }
 
-  /* Wait for sleep worker to run. */
+  /* Wait for usleep worker to run. */
 
   sem_wait(&sem);
 
@@ -154,7 +155,7 @@
   while (call_count != VERIFY_COUNT);
 
   sem_getvalue(&call_sem, &call_count);
-  printf("wqueue_test: call = %d, expect = %d\n", call_count, VERIFY_COUNT);
+  _info("wqueue_test: call = %d, expect = %d\n", call_count, VERIFY_COUNT);
 
   for (i = 0; i < VERIFY_COUNT; i++)
     {
@@ -177,7 +178,7 @@
   status = pthread_attr_init(&attr);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_attr_init failed, status=%d\n", status);
+      _info("wqueue_test: pthread_attr_init failed, status=%d\n", status);
     }
 
   memset(&sparam, 0, sizeof(sparam));
@@ -188,7 +189,7 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_attr_setschedparam failed for tester, "
+      _info("wqueue_test: pthread_attr_setschedparam failed for tester, "
              "status=%d\n", status);
     }
 
@@ -198,14 +199,14 @@
   status = pthread_create(&thread, &attr, tester, val);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_create failed for tester, "
+      _info("wqueue_test: pthread_create failed for tester, "
              "status=%d\n", status);
     }
 
   status = pthread_join(thread, NULL);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_join failed for tester, "
+      _info("wqueue_test: pthread_join failed for tester, "
              "status=%d\n", status);
     }
 
@@ -215,7 +216,7 @@
   status = pthread_attr_setschedparam(&attr, &sparam);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_attr_setschedparam failed for verifier, "
+      _info("wqueue_test: pthread_attr_setschedparam failed for verifier, "
              "status=%d\n", status);
     }
 
@@ -223,7 +224,7 @@
         VERIFY_COUNT * sizeof(struct work_s) + CONFIG_PTHREAD_STACK_DEFAULT);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_attr_setstacksize failed for verifier, "
+      _info("wqueue_test: pthread_attr_setstacksize failed for verifier, "
              "status=%d\n", status);
     }
 
@@ -232,14 +233,14 @@
   status = pthread_create(&thread, &attr, verifier, val);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_create failed for verifier, "
+      _info("wqueue_test: pthread_create failed for verifier, "
              "status=%d\n", status);
     }
 
   status = pthread_join(thread, NULL);
   if (status != 0)
     {
-      printf("wqueue_test: pthread_join failed for verifier, "
+      _info("wqueue_test: pthread_join failed for verifier, "
              "status=%d\n", status);
     }
 }
@@ -276,25 +277,25 @@
   int i;
 
 #ifdef CONFIG_SCHED_HPWORK
-  printf("wqueue_test: HPWORK\n");
+  _info("wqueue_test: HPWORK\n");
   wqueue_priority_test(HPWORK, NULL, CONFIG_SCHED_HPWORKPRIORITY);
-  printf("wqueue_test: HPWORK done\n");
+  _info("wqueue_test: HPWORK done\n");
 #endif
 
 #ifdef CONFIG_SCHED_LPWORK
-  printf("wqueue_test: LPWORK\n");
+  _info("wqueue_test: LPWORK\n");
   wqueue_priority_test(LPWORK, NULL, CONFIG_SCHED_LPWORKPRIORITY);
-  printf("wqueue_test: HPWORK done\n");
+  _info("wqueue_test: HPWORK done\n");
 #endif
 
   for (i = 1; i < 3; i++)
     {
-      printf("wqueue_test: test %d\n", i);
+      _info("wqueue_test: test %d\n", i);
       wq = work_queue_create("test", 100, NULL, 2048, i);
       DEBUGASSERT(wq != NULL);
       wqueue_priority_test(0, wq, 100);
       work_queue_free(wq);
-      printf("wqueue_test: test %d done\n", i);
+      _info("wqueue_test: test %d done\n", i);
     }
 }
 
diff -Naur apps-12.8.0/testing/smp/dhrystone.h apps/testing/smp/dhrystone.h
--- apps-12.8.0/testing/smp/dhrystone.h	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/dhrystone.h	2025-11-04 11:04:41.212226717 +0200
@@ -0,0 +1,432 @@
+// See LICENSE for license details.
+
+#ifndef _DHRYSTONE_H
+#define _DHRYSTONE_H
+
+/****************** "DHRYSTONE" Benchmark Program ***************************/
+#define Version "C, Version 2.2"
+/*  File:       dhry_1.c (part 2 of 3)
+ *  Author:     Reinhold P. Weicker
+ *              Siemens Nixdorf, Paderborn/Germany
+ *              weicker@specbench.org
+ *  Date:       May 25, 1988
+ *  Modified:	Steven Pemberton, CWI, Amsterdam; Steven.Pemberton@cwi.nl
+ *  Date:       October, 1993; March 1995
+ *              Included both files into one source, that gets compiled
+ *              in two passes. Made program auto-compiling, and auto-running,
+ *              and generally made it much easier to use.
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
+ *              are used for execution time measurement. For measurements
+ *              on other systems, these calls have to be changed.
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *              
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 389-8963 (9-17 EST)               
+ *                      Usenet: ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software used.
+ *      Hardware information includes: Machine type, CPU, type and size
+ *      of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states).
+ *      Software information includes: Compiler (and runtime library)
+ *      manufacturer and version, compilation switches, OS version.
+ *      The Operating System version may give an indication about the compiler;
+ *      Dhrystone itself performs no OS calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ ***************************************************************************
+ *
+ * Defines:     The following "Defines" are possible:
+ *      -DREG          (default: Not defined)
+ *              As an approximation to what an average C programmer
+ *              might do, causes the "register" storage class to be applied
+ *              - for local variables, if they are used (dynamically)
+ *                five or more times
+ *              - for parameters if they are used (dynamically)
+ *                six or more times
+ *              Note that an optimal "register" strategy is
+ *              compiler-dependent, and that "register" declarations
+ *              do not necessarily lead to faster execution.
+ *      -DNOSTRUCTASSIGN        (default: Not defined)
+ *              Define if the C compiler does not support
+ *              assignment of structures.
+ *      -DNOENUMS               (default: Not defined)
+ *              Define if the C compiler does not support
+ *              enumeration types.
+ *      -DTIMES                 (default)
+ *      -DTIME
+ *              The "times" function of UNIX (returning process times)
+ *              or the "time" function (returning wallclock time)
+ *              is used for measurement. 
+ *              For single user machines, "time ()" is adequate. For
+ *              multi-user machines where you cannot get single-user
+ *              access, use the "times ()" function. If you have
+ *              neither, use a stopwatch in the dead of night.
+ *              "printf"s are provided marking the points "Start Timer"
+ *              and "Stop Timer". DO NOT use the UNIX "time(1)"
+ *              command, as this will measure the total time to
+ *              run this program, which will (erroneously) include
+ *              the time to allocate storage (malloc) and to perform
+ *              the initialization.
+ *      -DHZ=nnn
+ *              In Berkeley UNIX, the function "times" returns process
+ *              time in 1/HZ seconds, with HZ = 60 for most systems.
+ *              CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
+ *              A VALUE.
+ *
+ ***************************************************************************
+ *
+ *  History:	Version C/2.1 was made for two reasons:
+ *
+ *	1) There was an obvious need for a common C version of
+ *      Dhrystone, since C is at present the most popular system
+ *      programming language for the class of processors
+ *      (microcomputers, minicomputers) where Dhrystone is used most.
+ *      There should be, as far as possible, only one C version of
+ *      Dhrystone such that results can be compared without
+ *      restrictions. In the past, the C versions distributed
+ *      by Rick Richardson (Version 1.1) and by Reinhold Weicker
+ *      had small (though not significant) differences.
+ *
+ *      2) As far as it is possible without changes to the Dhrystone
+ *      statistics, optimizing compilers should be prevented from
+ *      removing significant statements.
+ *
+ *      This C version has been developed in cooperation with
+ *      Rick Richardson (Tinton Falls, NJ), it incorporates many
+ *      ideas from the "Version 1.1" distributed previously by
+ *      him over the UNIX network Usenet.
+ *      I also thank Chaim Benedelac (National Semiconductor),
+ *      David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
+ *      Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
+ *      for their help with comments on earlier versions of the
+ *      benchmark.
+ *
+ *  Changes:    In the initialization part, this version follows mostly
+ *      Rick Richardson's version distributed via Usenet, not the
+ *      version distributed earlier via floppy disk by Reinhold Weicker.
+ *      As a concession to older compilers, names have been made
+ *      unique within the first 8 characters.
+ *      Inside the measurement loop, this version follows the
+ *      version previously distributed by Reinhold Weicker.
+ *
+ *      At several places in the benchmark, code has been added,
+ *      but within the measurement loop only in branches that 
+ *      are not executed. The intention is that optimizing compilers
+ *      should be prevented from moving code out of the measurement
+ *      loop, or from removing code altogether. Since the statements
+ *      that are executed within the measurement loop have NOT been
+ *      changed, the numbers defining the "Dhrystone distribution"
+ *      (distribution of statements, operand types and locality)
+ *      still hold. Except for sophisticated optimizing compilers,
+ *      execution times for this version should be the same as
+ *      for previous versions.
+ *
+ *      Since it has proven difficult to subtract the time for the
+ *      measurement loop overhead in a correct way, the loop check
+ *      has been made a part of the benchmark. This does have
+ *      an impact - though a very minor one - on the distribution
+ *      statistics which have been updated for this version.
+ *
+ *      All changes within the measurement loop are described
+ *      and discussed in the companion paper "Rationale for
+ *      Dhrystone version 2".
+ *
+ *      Because of the self-imposed limitation that the order and
+ *      distribution of the executed statements should not be
+ *      changed, there are still cases where optimizing compilers
+ *      may not generate code for some statements. To a certain
+ *      degree, this is unavoidable for small synthetic benchmarks.
+ *      Users of the benchmark are advised to check code listings
+ *      whether code is generated for all statements of Dhrystone.
+ *
+ *      Version 2.1 is identical to version 2.0 distributed via
+ *      the UNIX network Usenet in March 1988 except that it corrects
+ *      some minor deficiencies that were found by users of version 2.0.
+ *      The only change within the measurement loop is that a
+ *      non-executed "else" part was added to the "if" statement in
+ *      Func_3, and a non-executed "else" part removed from Proc_3.
+ *
+ * Version C/2.2, Steven Pemberton, October 1993
+ *	Functionally, identical to version 2.2; the changes are in
+ *	how you compile and use it:
+ *	- Everything is in one file now, but compiled in 2 passes
+ *	- Compile (and run) by running the file through the shell: 'sh dhry.c"
+ *	- Uses the system definition of HZ if one can be found
+ *	- HZ must be defined, otherwise it won't compile (no defaults here)
+ *	- The (uninteresting) output is printed to stderr (dhry2 > /dev/null)
+ *	- The number of loops is passed as a parameter, rather than read
+ *	  (dhry2 500000)
+ *	- If the number of loops is insufficient to get a good result,
+ *	  it repeats it with loops*10 until it is enough (rather than just
+ *	  stopping)
+ *	- Output says which sort of clock it is using, and the HZ value
+ *	- You can use -DREG instead of the -DREG=register of previous versions
+ *	- Some stylistic cleanups.
+ *		
+ ***************************************************************************
+ *
+ *  Compilation model and measurement (IMPORTANT):
+ *
+ *  The following "ground rules" apply for measurements:
+ *  - Separate compilation
+ *  - No procedure merging
+ *  - Otherwise, compiler optimizations are allowed but should be indicated
+ *  - Default results are those without register declarations
+ *  See the companion paper "Rationale for Dhrystone Version 2" for a more
+ *  detailed discussion of these ground rules.
+ *
+ *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
+ *  models ("small", "medium", "large" etc.) should be given if possible,
+ *  together with a definition of these models for the compiler system used.
+ *
+ **************************************************************************
+ *
+ *  Dhrystone (C version) statistics:
+ *
+ *  [Comment from the first distribution, updated for version 2.
+ *   Note that because of language differences, the numbers are slightly
+ *   different from the Ada version.]
+ *
+ *  The following program contains statements of a high level programming
+ *  language (here: C) in a distribution considered representative:           
+ *
+ *    assignments                  52 (51.0 %)
+ *    control statements           33 (32.4 %)
+ *    procedure, function calls    17 (16.7 %)
+ *
+ *  103 statements are dynamically executed. The program is balanced with
+ *  respect to the three aspects:                                             
+ *
+ *    - statement type
+ *    - operand type
+ *    - operand locality
+ *         operand global, local, parameter, or constant.                     
+ *
+ *  The combination of these three aspects is balanced only approximately.    
+ *
+ *  1. Statement Type:                                                        
+ *  -----------------             number
+ *
+ *     V1 = V2                     9
+ *       (incl. V1 = F(..)
+ *     V = Constant               12
+ *     Assignment,                 7
+ *       with array element
+ *     Assignment,                 6
+ *       with record component
+ *                                --
+ *                                34       34
+ *
+ *     X = Y +|-|"&&"|"|" Z        5
+ *     X = Y +|-|"==" Constant     6
+ *     X = X +|- 1                 3
+ *     X = Y *|/ Z                 2
+ *     X = Expression,             1
+ *           two operators
+ *     X = Expression,             1
+ *           three operators
+ *                                --
+ *                                18       18
+ *
+ *     if ....                    14
+ *       with "else"      7
+ *       without "else"   7
+ *           executed        3
+ *           not executed    4
+ *     for ...                     7  |  counted every time
+ *     while ...                   4  |  the loop condition
+ *     do ... while                1  |  is evaluated
+ *     switch ...                  1
+ *     break                       1
+ *     declaration with            1
+ *       initialization
+ *                                --
+ *                                34       34
+ *
+ *     P (...)  procedure call    11
+ *       user procedure      10
+ *       library procedure    1
+ *     X = F (...)
+ *             function  call      6
+ *       user function        5                                         
+ *       library function     1                                               
+ *                                --                                          
+ *                                17       17
+ *                                        ---
+ *                                        103
+ *
+ *    The average number of parameters in procedure or function calls
+ *    is 1.82 (not counting the function values aX *
+ *
+ *  2. Operators
+ *  ------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *    Arithmetic             32          50.8                                 
+ *
+ *       +                     21          33.3                              
+ *       -                      7          11.1                              
+ *       *                      3           4.8
+ *       / (int div)            1           1.6
+ *
+ *    Comparison             27           42.8
+ *
+ *       ==                     9           14.3
+ *       /=                     4            6.3
+ *       >                      1            1.6
+ *       <                      3            4.8
+ *       >=                     1            1.6
+ *       <=                     9           14.3
+ *
+ *    Logic                   4            6.3
+ *
+ *       && (AND-THEN)          1            1.6
+ *       |  (OR)                1            1.6
+ *       !  (NOT)               2            3.2
+ * 
+ *                           --          -----
+ *                           63          100.1
+ *
+ *
+ *  3. Operand Type (counted once per operand reference):
+ *  ---------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *     Integer               175        72.3 %
+ *     Character              45        18.6 %
+ *     Pointer                12         5.0 %
+ *     String30                6         2.5 %
+ *     Array                   2         0.8 %
+ *     Record                  2         0.8 %
+ *                           ---       -------
+ *                           242       100.0 %
+ *
+ *  When there is an access path leading to the final operand (e.g. a record
+ *  component), only the final data type on the access path is counted.       
+ *
+ *
+ *  4. Operand Locality:                                                      
+ *  -------------------
+ *                                number    approximate
+ *                                          percentage
+ *
+ *     local variable              114        47.1 %
+ *     global variable              22         9.1 %
+ *     parameter                    45        18.6 %
+ *        value                        23         9.5 %
+ *        reference                    22         9.1 %
+ *     function result               6         2.5 %
+ *     constant                     55        22.7 %
+ *                                 ---       -------
+ *                                 242       100.0 %
+ *
+ *  The program does not compute anything meaningful, but it is syntactically
+ *  and semantically correct. All variables have a value assigned to them
+ *  before they are used as a source operand.
+ *
+ *  There has been no explicit effort to account for the effects of a
+ *  cache, or to balance the use of long or short displacements for code or
+ *  data.
+ *
+ ***************************************************************************
+ */
+
+/* Compiler and system dependent definitions: */
+
+/* variables for time measurement: */
+
+#define HZ 1000000
+#define Too_Small_Time 1
+#define CLOCK_TYPE "rdcycle()"
+#define Start_Timer() Begin_Time = read_csr(mcycle)
+#define Stop_Timer() End_Time = read_csr(mcycle)
+
+
+
+#define Mic_secs_Per_Second     1000000
+#define NUMBER_OF_RUNS		500 /* Default number of runs */
+
+#ifdef  NOSTRUCTASSIGN
+#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
+#else
+#define structassign(d, s)      d = s
+#endif
+
+#ifdef  NOENUM
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+  typedef int   Enumeration;
+#else
+  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+#endif
+        /* for boolean and enumeration types in Ada, Pascal */
+
+/* General definitions: */
+
+#include <stdio.h>
+#include <string.h>
+                /* for strcpy, strcmp */
+
+#define Null 0 
+                /* Value of a Null pointer */
+#ifndef true
+#define true  1
+#endif
+#ifndef false
+#define false 0
+#endif
+
+typedef int     One_Thirty;
+typedef int     One_Fifty;
+typedef char    Capital_Letter;
+typedef int     Boolean;
+typedef char    Str_30 [31];
+typedef int     Arr_1_Dim [50];
+typedef int     Arr_2_Dim [50] [50];
+
+typedef struct record 
+    {
+    struct record *Ptr_Comp;
+    Enumeration    Discr;
+    union {
+          struct {
+                  Enumeration Enum_Comp;
+                  int         Int_Comp;
+                  char        Str_Comp [31];
+                  } var_1;
+          struct {
+                  Enumeration E_Comp_2;
+                  char        Str_2_Comp [31];
+                  } var_2;
+          struct {
+                  char        Ch_1_Comp;
+                  char        Ch_2_Comp;
+                  } var_3;
+          } variant;
+      } Rec_Type, *Rec_Pointer;
+
+#endif
diff -Naur apps-12.8.0/testing/smp/dhrystone_main.c apps/testing/smp/dhrystone_main.c
--- apps-12.8.0/testing/smp/dhrystone_main.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/dhrystone_main.c	2025-11-04 11:04:41.213226135 +0200
@@ -0,0 +1,525 @@
+// See LICENSE for license details.
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <debug.h>
+
+//**************************************************************************
+// Dhrystone bencmark
+//--------------------------------------------------------------------------
+//
+// This is the classic Dhrystone synthetic integer benchmark.
+//
+
+#pragma GCC optimize ("no-inline")
+
+#include "dhrystone.h"
+
+#include <alloca.h>
+
+#define setStats(x)
+
+#define read_csr(csrname) ({ \
+        uint32_t __csr_tmp_u32; \
+        __asm__ volatile ("csrr %0, " #csrname : "=r" (__csr_tmp_u32)); \
+        __csr_tmp_u32; \
+})
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+// dhrystone.c
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+#undef REG
+#define REG register
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1: 
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2: 
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5: 
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+// end of dhrystone.c
+
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#undef REG
+#define REG register
+#endif
+
+Boolean		Done;
+
+long            Begin_Time,
+                End_Time,
+                User_Time;
+long            Microseconds,
+                Dhrystones_Per_Second;
+
+/* end of variables for time measurement */
+
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+  
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp 
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;  
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+//int main (int argc, char** argv)
+int main(int argc, FAR char *argv[])
+/*****/
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Arguments */
+  Number_Of_Runs = NUMBER_OF_RUNS;
+
+  /* Initializations */
+
+  Next_Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+  _info("\n");
+  _info("Dhrystone Benchmark, Version %s\n", Version);
+  if (Reg)
+  {
+    _info("Program compiled with 'register' attribute\n");
+  }
+  else
+  {
+    _info("Program compiled without 'register' attribute\n");
+  }
+  _info("Using %s, HZ=%d\n", CLOCK_TYPE, HZ);
+  _info("\n");
+
+  Done = false;
+  while (!Done) {
+    _info("Trying %d runs through Dhrystone:\n", Number_Of_Runs);
+
+    /***************/
+    /* Start timer */
+    /***************/
+
+    setStats(1);
+    Start_Timer();
+
+    for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+    {
+
+      Proc_5();
+      Proc_4();
+	/* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+      Int_1_Loc = 2;
+      Int_2_Loc = 3;
+      strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+      Enum_Loc = Ident_2;
+      Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+	/* Bool_Glob == 1 */
+      while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+      {
+	Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+	  /* Int_3_Loc == 7 */
+	Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+	  /* Int_3_Loc == 7 */
+	Int_1_Loc += 1;
+      } /* while */
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+	/* Int_Glob == 5 */
+      Proc_1 (Ptr_Glob);
+      for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+			       /* loop body executed twice */
+      {
+	if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+	    /* then, not executed */
+	  {
+	  Proc_6 (Ident_1, &Enum_Loc);
+	  strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+	  Int_2_Loc = Run_Index;
+	  Int_Glob = Run_Index;
+	  }
+      }
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Int_2_Loc = Int_2_Loc * Int_1_Loc;
+      Int_1_Loc = Int_2_Loc / Int_3_Loc;
+      Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+	/* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+      Proc_2 (&Int_1_Loc);
+	/* Int_1_Loc == 5 */
+
+    } /* loop "for Run_Index" */
+
+    /**************/
+    /* Stop timer */
+    /**************/
+
+    Stop_Timer();
+    setStats(0);
+
+    User_Time = End_Time - Begin_Time;
+
+    if (User_Time < Too_Small_Time)
+    {
+      _info("Measured time too small to obtain meaningful results\n");
+      Number_Of_Runs = Number_Of_Runs * 10;
+      _info("\n");
+    } else Done = true;
+  }
+
+  _info("Final values of the variables used in the benchmark:\n");
+  _info("\n");
+  _info("Int_Glob:            %d\n", Int_Glob);
+  _info("        should be:   %d\n", 5);
+  _info("Bool_Glob:           %d\n", Bool_Glob);
+  _info("        should be:   %d\n", 1);
+  _info("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  _info("        should be:   %c\n", 'A');
+  _info("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  _info("        should be:   %c\n", 'B');
+  _info("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  _info("        should be:   %d\n", 7);
+  _info("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  _info("        should be:   Number_Of_Runs + 10\n");
+  _info("Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent)\n");
+  _info("  Discr:             %d\n", Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 2);
+  _info("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 17);
+  _info("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Next_Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Next_Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent), same as above\n");
+  _info("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 1);
+  _info("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 18);
+  _info("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Int_1_Loc:           %d\n", Int_1_Loc);
+  _info("        should be:   %d\n", 5);
+  _info("Int_2_Loc:           %d\n", Int_2_Loc);
+  _info("        should be:   %d\n", 13);
+  _info("Int_3_Loc:           %d\n", Int_3_Loc);
+  _info("        should be:   %d\n", 7);
+  _info("Enum_Loc:            %d\n", Enum_Loc);
+  _info("        should be:   %d\n", 1);
+  _info("Str_1_Loc:           %s\n", Str_1_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  _info("Str_2_Loc:           %s\n", Str_2_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  _info("\n");
+
+
+  Microseconds = ((User_Time / Number_Of_Runs) * Mic_secs_Per_Second) / HZ;
+  Dhrystones_Per_Second = (HZ * Number_Of_Runs) / User_Time;
+
+  _info("Microseconds for one run through Dhrystone: %ld\n", Microseconds);
+  _info("Dhrystones per Second:                      %ld\n", Dhrystones_Per_Second);
+
+  return 0;
+}
+
+
+
diff -Naur apps-12.8.0/testing/smp/Make.dep apps/testing/smp/Make.dep
--- apps-12.8.0/testing/smp/Make.dep	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/Make.dep	2025-11-04 11:04:41.215224973 +0200
@@ -0,0 +1,231 @@
+# Gen Make.dep automatically
+mmc.c.home.laur.lucru.rtos.apps.testing.smp.o: src/mmc.c src/mmc.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+ocsdc.c.home.laur.lucru.rtos.apps.testing.smp.o: src/ocsdc.c src/mmc.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+sdc_example.c.home.laur.lucru.rtos.apps.testing.smp.o: src/sdc_example.c \
+ src/mmc.h /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+smp_main.c.home.laur.lucru.rtos.apps.testing.smp.o: smp_main.c \
+ /home/laur/lucru/rtos/nuttx/include/sched.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/config.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/types.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/compiler.h \
+ /home/laur/lucru/rtos/nuttx/include/stdint.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/types.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/limits.h \
+ /home/laur/lucru/rtos/nuttx/include/stdbool.h \
+ /home/laur/lucru/rtos/nuttx/include/strings.h \
+ /home/laur/lucru/rtos/nuttx/include/string.h \
+ /home/laur/lucru/rtos/nuttx/include/stddef.h \
+ /home/laur/lucru/rtos/nuttx/include/alloca.h \
+ /home/laur/lucru/rtos/nuttx/include/time.h \
+ /home/laur/lucru/rtos/nuttx/include/stdio.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdarg.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/fs.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/ioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/serial/tioctl.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/fs/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/sys/uio.h \
+ /home/laur/lucru/rtos/nuttx/include/dirent.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/atomic.h \
+ /home/laur/lucru/rtos/riscv-none-elf-gcc/lib/gcc/riscv-none-elf/13.2.0/include/stdatomic.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mutex.h \
+ /home/laur/lucru/rtos/nuttx/include/assert.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/errno.h \
+ /home/laur/lucru/rtos/nuttx/include/semaphore.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/queue.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/clock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/math32.h \
+ /home/laur/lucru/rtos/nuttx/include/inttypes.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/map.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/gran.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/spawn.h \
+ /home/laur/lucru/rtos/nuttx/include/signal.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/csr.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/chip/irq.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/mode.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/spinlock_type.h \
+ /home/laur/lucru/rtos/nuttx/include/arch/spinlock.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/lib/lib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/kmalloc.h \
+ /home/laur/lucru/rtos/nuttx/include/stdlib.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/mm/mm.h \
+ /home/laur/lucru/rtos/nuttx/include/nuttx/userspace.h \
+ /home/laur/lucru/rtos/nuttx/include/pthread.h \
+ /home/laur/lucru/rtos/nuttx/include/unistd.h \
+ /home/laur/lucru/rtos/nuttx/include/malloc.h \
+ /home/laur/lucru/rtos/nuttx/include/debug.h \
+ /home/laur/lucru/rtos/nuttx/include/syslog.h
+# No files specified for dependency generation
+# No files specified for dependency generation
diff -Naur apps-12.8.0/testing/smp/Makefile apps/testing/smp/Makefile
--- apps-12.8.0/testing/smp/Makefile	2025-01-24 11:45:01.824432074 +0200
+++ apps/testing/smp/Makefile	2025-11-04 11:04:41.215224973 +0200
@@ -30,7 +30,9 @@
 MODULE = $(CONFIG_TESTING_SMP)
 
 # SMP Example
-
+CSRCS += src/mmc.c
+CSRCS += src/ocsdc.c  
+CSRCS += src/sdc_example.c
 MAINSRC = smp_main.c
 
 include $(APPDIR)/Application.mk
diff -Naur apps-12.8.0/testing/smp/smp_main-12.8.0.c apps/testing/smp/smp_main-12.8.0.c
--- apps-12.8.0/testing/smp/smp_main-12.8.0.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/smp_main-12.8.0.c	2025-11-04 11:04:41.214225554 +0200
@@ -0,0 +1,332 @@
+/****************************************************************************
+ * apps/testing/smp/smp_main.c
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+
+#include <debug.h>
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#define HOG_MSEC       1000
+#define YIELD_MSEC     100
+#define IMPOSSIBLE_CPU -1
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+static pthread_barrier_t g_smp_barrier;
+static volatile int g_thread_cpu[CONFIG_TESTING_SMP_NBARRIER_THREADS + 1];
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: show_cpu / show_cpu_conditional
+ *
+ * Description:
+ *   This depends on internal OS interfaces that are not generally available
+ *   but can be accessed (albeit inappropriately) in a FLAT build
+ *
+ ****************************************************************************/
+
+static void show_cpu(FAR const char *caller, int threadno)
+{
+  g_thread_cpu[threadno] = sched_getcpu();
+  _info("%s[%d]: Running on CPU%d\n",
+         caller, threadno, g_thread_cpu[threadno]);
+}
+
+static void show_cpu_conditional(FAR const char *caller, int threadno)
+{
+  int cpu = sched_getcpu();
+
+  if (cpu != g_thread_cpu[threadno])
+    {
+      g_thread_cpu[threadno] = cpu;
+      _info("%s[%d]: Now running on CPU%d\n", caller, threadno, cpu);
+    }
+}
+
+/****************************************************************************
+ * Name: hog_milliseconds
+ *
+ * Description:
+ *   Delay inline for the specified number of milliseconds.
+ *
+ ****************************************************************************/
+
+static void hog_milliseconds(unsigned int milliseconds)
+{
+  volatile unsigned int i;
+  volatile unsigned int j;
+
+  for (i = 0; i < milliseconds; i++)
+    {
+      for (j = 0; j < CONFIG_BOARD_LOOPSPERMSEC; j++)
+        {
+        }
+    }
+}
+
+/****************************************************************************
+ * Name: hog_time
+ *
+ * Description:
+ *   Delay for awhile, calling pthread_yield() now and then to allow other
+ *   pthreads to get CPU time.
+ *
+ ****************************************************************************/
+
+static void hog_time(FAR const char *caller, int threadno)
+{
+  unsigned int remaining = HOG_MSEC;
+  unsigned int hogmsec;
+
+  while (remaining > 0)
+    {
+      /* Hog some CPU */
+
+      hogmsec = YIELD_MSEC;
+      if (hogmsec > remaining)
+        {
+          hogmsec = remaining;
+        }
+
+      hog_milliseconds(hogmsec);
+      remaining -= hogmsec;
+
+      /* Let other threads run */
+
+      pthread_yield();
+      show_cpu_conditional(caller, threadno);
+    }
+}
+
+/****************************************************************************
+ * Name: barrier_thread
+ ****************************************************************************/
+
+static pthread_addr_t barrier_thread(pthread_addr_t parameter)
+{
+  int threadno  = (int)((intptr_t)parameter);
+  int ret;
+
+  _info("Thread[%d]: Started\n",  threadno);
+  show_cpu("Thread", threadno);
+
+  /* Hog some CPU time */
+
+  hog_time("Thread", threadno);
+
+  /* Wait at the barrier until all threads are synchronized. */
+
+  _info("Thread[%d]: Calling pthread_barrier_wait()\n",
+         threadno);
+  fflush(stdout);
+  show_cpu_conditional("Thread", threadno);
+
+  ret = pthread_barrier_wait(&g_smp_barrier);
+  if (ret == 0)
+    {
+      _info("Thread[%d]: Back with ret=0 (I am not special)\n",
+             threadno);
+    }
+  else if (ret == PTHREAD_BARRIER_SERIAL_THREAD)
+    {
+      _info("Thread[%d]: Back with "
+             "ret=PTHREAD_BARRIER_SERIAL_THREAD (I AM SPECIAL)\n",
+             threadno);
+    }
+  else
+    {
+      _info("Thread[%d]: ERROR could not get semaphore value\n",
+             threadno);
+    }
+
+  fflush(stdout);
+  show_cpu_conditional("Thread", threadno);
+
+  /* Hog some more CPU time */
+
+  hog_time("Thread", threadno);
+
+  /* Then exit */
+
+  _info("Thread[%d]: Done\n",  threadno);
+  fflush(stdout);
+  show_cpu_conditional("Thread", threadno);
+  return NULL;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * smp_main
+ ****************************************************************************/
+
+int main(int argc, FAR char *argv[])
+{
+  pthread_t threadid[CONFIG_TESTING_SMP_NBARRIER_THREADS];
+  pthread_addr_t result;
+  pthread_attr_t attr;
+  pthread_barrierattr_t barrierattr;
+  int errcode = EXIT_SUCCESS;
+  int ret;
+  int i;
+
+  _info("main\n");
+
+  /* Initialize data */
+
+  memset(threadid,
+         0,
+         sizeof(pthread_t) * CONFIG_TESTING_SMP_NBARRIER_THREADS);
+  for (i = 0; i <= CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
+    {
+      g_thread_cpu[i] = IMPOSSIBLE_CPU;
+      if (i < CONFIG_TESTING_SMP_NBARRIER_THREADS)
+        {
+          threadid[i] = 0;
+        }
+    }
+
+  show_cpu("  Main", 0);
+  _info("  Main[0]: Initializing barrier\n");
+
+  /* Create the barrier */
+
+  ret = pthread_barrierattr_init(&barrierattr);
+  if (ret != OK)
+    {
+      _info("  Main[0]: pthread_barrierattr_init failed, ret=%d\n",
+              ret);
+
+      errcode = EXIT_FAILURE;
+      goto errout;
+    }
+
+  ret = pthread_barrier_init(&g_smp_barrier, &barrierattr,
+                             CONFIG_TESTING_SMP_NBARRIER_THREADS);
+  if (ret != OK)
+    {
+      _info("  Main[0]: pthread_barrier_init failed, ret=%d\n",
+             ret);
+
+      errcode = EXIT_FAILURE;
+      goto errout_with_attr;
+    }
+
+  /* Start CONFIG_TESTING_SMP_NBARRIER_THREADS thread instances */
+
+  ret = pthread_attr_init(&attr);
+  if (ret != OK)
+    {
+      _info("  Main[0]: pthread_attr_init failed, ret=%d\n", ret);
+
+      errcode = EXIT_FAILURE;
+      goto errout_with_barrier;
+    }
+
+  for (i = 0; i < CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
+    {
+      ret = pthread_create(&threadid[i], &attr, barrier_thread,
+                           (pthread_addr_t)((uintptr_t)i + 1));
+      if (ret != 0)
+        {
+          _info("  Main[0]: Error in thread %d create, ret=%d\n",
+                  i + 1, ret);
+          _info("  Main[0]: Test aborted with waiting threads\n");
+
+          errcode = EXIT_FAILURE;
+          break;
+        }
+      else
+        {
+          _info("  Main[0]: Thread %d created\n", i + 1);
+        }
+
+      show_cpu_conditional("  Main", 0);
+    }
+
+  fflush(stdout);
+  show_cpu_conditional("  Main", 0);
+
+  /* Wait for all thread instances to complete */
+
+  for (i = 0; i < CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
+    {
+      if (threadid[i] != 0)
+        {
+          ret = pthread_join(threadid[i], &result);
+          show_cpu_conditional("  Main", 0);
+
+          if (ret != 0)
+            {
+              _info("  Main[0]: Error in thread %d join, ret=%d\n",
+                     i + 1, ret);
+              errcode = EXIT_FAILURE;
+            }
+          else
+            {
+              _info("  Main[0]: Thread %d completed with result=%p\n",
+                     i + 1, result);
+            }
+        }
+    }
+
+  /* Destroy the barrier */
+
+errout_with_barrier:
+  ret = pthread_barrier_destroy(&g_smp_barrier);
+  if (ret != OK)
+    {
+      _info("  Main[0]: pthread_barrier_destroy failed, ret=%d\n", ret);
+    }
+
+errout_with_attr:
+  ret = pthread_barrierattr_destroy(&barrierattr);
+  if (ret != OK)
+    {
+      _info("  Main[0]: pthread_barrierattr_destroy failed, ret=%d\n",
+             ret);
+    }
+
+errout:
+  fflush(stdout);
+  show_cpu_conditional("  Main", 0);
+  return errcode;
+}
diff -Naur apps-12.8.0/testing/smp/smp_main-12-laur.c apps/testing/smp/smp_main-12-laur.c
--- apps-12.8.0/testing/smp/smp_main-12-laur.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/smp_main-12-laur.c	2025-11-04 11:04:41.214225554 +0200
@@ -0,0 +1,346 @@
+/****************************************************************************
+ * apps/testing/smp/smp_main.c
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+
+#include <debug.h>
+#include <nuttx/semaphore.h>
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+#define HOG_MSEC       10 // 1000
+#define YIELD_MSEC     10 // 100
+#define IMPOSSIBLE_CPU -1
+
+sem_t nsem;
+#define dbginfo(str, ...) \
+	do { \
+		nxsem_wait(&nsem); \
+		_info(str, ##__VA_ARGS__); \
+		nxsem_post(&nsem); \
+	} while(0);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+static pthread_barrier_t g_smp_barrier;
+static volatile int g_thread_cpu[CONFIG_TESTING_SMP_NBARRIER_THREADS + 1];
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: show_cpu / show_cpu_conditional
+ *
+ * Description:
+ *   This depends on internal OS interfaces that are not generally available
+ *   but can be accessed (albeit inappropriately) in a FLAT build
+ *
+ ****************************************************************************/
+
+static void show_cpu(FAR const char *caller, int threadno)
+{
+  g_thread_cpu[threadno] = sched_getcpu();
+  dbginfo("%s[%d]: Running on CPU%d\n",
+         caller, threadno, g_thread_cpu[threadno]);
+}
+
+static void show_cpu_conditional(FAR const char *caller, int threadno)
+{
+  int cpu = sched_getcpu();
+
+  if (cpu != g_thread_cpu[threadno])
+    {
+      g_thread_cpu[threadno] = cpu;
+      dbginfo("%s[%d]: Now running on CPU%d\n", caller, threadno, cpu);
+    }
+}
+
+/****************************************************************************
+ * Name: hog_milliseconds
+ *
+ * Description:
+ *   Delay inline for the specified number of milliseconds.
+ *
+ ****************************************************************************/
+
+static void hog_milliseconds(unsigned int milliseconds)
+{
+  volatile unsigned int i;
+  volatile unsigned int j;
+
+  for (i = 0; i < milliseconds; i++)
+    {
+      for (j = 0; j < CONFIG_BOARD_LOOPSPERMSEC; j++)
+        {
+        }
+    }
+}
+
+/****************************************************************************
+ * Name: hog_time
+ *
+ * Description:
+ *   Delay for awhile, calling pthread_yield() now and then to allow other
+ *   pthreads to get CPU time.
+ *
+ ****************************************************************************/
+
+static void hog_time(FAR const char *caller, int threadno)
+{
+  unsigned int remaining = HOG_MSEC;
+  unsigned int hogmsec;
+
+  while (remaining > 0)
+    {
+      /* Hog some CPU */
+
+      hogmsec = YIELD_MSEC;
+      if (hogmsec > remaining)
+        {
+          hogmsec = remaining;
+        }
+
+      hog_milliseconds(hogmsec);
+      remaining -= hogmsec;
+
+      /* Let other threads run */
+
+      pthread_yield();
+      show_cpu_conditional(caller, threadno);
+    }
+}
+
+/****************************************************************************
+ * Name: barrier_thread
+ ****************************************************************************/
+
+static pthread_addr_t barrier_thread(pthread_addr_t parameter)
+{
+  int threadno  = (int)((intptr_t)parameter);
+  int ret;
+
+  dbginfo("Thread[%d]: Started\n",  threadno);
+  show_cpu("Thread", threadno);
+
+  /* Hog some CPU time */
+
+  hog_time("Thread", threadno);
+
+  /* Wait at the barrier until all threads are synchronized. */
+
+  dbginfo("Thread[%d]: Calling pthread_barrier_wait()\n",
+         threadno);
+  fflush(stdout);
+  show_cpu_conditional("Thread", threadno);
+
+  ret = pthread_barrier_wait(&g_smp_barrier);
+  if (ret == 0)
+    {
+      dbginfo("Thread[%d]: Back with ret=0 (I am not special)\n",
+             threadno);
+    }
+  else if (ret == PTHREAD_BARRIER_SERIAL_THREAD)
+    {
+      dbginfo("Thread[%d]: Back with "
+             "ret=PTHREAD_BARRIER_SERIAL_THREAD (I AM SPECIAL)\n",
+             threadno);
+    }
+  else
+    {
+      dbginfo("Thread[%d]: ERROR could not get semaphore value\n",
+             threadno);
+    }
+
+  fflush(stdout);
+  show_cpu_conditional("Thread", threadno);
+
+  /* Hog some more CPU time */
+
+  hog_time("Thread", threadno);
+
+  /* Then exit */
+
+  dbginfo("Thread[%d]: Done\n",  threadno);
+  fflush(stdout);
+  show_cpu_conditional("Thread", threadno);
+  return NULL;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * smp_main
+ ****************************************************************************/
+
+int main(int argc, FAR char *argv[])
+{
+  pthread_t threadid[CONFIG_TESTING_SMP_NBARRIER_THREADS];
+  pthread_addr_t result;
+  pthread_attr_t attr;
+  pthread_barrierattr_t barrierattr;
+  int errcode = EXIT_SUCCESS;
+  int ret;
+  int i;
+
+  // do not print before this
+  nxsem_init(&nsem, 0, 1);
+
+  /* Initialize data */
+
+  memset(threadid,
+         0,
+         sizeof(pthread_t) * CONFIG_TESTING_SMP_NBARRIER_THREADS);
+  for (i = 0; i <= CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
+    {
+      g_thread_cpu[i] = IMPOSSIBLE_CPU;
+      if (i < CONFIG_TESTING_SMP_NBARRIER_THREADS)
+        {
+          threadid[i] = 0;
+        }
+    }
+
+  show_cpu("  Main", 0);
+  dbginfo("  Main[0]: Initializing barrier\n");
+
+  /* Create the barrier */
+
+  ret = pthread_barrierattr_init(&barrierattr);
+  if (ret != OK)
+    {
+      dbginfo("  Main[0]: pthread_barrierattr_init failed, ret=%d\n",
+              ret);
+
+      errcode = EXIT_FAILURE;
+      goto errout;
+    }
+
+  ret = pthread_barrier_init(&g_smp_barrier, &barrierattr,
+                             CONFIG_TESTING_SMP_NBARRIER_THREADS);
+  if (ret != OK)
+    {
+      dbginfo("  Main[0]: pthread_barrier_init failed, ret=%d\n",
+             ret);
+
+      errcode = EXIT_FAILURE;
+      goto errout_with_attr;
+    }
+
+  /* Start CONFIG_TESTING_SMP_NBARRIER_THREADS thread instances */
+  dbginfo("Start CONFIG_TESTING_SMP_NBARRIER_THREADS thread instances");
+
+  ret = pthread_attr_init(&attr);
+  if (ret != OK)
+    {
+      dbginfo("  Main[0]: pthread_attr_init failed, ret=%d\n", ret);
+
+      errcode = EXIT_FAILURE;
+      goto errout_with_barrier;
+    }
+
+  for (i = 0; i < CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
+    {
+      ret = pthread_create(&threadid[i], &attr, barrier_thread,
+                           (pthread_addr_t)((uintptr_t)i + 1));
+      if (ret != 0)
+        {
+          dbginfo("  Main[0]: Error in thread %d create, ret=%d\n",
+                  i + 1, ret);
+          dbginfo("  Main[0]: Test aborted with waiting threads\n");
+
+          errcode = EXIT_FAILURE;
+          break;
+        }
+      else
+        {
+          dbginfo("  Main[0]: Thread %d created\n", i + 1);
+        }
+
+      show_cpu_conditional("  Main", 0);
+    }
+
+  fflush(stdout);
+  show_cpu_conditional("  Main", 0);
+
+  /* Wait for all thread instances to complete */
+  dbginfo("Wait for all thread instances to complete");
+
+  for (i = 0; i < CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
+    {
+      if (threadid[i] != 0)
+        {
+          ret = pthread_join(threadid[i], &result);
+          show_cpu_conditional("  Main", 0);
+
+          if (ret != 0)
+            {
+              dbginfo("  Main[0]: Error in thread %d join, ret=%d\n",
+                     i + 1, ret);
+              errcode = EXIT_FAILURE;
+            }
+          else
+            {
+              dbginfo("  Main[0]: Thread %d completed with result=%p\n",
+                     i + 1, result);
+            }
+        }
+    }
+
+  nxsem_destroy(&nsem);
+
+  /* Destroy the barrier */
+
+errout_with_barrier:
+  ret = pthread_barrier_destroy(&g_smp_barrier);
+  if (ret != OK)
+    {
+      dbginfo("  Main[0]: pthread_barrier_destroy failed, ret=%d\n", ret);
+    }
+
+errout_with_attr:
+  ret = pthread_barrierattr_destroy(&barrierattr);
+  if (ret != OK)
+    {
+      dbginfo("  Main[0]: pthread_barrierattr_destroy failed, ret=%d\n",
+             ret);
+    }
+
+errout:
+  fflush(stdout);
+  show_cpu_conditional("  Main", 0);
+
+  return errcode;
+}
diff -Naur apps-12.8.0/testing/smp/smp_main.c apps/testing/smp/smp_main.c
--- apps-12.8.0/testing/smp/smp_main.c	2025-01-24 11:45:01.824432074 +0200
+++ apps/testing/smp/smp_main.c	2025-11-04 11:04:41.215224973 +0200
@@ -31,14 +31,24 @@
 #include <pthread.h>
 #include <string.h>
 
+#include <debug.h>
+#include <nuttx/semaphore.h>
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
 
-#define HOG_MSEC       1000
-#define YIELD_MSEC     100
+#define HOG_MSEC       10 // 1000
+#define YIELD_MSEC     10 // 100
 #define IMPOSSIBLE_CPU -1
 
+sem_t nsem;
+#define dbginfo(str, ...) \
+	do { \
+		nxsem_wait(&nsem); \
+		_info(str, ##__VA_ARGS__); \
+		nxsem_post(&nsem); \
+	} while(0);
+
 /****************************************************************************
  * Private Data
  ****************************************************************************/
@@ -62,7 +72,7 @@
 static void show_cpu(FAR const char *caller, int threadno)
 {
   g_thread_cpu[threadno] = sched_getcpu();
-  printf("%s[%d]: Running on CPU%d\n",
+  dbginfo("%s[%d]: Running on CPU%d\n",
          caller, threadno, g_thread_cpu[threadno]);
 }
 
@@ -73,7 +83,7 @@
   if (cpu != g_thread_cpu[threadno])
     {
       g_thread_cpu[threadno] = cpu;
-      printf("%s[%d]: Now running on CPU%d\n", caller, threadno, cpu);
+      dbginfo("%s[%d]: Now running on CPU%d\n", caller, threadno, cpu);
     }
 }
 
@@ -141,7 +151,7 @@
   int threadno  = (int)((intptr_t)parameter);
   int ret;
 
-  printf("Thread[%d]: Started\n",  threadno);
+  dbginfo("Thread[%d]: Started\n",  threadno);
   show_cpu("Thread", threadno);
 
   /* Hog some CPU time */
@@ -150,7 +160,7 @@
 
   /* Wait at the barrier until all threads are synchronized. */
 
-  printf("Thread[%d]: Calling pthread_barrier_wait()\n",
+  dbginfo("Thread[%d]: Calling pthread_barrier_wait()\n",
          threadno);
   fflush(stdout);
   show_cpu_conditional("Thread", threadno);
@@ -158,18 +168,18 @@
   ret = pthread_barrier_wait(&g_smp_barrier);
   if (ret == 0)
     {
-      printf("Thread[%d]: Back with ret=0 (I am not special)\n",
+      dbginfo("Thread[%d]: Back with ret=0 (I am not special)\n",
              threadno);
     }
   else if (ret == PTHREAD_BARRIER_SERIAL_THREAD)
     {
-      printf("Thread[%d]: Back with "
+      dbginfo("Thread[%d]: Back with "
              "ret=PTHREAD_BARRIER_SERIAL_THREAD (I AM SPECIAL)\n",
              threadno);
     }
   else
     {
-      printf("Thread[%d]: ERROR could not get semaphore value\n",
+      dbginfo("Thread[%d]: ERROR could not get semaphore value\n",
              threadno);
     }
 
@@ -182,7 +192,7 @@
 
   /* Then exit */
 
-  printf("Thread[%d]: Done\n",  threadno);
+  dbginfo("Thread[%d]: Done\n",  threadno);
   fflush(stdout);
   show_cpu_conditional("Thread", threadno);
   return NULL;
@@ -206,6 +216,9 @@
   int ret;
   int i;
 
+  // do not print before this
+  nxsem_init(&nsem, 0, 1);
+
   /* Initialize data */
 
   memset(threadid,
@@ -221,14 +234,14 @@
     }
 
   show_cpu("  Main", 0);
-  printf("  Main[0]: Initializing barrier\n");
+  dbginfo("  Main[0]: Initializing barrier\n");
 
   /* Create the barrier */
 
   ret = pthread_barrierattr_init(&barrierattr);
   if (ret != OK)
     {
-      printf("  Main[0]: pthread_barrierattr_init failed, ret=%d\n",
+      dbginfo("  Main[0]: pthread_barrierattr_init failed, ret=%d\n",
               ret);
 
       errcode = EXIT_FAILURE;
@@ -239,7 +252,7 @@
                              CONFIG_TESTING_SMP_NBARRIER_THREADS);
   if (ret != OK)
     {
-      printf("  Main[0]: pthread_barrier_init failed, ret=%d\n",
+      dbginfo("  Main[0]: pthread_barrier_init failed, ret=%d\n",
              ret);
 
       errcode = EXIT_FAILURE;
@@ -247,11 +260,12 @@
     }
 
   /* Start CONFIG_TESTING_SMP_NBARRIER_THREADS thread instances */
+  dbginfo("Start CONFIG_TESTING_SMP_NBARRIER_THREADS thread instances");
 
   ret = pthread_attr_init(&attr);
   if (ret != OK)
     {
-      printf("  Main[0]: pthread_attr_init failed, ret=%d\n", ret);
+      dbginfo("  Main[0]: pthread_attr_init failed, ret=%d\n", ret);
 
       errcode = EXIT_FAILURE;
       goto errout_with_barrier;
@@ -263,16 +277,16 @@
                            (pthread_addr_t)((uintptr_t)i + 1));
       if (ret != 0)
         {
-          printf("  Main[0]: Error in thread %d create, ret=%d\n",
+          dbginfo("  Main[0]: Error in thread %d create, ret=%d\n",
                   i + 1, ret);
-          printf("  Main[0]: Test aborted with waiting threads\n");
+          dbginfo("  Main[0]: Test aborted with waiting threads\n");
 
           errcode = EXIT_FAILURE;
           break;
         }
       else
         {
-          printf("  Main[0]: Thread %d created\n", i + 1);
+          dbginfo("  Main[0]: Thread %d created\n", i + 1);
         }
 
       show_cpu_conditional("  Main", 0);
@@ -282,6 +296,7 @@
   show_cpu_conditional("  Main", 0);
 
   /* Wait for all thread instances to complete */
+  dbginfo("Wait for all thread instances to complete");
 
   for (i = 0; i < CONFIG_TESTING_SMP_NBARRIER_THREADS; i++)
     {
@@ -292,37 +307,40 @@
 
           if (ret != 0)
             {
-              printf("  Main[0]: Error in thread %d join, ret=%d\n",
+              dbginfo("  Main[0]: Error in thread %d join, ret=%d\n",
                      i + 1, ret);
               errcode = EXIT_FAILURE;
             }
           else
             {
-              printf("  Main[0]: Thread %d completed with result=%p\n",
+              dbginfo("  Main[0]: Thread %d completed with result=%p\n",
                      i + 1, result);
             }
         }
     }
 
+  nxsem_destroy(&nsem);
+
   /* Destroy the barrier */
 
 errout_with_barrier:
   ret = pthread_barrier_destroy(&g_smp_barrier);
   if (ret != OK)
     {
-      printf("  Main[0]: pthread_barrier_destroy failed, ret=%d\n", ret);
+      dbginfo("  Main[0]: pthread_barrier_destroy failed, ret=%d\n", ret);
     }
 
 errout_with_attr:
   ret = pthread_barrierattr_destroy(&barrierattr);
   if (ret != OK)
     {
-      printf("  Main[0]: pthread_barrierattr_destroy failed, ret=%d\n",
+      dbginfo("  Main[0]: pthread_barrierattr_destroy failed, ret=%d\n",
              ret);
     }
 
 errout:
   fflush(stdout);
   show_cpu_conditional("  Main", 0);
+
   return errcode;
 }
diff -Naur apps-12.8.0/testing/smp/smp_main-dhrystone.c apps/testing/smp/smp_main-dhrystone.c
--- apps-12.8.0/testing/smp/smp_main-dhrystone.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/smp_main-dhrystone.c	2025-11-04 11:04:41.208229042 +0200
@@ -0,0 +1,607 @@
+// See LICENSE for license details.
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <debug.h>
+#include <math.h>
+
+extern int tints;
+
+//**************************************************************************
+// Dhrystone bencmark
+//--------------------------------------------------------------------------
+//
+// This is the classic Dhrystone synthetic integer benchmark.
+//
+
+#pragma GCC optimize ("no-inline")
+
+#include "dhrystone.h"
+
+#include <alloca.h>
+
+int core_main(int argc, char *argv[]);
+
+#define setStats(x)
+
+#define read_csr(reg) ({ unsigned long __tmp; \
+  asm volatile ("csrr %0, " #reg : "=r"(__tmp)); \
+  __tmp; })
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+// dhrystone.c
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+#undef REG
+#define REG register
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1: 
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2: 
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5: 
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+// end of dhrystone.c
+
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#undef REG
+#define REG register
+#endif
+
+Boolean		Done;
+
+long            Begin_Time,
+                End_Time,
+                User_Time;
+long            Microseconds,
+                Dhrystones_Per_Second;
+
+/* end of variables for time measurement */
+
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+  
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp 
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;  
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+#define wait_not_busy(baddr, status) \
+          do { \
+                nxsig_usleep(10); \
+                status = *(volatile int *)(baddr - 0x200); \
+                /*if(status & 0x100ff) _info("r status=%x\n", status);*/ \
+          } while ((status & 0x100ff))
+volatile unsigned char *baddr;
+unsigned char b[512]={0};
+void testsd()
+{
+        volatile int i, status=0;
+        baddr = 0x40008200;
+	int sector=4096, match=1;
+
+      for(i = 0; i < 0x200; i++)
+	      b[i] = i;
+      // fill hw buffer with user data
+      for(i = 0; i < 0x200; i++) {
+                *(volatile unsigned char*)(baddr+i) = b[i];
+        }
+      /* Then transfer the sector */
+      *(volatile int *)(baddr - 0x200 + 4) = sector;
+      // wait writing
+      wait_not_busy(baddr, status);
+
+      // read block 0 
+      sector = 0;
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = sector;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        b[i] = *(volatile unsigned char *)(baddr + i);
+      //_info("\nsector %d: ", sector);
+      //for(i=0; i<0x200; i++)
+      //       _info("b[%d]=%d ", i, b[i]);
+
+      // read block 4096
+      sector = 4096;
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = sector;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        b[i] = *(volatile unsigned char *)(baddr + i);
+
+      // check b[i]
+      //_info("\nsector %d: ", sector);
+      //for(i=0; i<0x200; i++)
+      //        _info("b[%d]=%d ", i, b[i]);
+      match = 1;
+      for(i=0; i<0x200; i++)
+	if(b[i] != (unsigned char)i)
+		match = 0;
+      if(match)
+	     	_info("block match\n");
+      else
+		_info("block unmatch\n");
+}
+
+int t0=0, t1=0;
+
+int sdc_main(void);
+int main(int argc, FAR char *argv[])
+/*****/
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+
+	//sdc_main();
+	//testsd();
+
+#if 0
+  float a=1.5, b=2.6;
+  _info("a+b=%f\n", a*b);
+  while(1);
+#endif
+
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Arguments */
+  Number_Of_Runs = NUMBER_OF_RUNS;
+
+  /* Initializations */
+
+  Next_Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+  _info("\n");
+  _info("Dhrystone Benchmark, Version %s\n", Version);
+  if (Reg)
+  {
+    _info("Program compiled with 'register' attribute\n");
+  }
+  else
+  {
+    _info("Program compiled without 'register' attribute\n");
+  }
+  _info("Using %s, HZ=%d\n", CLOCK_TYPE, HZ);
+  _info("\n");
+
+  Done = false;
+  while (!Done) {
+    _info("Trying %d runs through Dhrystone:\n", Number_Of_Runs);
+
+    /***************/
+    /* Start timer */
+    /***************/
+
+    setStats(1);
+    Start_Timer();
+    t0 = read_csr(mcycle);
+
+    for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+    {
+
+      Proc_5();
+      Proc_4();
+	/* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+      Int_1_Loc = 2;
+      Int_2_Loc = 3;
+      strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+      Enum_Loc = Ident_2;
+      Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+	/* Bool_Glob == 1 */
+      while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+      {
+	Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+	  /* Int_3_Loc == 7 */
+	Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+	  /* Int_3_Loc == 7 */
+	Int_1_Loc += 1;
+      } /* while */
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+	/* Int_Glob == 5 */
+      Proc_1 (Ptr_Glob);
+      for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+			       /* loop body executed twice */
+      {
+	if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+	    /* then, not executed */
+	  {
+	  Proc_6 (Ident_1, &Enum_Loc);
+	  strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+	  Int_2_Loc = Run_Index;
+	  Int_Glob = Run_Index;
+	  }
+      }
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Int_2_Loc = Int_2_Loc * Int_1_Loc;
+      Int_1_Loc = Int_2_Loc / Int_3_Loc;
+      Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+	/* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+      Proc_2 (&Int_1_Loc);
+	/* Int_1_Loc == 5 */
+
+    } /* loop "for Run_Index" */
+
+    /**************/
+    /* Stop timer */
+    /**************/
+
+    Stop_Timer();
+    t1 = read_csr(mcycle);
+    setStats(0);
+
+    User_Time = t1 - t0; // End_Time - Begin_Time;
+
+    if (User_Time < Too_Small_Time)
+    {
+      _info("Measured time %d too small to obtain meaningful results %d\n", User_Time, Too_Small_Time);
+      Number_Of_Runs = Number_Of_Runs * 10;
+      _info("\n");
+    } else Done = true;
+  }
+
+  _info("Final values of the variables used in the benchmark:\n");
+  _info("\n");
+  _info("Int_Glob:            %d\n", Int_Glob);
+  _info("        should be:   %d\n", 5);
+  _info("Bool_Glob:           %d\n", Bool_Glob);
+  _info("        should be:   %d\n", 1);
+  _info("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  _info("        should be:   %c\n", 'A');
+  _info("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  _info("        should be:   %c\n", 'B');
+  _info("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  _info("        should be:   %d\n", 7);
+  _info("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  _info("        should be:   Number_Of_Runs + 10\n");
+  _info("Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent)\n");
+  _info("  Discr:             %d\n", Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 2);
+  _info("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 17);
+  _info("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Next_Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Next_Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent), same as above\n");
+  _info("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 1);
+  _info("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 18);
+  _info("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Int_1_Loc:           %d\n", Int_1_Loc);
+  _info("        should be:   %d\n", 5);
+  _info("Int_2_Loc:           %d\n", Int_2_Loc);
+  _info("        should be:   %d\n", 13);
+  _info("Int_3_Loc:           %d\n", Int_3_Loc);
+  _info("        should be:   %d\n", 7);
+  _info("Enum_Loc:            %d\n", Enum_Loc);
+  _info("        should be:   %d\n", 1);
+  _info("Str_1_Loc:           %s\n", Str_1_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  _info("Str_2_Loc:           %s\n", Str_2_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  _info("\n");
+
+
+  Microseconds = ((User_Time / Number_Of_Runs) * Mic_secs_Per_Second) / HZ;
+  Dhrystones_Per_Second = (HZ * Number_Of_Runs) / User_Time;
+
+  _info("Microseconds for one run through Dhrystone: %ld\n", Microseconds);
+  _info("Dhrystones per Second:                      %ld\n", Dhrystones_Per_Second);
+
+  //int tints=0;
+  _info("tints=%d, t1=%d, t0=%d\n", tints, t1, t0);
+
+  core_main(0, 0);
+
+  _info("tints=%d\n", tints);
+
+  return 0;
+}
+
diff -Naur apps-12.8.0/testing/smp/smp_main-dhrystone-laur.c apps/testing/smp/smp_main-dhrystone-laur.c
--- apps-12.8.0/testing/smp/smp_main-dhrystone-laur.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/smp_main-dhrystone-laur.c	2025-11-04 11:04:41.212226717 +0200
@@ -0,0 +1,651 @@
+// See LICENSE for license details.
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <debug.h>
+#include <math.h>
+
+extern int tints;
+
+//**************************************************************************
+// Dhrystone bencmark
+//--------------------------------------------------------------------------
+//
+// This is the classic Dhrystone synthetic integer benchmark.
+//
+
+#pragma GCC optimize ("no-inline")
+
+#include "dhrystone.h"
+
+#include <alloca.h>
+
+int core_main(int argc, char *argv[]);
+
+#define setStats(x)
+
+#define read_csr(reg) ({ unsigned long __tmp; \
+  asm volatile ("csrr %0, " #reg : "=r"(__tmp)); \
+  __tmp; })
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+// dhrystone.c
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+#undef REG
+#define REG register
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1: 
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2: 
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5: 
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+// end of dhrystone.c
+
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#undef REG
+#define REG register
+#endif
+
+Boolean		Done[2];
+
+long            Begin_Time,
+                End_Time,
+                User_Time[2];
+long            Microseconds[2],
+                Dhrystones_Per_Second[2];
+
+/* end of variables for time measurement */
+
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+  
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp 
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;  
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+#define wait_not_busy(baddr, status) \
+          do { \
+                nxsig_usleep(10); \
+                status = *(volatile int *)(baddr - 0x200); \
+                /*if(status & 0x100ff) _info("r status=%x\n", status);*/ \
+          } while ((status & 0x100ff))
+volatile unsigned char *baddr;
+unsigned char b[512]={0};
+void testsd()
+{
+        volatile int i, status=0;
+        baddr = 0x40008200;
+	int sector=4096, match=1;
+
+      for(i = 0; i < 0x200; i++)
+	      b[i] = i;
+      // fill hw buffer with user data
+      for(i = 0; i < 0x200; i++) {
+                *(volatile unsigned char*)(baddr+i) = b[i];
+        }
+      /* Then transfer the sector */
+      *(volatile int *)(baddr - 0x200 + 4) = sector;
+      // wait writing
+      wait_not_busy(baddr, status);
+
+      // read block 0 
+      sector = 0;
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = sector;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        b[i] = *(volatile unsigned char *)(baddr + i);
+      //_info("\nsector %d: ", sector);
+      //for(i=0; i<0x200; i++)
+      //       _info("b[%d]=%d ", i, b[i]);
+
+      // read block 4096
+      sector = 4096;
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = sector;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        b[i] = *(volatile unsigned char *)(baddr + i);
+
+      // check b[i]
+      //_info("\nsector %d: ", sector);
+      //for(i=0; i<0x200; i++)
+      //        _info("b[%d]=%d ", i, b[i]);
+      match = 1;
+      for(i=0; i<0x200; i++)
+	if(b[i] != (unsigned char)i)
+		match = 0;
+      if(match)
+	     	_info("block match\n");
+      else
+		_info("block unmatch\n");
+}
+
+int t0[2]={0}, t1[2]={0};
+int h0end=0;
+int mhartid;
+
+int sdc_main(void);
+int main(int argc, FAR char *argv[]) {
+	dhrmain();
+	return 0;
+}
+int dhrmain()
+/*****/
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+#ifdef laur0
+	//_info("dhr\n");
+	//up_putc('L');
+
+	//int mhartid;
+	mhartid = read_csr(/*CSR_MHARTID*/0xf14);
+
+	int i,j,k, pstart;
+	if(mhartid == 0)
+		pstart = 3;
+	else
+		pstart = 5;
+
+	for(i = pstart; i < 100; i+=4) {
+		j = 3;
+		do{
+			k = i % j;
+			j = j + 2;
+		}while (k && j < k);
+		if(k)
+			if(mhartid == 0)
+				up_putc('0');
+			else 
+				up_putc('1');
+			//_info("i=%d prime h=%x\n", i, mhartid);
+			
+	}	
+	//while(1);
+#endif
+
+	//sdc_main();
+	//testsd();
+
+#if 0
+  float a=1.5, b=2.6;
+  _info("a+b=%f\n", a*b);
+  while(1);
+#endif
+
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Arguments */
+  Number_Of_Runs = NUMBER_OF_RUNS;
+
+  /* Initializations */
+
+  Next_Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+  if(mhartid == 0) {
+  _info("\n");
+  _info("Dhrystone Benchmark, Version %s\n", Version);
+  if (Reg)
+  {
+    _info("Program compiled with 'register' attribute\n");
+  }
+  else
+  {
+    _info("Program compiled without 'register' attribute\n");
+  }
+  _info("Using %s, HZ=%d\n", CLOCK_TYPE, HZ);
+  _info("\n");
+  }
+
+  Done[mhartid] = false;
+  while (!Done[mhartid]) {
+    _info("Trying %d runs through Dhrystone:\n", Number_Of_Runs);
+
+    /***************/
+    /* Start timer */
+    /***************/
+
+    setStats(1);
+    Start_Timer();
+    t0[mhartid] = read_csr(mcycle);
+
+    for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+    {
+
+      Proc_5();
+      Proc_4();
+	/* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+      Int_1_Loc = 2;
+      Int_2_Loc = 3;
+      strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+      Enum_Loc = Ident_2;
+      Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+	/* Bool_Glob == 1 */
+      while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+      {
+	Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+	  /* Int_3_Loc == 7 */
+	Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+	  /* Int_3_Loc == 7 */
+	Int_1_Loc += 1;
+      } /* while */
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+	/* Int_Glob == 5 */
+      Proc_1 (Ptr_Glob);
+      for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+			       /* loop body executed twice */
+      {
+	if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+	    /* then, not executed */
+	  {
+	  Proc_6 (Ident_1, &Enum_Loc);
+	  strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+	  Int_2_Loc = Run_Index;
+	  Int_Glob = Run_Index;
+	  }
+      }
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Int_2_Loc = Int_2_Loc * Int_1_Loc;
+      Int_1_Loc = Int_2_Loc / Int_3_Loc;
+      Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+	/* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+      Proc_2 (&Int_1_Loc);
+	/* Int_1_Loc == 5 */
+
+    } /* loop "for Run_Index" */
+
+    /**************/
+    /* Stop timer */
+    /**************/
+
+    Stop_Timer();
+    t1[mhartid] = read_csr(mcycle);
+    setStats(0);
+
+    User_Time[mhartid] = t1[mhartid] - t0[mhartid]; // End_Time - Begin_Time;
+
+    if (User_Time[mhartid] < Too_Small_Time)
+    {
+      _info("Measured time %d too small to obtain meaningful results %d\n", User_Time, Too_Small_Time);
+      Number_Of_Runs = Number_Of_Runs * 10;
+      _info("\n");
+    } else Done[mhartid] = true;
+  }
+
+  if(mhartid)
+	  do {} while (h0end == 0);
+
+  _info("Final values of the variables used in the benchmark:\n");
+  _info("\n");
+  _info("Int_Glob:            %d\n", Int_Glob);
+  _info("        should be:   %d\n", 5);
+  _info("Bool_Glob:           %d\n", Bool_Glob);
+  _info("        should be:   %d\n", 1);
+  _info("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  _info("        should be:   %c\n", 'A');
+  _info("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  _info("        should be:   %c\n", 'B');
+  _info("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  _info("        should be:   %d\n", 7);
+  _info("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  _info("        should be:   Number_Of_Runs + 10\n");
+  _info("Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent)\n");
+  _info("  Discr:             %d\n", Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 2);
+  _info("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 17);
+  _info("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Next_Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Next_Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent), same as above\n");
+  _info("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 1);
+  _info("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 18);
+  _info("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Int_1_Loc:           %d\n", Int_1_Loc);
+  _info("        should be:   %d\n", 5);
+  _info("Int_2_Loc:           %d\n", Int_2_Loc);
+  _info("        should be:   %d\n", 13);
+  _info("Int_3_Loc:           %d\n", Int_3_Loc);
+  _info("        should be:   %d\n", 7);
+  _info("Enum_Loc:            %d\n", Enum_Loc);
+  _info("        should be:   %d\n", 1);
+  _info("Str_1_Loc:           %s\n", Str_1_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  _info("Str_2_Loc:           %s\n", Str_2_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  _info("\n");
+
+
+  Microseconds[mhartid] = ((User_Time[mhartid] / Number_Of_Runs) * Mic_secs_Per_Second) / HZ;
+  Dhrystones_Per_Second[mhartid] = (HZ * Number_Of_Runs) / User_Time[mhartid];
+
+  _info("Microseconds for one run through Dhrystone: %ld\n", Microseconds[mhartid]);
+  _info("Dhrystones per Second:                      %ld\n", Dhrystones_Per_Second[mhartid]);
+
+  //int tints=0;
+  _info("tints=%d, t1=%d, t0=%d\n", tints, t1, t0);
+  h0end = 1;
+
+#define TESTCOREMARK
+#ifdef TESTCOREMARK
+  core_main(0, 0);
+
+  _info("tints=%d\n", tints);
+#endif
+
+  return 0;
+}
+
diff -Naur apps-12.8.0/testing/smp/src/mmc.c apps/testing/smp/src/mmc.c
--- apps-12.8.0/testing/smp/src/mmc.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/src/mmc.c	2025-11-04 11:04:41.211227298 +0200
@@ -0,0 +1,923 @@
+/*
+ * Copyright 2008, Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based vaguely on the Linux code
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include "mmc.h"
+#include <stdio.h>
+#include <string.h>
+#include <debug.h>
+
+void udelay(int t) {
+#define US_DELAY 100
+	volatile int us = US_DELAY;
+	while(t--) {
+		us = US_DELAY;
+		while(us--);
+	}
+}
+
+/* frequency bases */
+/* divided by 10 to be nice to platforms without floating point */
+static const int fbase[] = {
+	10000,
+	100000,
+	1000000,
+	10000000,
+};
+
+/* Multiplier values for TRAN_SPEED.  Multiplied by 10 to be nice
+ * to platforms without floating point.
+ */
+static const int multipliers[] = {
+	0,	/* reserved */
+	10,
+	12,
+	13,
+	15,
+	20,
+	25,
+	30,
+	35,
+	40,
+	45,
+	50,
+	55,
+	60,
+	70,
+	80,
+};
+
+static void mmc_set_ios(struct mmc *mmc)
+{
+	mmc->set_ios(mmc);
+}
+
+static void mmc_set_bus_width(struct mmc *mmc, uint width)
+{
+	mmc->bus_width = width;
+
+	mmc_set_ios(mmc);
+}
+
+static void mmc_set_clock(struct mmc *mmc, uint clock)
+{
+	if (clock > mmc->f_max)
+		clock = mmc->f_max;
+
+	if (clock < mmc->f_min)
+		clock = mmc->f_min;
+
+	mmc->clock = clock;
+
+	mmc_set_ios(mmc);
+}
+
+static int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	int ret;
+
+	ret = mmc->send_cmd(mmc, cmd, data);
+
+	return ret;
+}
+
+static int mmc_go_idle(struct mmc* mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	udelay(1000);
+
+	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_NONE;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	udelay(2000);
+
+	return 0;
+}
+
+static int mmc_send_if_cond(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	cmd.cmdidx = SD_CMD_SEND_IF_COND;
+	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
+	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
+	cmd.resp_type = MMC_RSP_R7;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	if ((cmd.response[0] & 0xff) != 0xaa)
+		return UNUSABLE_ERR;
+	else
+		mmc->version = SD_VERSION_2;
+
+	return 0;
+}
+
+static int sd_send_op_cond(struct mmc *mmc)
+{
+	int timeout = 1000;
+	int err;
+	struct mmc_cmd cmd;
+
+	do {
+		cmd.cmdidx = MMC_CMD_APP_CMD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = 0;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+		cmd.resp_type = MMC_RSP_R3;
+
+		/*
+		 * Most cards do not answer if some reserved bits
+		 * in the ocr are set. However, Some controller
+		 * can set bit 7 (reserved for low voltages), but
+		 * how to manage low voltages SD card is not yet
+		 * specified.
+		 */
+		cmd.cmdarg = (mmc->voltages & 0xff8000);
+
+		if (mmc->version == SD_VERSION_2)
+			cmd.cmdarg |= OCR_HCS;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		udelay(1000);
+	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
+
+	if (mmc->version != SD_VERSION_2)
+		mmc->version = SD_VERSION_1_0;
+
+	mmc->ocr = cmd.response[0];
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
+
+	return 0;
+}
+
+static int mmc_send_op_cond(struct mmc *mmc)
+{
+	int timeout = 10000;
+	struct mmc_cmd cmd;
+	int err;
+
+	/* Some cards seem to need this */
+	mmc_go_idle(mmc);
+
+ 	/* Asking to the card its capabilities */
+ 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
+ 	cmd.resp_type = MMC_RSP_R3;
+ 	cmd.cmdarg = 0;
+
+ 	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+ 	if (err)
+ 		return err;
+
+ 	udelay(1000);
+
+	do {
+		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
+		cmd.resp_type = MMC_RSP_R3;
+		cmd.cmdarg =
+				(mmc->voltages &
+				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
+				(cmd.response[0] & OCR_ACCESS_MODE);
+
+		if (mmc->host_caps & MMC_MODE_HC)
+			cmd.cmdarg |= OCR_HCS;
+
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+
+		if (err)
+			return err;
+
+		udelay(1000);
+	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
+
+	if (timeout <= 0)
+		return UNUSABLE_ERR;
+
+	mmc->version = MMC_VERSION_UNKNOWN;
+	mmc->ocr = cmd.response[0];
+
+	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
+	mmc->rca = 0;
+
+	return 0;
+}
+
+static int mmc_send_status(struct mmc *mmc, int timeout)
+{
+	struct mmc_cmd cmd;
+	int err, retries = 5;
+
+	cmd.cmdidx = MMC_CMD_SEND_STATUS;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	do {
+		err = mmc_send_cmd(mmc, &cmd, NULL);
+		if (!err) {
+			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
+			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
+			     MMC_STATE_PRG)
+				break;
+			else if (cmd.response[0] & MMC_STATUS_MASK) {
+				_info("Status Error: 0x%08X\n\r",
+					cmd.response[0]);
+				return COMM_ERR;
+			}
+		} else if (--retries < 0)
+			return err;
+
+		udelay(1000);
+
+	} while (timeout--);
+
+	if (timeout <= 0) {
+		_info("Timeout waiting card ready\n\r");
+		return TIMEOUT;
+	}
+
+	return 0;
+}
+
+static int mmc_send_ext_csd(struct mmc *mmc, char *ext_csd)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+
+	/* Get the Card Status Register */
+	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	data.dest = (char *)ext_csd;
+	data.blocks = 1;
+	data.blocksize = 512;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	return err;
+}
+
+static int mmc_switch(struct mmc *mmc, char set, char index, char value)
+{
+	struct mmc_cmd cmd;
+	int timeout = 1000;
+	int ret;
+
+	cmd.cmdidx = MMC_CMD_SWITCH;
+	cmd.resp_type = MMC_RSP_R1b;
+	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
+				 (index << 16) |
+				 (value << 8);
+
+	ret = mmc_send_cmd(mmc, &cmd, NULL);
+
+	/* Waiting for the ready status */
+	if (!ret)
+		ret = mmc_send_status(mmc, timeout);
+
+	return ret;
+
+}
+
+static int sd_switch(struct mmc *mmc, int mode, int group, char value, char *resp)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	/* Switch the frequency */
+	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = (mode << 31) | 0xffffff;
+	cmd.cmdarg &= ~(0xf << (group * 4));
+	cmd.cmdarg |= value << (group * 4);
+
+	data.dest = (char *)resp;
+	data.blocksize = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	return mmc_send_cmd(mmc, &cmd, &data);
+}
+
+static int sd_change_freq(struct mmc *mmc)
+{
+	int err;
+	struct mmc_cmd cmd;
+	uint scr[2];
+	uint switch_status[16];
+	struct mmc_data data;
+	int timeout;
+
+	mmc->card_caps = 0;
+
+	/* Read the SCR to find out if this card supports higher speeds */
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0;
+
+	timeout = 3;
+
+retry_scr:
+	data.dest = (char *)scr;
+	data.blocksize = 8;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	err = mmc_send_cmd(mmc, &cmd, &data);
+
+	if (err) {
+		if (timeout--)
+			goto retry_scr;
+
+		return err;
+	}
+
+	mmc->scr[0] = scr[0];
+	mmc->scr[1] = scr[1];
+
+	_info("SCR: %08x\n\r", mmc->scr[0]);
+	_info("     %08x\n\r", mmc->scr[1]);
+
+	switch ((mmc->scr[0] >> 24) & 0xf) {
+		case 0:
+			mmc->version = SD_VERSION_1_0;
+			break;
+		case 1:
+			mmc->version = SD_VERSION_1_10;
+			break;
+		case 2:
+			mmc->version = SD_VERSION_2;
+			break;
+		default:
+			mmc->version = SD_VERSION_1_0;
+			break;
+	}
+
+	if (mmc->scr[0] & SD_DATA_4BIT)
+		mmc->card_caps |= MMC_MODE_4BIT;
+
+	/* Version 1.0 doesn't support switching */
+	if (mmc->version == SD_VERSION_1_0)
+		return 0;
+
+	timeout = 4;
+	while (timeout--) {
+		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
+				(char *)switch_status);
+
+		if (err)
+			return err;
+
+		_info("switch status 7 %08x\n\r", switch_status[7]);
+		_info("switch status 3 %08x\n\r", switch_status[3]);
+		_info("switch status 4 %08x\n\r", switch_status[4]);
+		/* The high-speed function is busy.  Try again */
+		if (!(switch_status[7] & SD_HIGHSPEED_BUSY))
+			break;
+	}
+
+	/* If high-speed isn't supported, we return */
+	if (!(switch_status[3] & SD_HIGHSPEED_SUPPORTED))
+		return 0;
+
+	/*
+	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
+	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
+	 * This can avoid furthur problem when the card runs in different
+	 * mode between the host.
+	 */
+	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
+		(mmc->host_caps & MMC_MODE_HS)))
+		return 0;
+
+	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (char *)switch_status);
+
+	if (err)
+		return err;
+
+	if ((switch_status[4] & 0x0f000000) == 0x01000000)
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+
+static int mmc_change_freq(struct mmc *mmc)
+{
+	char ext_csd[512];
+	char cardtype;
+	int err;
+
+	mmc->card_caps = 0;
+
+	/* Only version 4 supports high-speed */
+	if (mmc->version < MMC_VERSION_4)
+		return 0;
+
+	err = mmc_send_ext_csd(mmc, ext_csd);
+
+	if (err)
+		return err;
+
+	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
+
+	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
+
+	if (err)
+		return err;
+
+	/* Now check to see that it worked */
+	err = mmc_send_ext_csd(mmc, ext_csd);
+
+	if (err)
+		return err;
+
+	/* No high-speed support */
+	if (!ext_csd[EXT_CSD_HS_TIMING])
+		return 0;
+
+	/* High Speed is set, there are two types: 52MHz and 26MHz */
+	if (cardtype & MMC_HS_52MHZ)
+		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
+	else
+		mmc->card_caps |= MMC_MODE_HS;
+
+	return 0;
+}
+
+static int mmc_startup(struct mmc *mmc)
+{
+	int err, width;
+	uint mult, freq;
+	uint cmult, csize, capacity;
+	struct mmc_cmd cmd;
+	char ext_csd[512];
+	char test_csd[512];
+	int timeout = 1000;
+
+	/* Put the Card in Identify Mode */
+	cmd.cmdidx = MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
+	cmd.resp_type = MMC_RSP_R2;
+	cmd.cmdarg = 0;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err) {
+		_info("mmc_send_cmd err line %d\n", __LINE__);
+		return err;
+	}
+
+	memcpy(mmc->cid, cmd.response, 16);
+
+	/*
+	 * For MMC cards, set the Relative Address.
+	 * For SD cards, get the Relatvie Address.
+	 * This also puts the cards into Standby State
+	 */
+	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
+	cmd.cmdarg = mmc->rca << 16;
+	cmd.resp_type = MMC_RSP_R6;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	if (err) {
+                _info("mmc_send_cmd err line %d\n", __LINE__);
+                return err;
+        }
+
+	if (IS_SD(mmc))
+		mmc->rca = (cmd.response[0] >> 16) & 0xffff;
+
+	/* Get the Card-Specific Data */
+	cmd.cmdidx = MMC_CMD_SEND_CSD;
+	cmd.resp_type = MMC_RSP_R2;
+	cmd.cmdarg = mmc->rca << 16;
+
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+	/* Waiting for the ready status */
+	mmc_send_status(mmc, timeout);
+
+        if (err) {              
+                _info("mmc_send_cmd err line %d\n", __LINE__);
+                return err;
+        }
+
+	mmc->csd[0] = cmd.response[0];
+	mmc->csd[1] = cmd.response[1];
+	mmc->csd[2] = cmd.response[2];
+	mmc->csd[3] = cmd.response[3];
+
+	if (mmc->version == MMC_VERSION_UNKNOWN) {
+		int version = (cmd.response[0] >> 26) & 0xf;
+
+		switch (version) {
+			case 0:
+				mmc->version = MMC_VERSION_1_2;
+				break;
+			case 1:
+				mmc->version = MMC_VERSION_1_4;
+				break;
+			case 2:
+				mmc->version = MMC_VERSION_2_2;
+				break;
+			case 3:
+				mmc->version = MMC_VERSION_3;
+				break;
+			case 4:
+				mmc->version = MMC_VERSION_4;
+				break;
+			default:
+				mmc->version = MMC_VERSION_1_2;
+				break;
+		}
+	}
+
+	/* divide frequency by 10, since the mults are 10x bigger */
+	freq = fbase[(cmd.response[0] & 0x7)];
+	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
+
+	mmc->tran_speed = freq * mult;
+
+	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
+
+	if (IS_SD(mmc))
+		mmc->write_bl_len = mmc->read_bl_len;
+	else
+		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
+
+	if (mmc->high_capacity) {
+		csize = (mmc->csd[1] & 0x3f) << 16
+			| (mmc->csd[2] & 0xffff0000) >> 16;
+		cmult = 8;
+	} else {
+		csize = (mmc->csd[1] & 0x3ff) << 2
+			| (mmc->csd[2] & 0xc0000000) >> 30;
+		cmult = (mmc->csd[2] & 0x00038000) >> 15;
+	}
+
+	mmc->capacity = (csize + 1) << (cmult + 2);
+	mmc->capacity *= mmc->read_bl_len;
+
+	if (mmc->read_bl_len > 512)
+		mmc->read_bl_len = 512;
+
+	if (mmc->write_bl_len > 512)
+		mmc->write_bl_len = 512;
+
+	/* Select the card, and put it into Transfer Mode */
+	cmd.cmdidx = MMC_CMD_SELECT_CARD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca << 16;
+	err = mmc_send_cmd(mmc, &cmd, NULL);
+
+        if (err) {              
+                _info("mmc_send_cmd err line %d\n", __LINE__);
+                return err;
+        }	
+
+	/*
+	 * For SD, its erase group is always one sector
+	 */
+	mmc->erase_grp_size = 1;
+	mmc->part_config = MMCPART_NOAVAILABLE;
+	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
+		/* check  ext_csd version and capacity */
+		err = mmc_send_ext_csd(mmc, ext_csd);
+		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
+			/*
+			 * According to the JEDEC Standard, the value of
+			 * ext_csd's capacity is valid if the value is more
+			 * than 2GB
+			 */
+			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
+					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
+					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
+					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
+			capacity *= 512;
+			if ((capacity >> 20) > 2 * 1024)
+				mmc->capacity = capacity;
+		}
+
+		/*
+		 * Check whether GROUP_DEF is set, if yes, read out
+		 * group size from ext_csd directly, or calculate
+		 * the group size from the csd value.
+		 */
+		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
+			mmc->erase_grp_size =
+			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
+		else {
+			int erase_gsz, erase_gmul;
+			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
+			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
+			mmc->erase_grp_size = (erase_gsz + 1)
+				* (erase_gmul + 1);
+		}
+
+		/* store the partition info of emmc */
+		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
+		    ext_csd[EXT_CSD_BOOT_MULT])
+			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
+	}
+
+	if (IS_SD(mmc))
+		err = sd_change_freq(mmc);
+	else
+		err = mmc_change_freq(mmc);
+
+        if (err) {              
+                _info("mmc_send_cmd err line %d\n", __LINE__);
+                return err;
+        }
+
+	/* Restrict card's capabilities by what the host can do */
+	mmc->card_caps &= mmc->host_caps;
+
+	if (IS_SD(mmc)) {
+		if (mmc->card_caps & MMC_MODE_4BIT) {
+			cmd.cmdidx = MMC_CMD_APP_CMD;
+			cmd.resp_type = MMC_RSP_R1;
+			cmd.cmdarg = mmc->rca << 16;
+
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+			if (err)
+				return err;
+
+			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
+			cmd.resp_type = MMC_RSP_R1;
+			cmd.cmdarg = 2;
+			err = mmc_send_cmd(mmc, &cmd, NULL);
+			if (err)
+				return err;
+
+			mmc_set_bus_width(mmc, 4);
+		}
+
+		if (mmc->card_caps & MMC_MODE_HS)
+			mmc->tran_speed = 50000000;
+		else
+			mmc->tran_speed = 25000000;
+	} else {
+		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
+			 MMC_MODE_WIDTH_BITS_SHIFT);
+		for (; width >= 0; width--) {
+			/* Set the card to use 4 bit*/
+			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
+					EXT_CSD_BUS_WIDTH, width);
+
+			if (err)
+				continue;
+
+			if (!width) {
+				mmc_set_bus_width(mmc, 1);
+				break;
+			} else
+				mmc_set_bus_width(mmc, 4 * width);
+
+			err = mmc_send_ext_csd(mmc, test_csd);
+			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
+				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
+				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
+				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
+				 && ext_csd[EXT_CSD_REV] \
+				    == test_csd[EXT_CSD_REV]
+				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
+				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
+				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
+					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {
+
+				mmc->card_caps |= width;
+				break;
+			}
+		}
+
+		if (mmc->card_caps & MMC_MODE_HS) {
+			if (mmc->card_caps & MMC_MODE_HS_52MHz)
+				mmc->tran_speed = 52000000;
+			else
+				mmc->tran_speed = 26000000;
+		}
+	}
+
+	mmc_set_clock(mmc, mmc->tran_speed);
+
+	return 0;
+}
+
+static int mmc_set_blocklen(struct mmc *mmc, int len)
+{
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = len;
+
+	return mmc_send_cmd(mmc, &cmd, NULL);
+}
+
+static int mmc_read_blocks(struct mmc *mmc, void *dst, size_t start, size_t blkcnt)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+
+	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * mmc->read_bl_len;
+
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = dst;
+	data.blocks = blkcnt;
+	data.blocksize = mmc->read_bl_len;
+	data.flags = MMC_DATA_READ;
+
+	if (mmc_send_cmd(mmc, &cmd, &data))
+		return 0;
+
+	if (blkcnt > 1) {
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
+		if (mmc_send_cmd(mmc, &cmd, NULL)) {
+			_info("mmc fail to send stop cmd\n");
+			return 0;
+		}
+	}
+
+	return blkcnt;
+}
+
+int mmc_init(struct mmc *mmc)
+{
+	int err;
+
+	if (mmc->has_init)
+		return 0;
+
+	_info("mmc->init\n");
+	err = mmc->init(mmc);
+
+	if (err)
+		return err;
+
+	_info("mmc->set bus width\n");
+	mmc_set_bus_width(mmc, 1);
+	_info("mmc->set clock\n");
+	mmc_set_clock(mmc, 1);
+
+	/* Reset the Card */
+	_info("mmc->go idle\n");
+	err = mmc_go_idle(mmc);
+
+	if (err)
+		return err;
+
+	/* The internal partition reset to user partition(0) at every CMD0*/
+	mmc->part_num = 0;
+
+	/* Test for SD version 2 */
+	_info("mmc->send if cond\n");
+	err = mmc_send_if_cond(mmc);
+
+	/* Now try to get the SD card's operating condition */
+	_info("mmc->send op cond\n");
+	err = sd_send_op_cond(mmc);
+
+	/* If the command timed out, we check for an MMC card */
+	if (err == TIMEOUT) {
+		_info("mmc->send op cond 2\n");
+		err = mmc_send_op_cond(mmc);
+
+		if (err) {
+			_info("Card did not respond to voltage select!\n\r");
+			return UNUSABLE_ERR;
+		}
+	}
+
+	_info("mmc->startup\n");
+	err = mmc_startup(mmc);
+	if (err)
+		mmc->has_init = 0;
+	else
+		mmc->has_init = 1;
+	_info("mmc->init done\n");
+	return err;
+}
+
+size_t mmc_bread(struct mmc *mmc, size_t start, size_t blkcnt, void *dst)
+{
+	size_t cur, blocks_todo = blkcnt;
+
+	if (blkcnt == 0)
+		return 0;
+
+	if ((start + blkcnt) > mmc->capacity / mmc->read_bl_len) {
+		_info("MMC: block number 0x%lx exceeds max(0x%lx)\n",
+			start + blkcnt, mmc->capacity / mmc->read_bl_len);
+		return 0;
+	}
+
+	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
+		return 0;
+
+	do {
+		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
+		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
+			return 0;
+		blocks_todo -= cur;
+		start += cur;
+		dst += cur * mmc->read_bl_len;
+	} while (blocks_todo > 0);
+
+	return blkcnt;
+}
+
+void print_mmcinfo(struct mmc *mmc)
+{
+	_info("Device: %s\n\r", mmc->name);
+	_info("Manufacturer ID: %x\n\r", mmc->cid[0] >> 24);
+	_info("OEM: %x\n\r", (mmc->cid[0] >> 8) & 0xffff);
+	_info("Name: %c%c%c%c%c \n\r", mmc->cid[0] & 0xff,
+			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
+			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
+
+	_info("Tran Speed: %d\n\r", mmc->tran_speed);
+	_info("Rd Block Len: %d\n\r", mmc->read_bl_len);
+
+	_info("%s version %d.%d\n\r", IS_SD(mmc) ? "SD" : "MMC",
+			(mmc->version >> 4) & 0xf, mmc->version & 0xf);
+
+	_info("High Capacity: %s\n\r", mmc->high_capacity ? "Yes" : "No");
+	_info("Capacity: %ld\n\r", mmc->capacity);
+
+	_info("Bus Width: %d-bit\n\r", mmc->bus_width);
+}
+
+
+
diff -Naur apps-12.8.0/testing/smp/src/mmc.h apps/testing/smp/src/mmc.h
--- apps-12.8.0/testing/smp/src/mmc.h	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/src/mmc.h	2025-11-04 11:04:41.210227879 +0200
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2008,2010 Freescale Semiconductor, Inc
+ * Andy Fleming
+ *
+ * Based (loosely) on the Linux code
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef _MMC_H_
+#define _MMC_H_
+
+#include <sys/types.h>
+
+#define SD_VERSION_SD	0x20000
+#define SD_VERSION_2	(SD_VERSION_SD | 0x20)
+#define SD_VERSION_1_0	(SD_VERSION_SD | 0x10)
+#define SD_VERSION_1_10	(SD_VERSION_SD | 0x1a)
+#define MMC_VERSION_MMC		0x10000
+#define MMC_VERSION_UNKNOWN	(MMC_VERSION_MMC)
+#define MMC_VERSION_1_2		(MMC_VERSION_MMC | 0x12)
+#define MMC_VERSION_1_4		(MMC_VERSION_MMC | 0x14)
+#define MMC_VERSION_2_2		(MMC_VERSION_MMC | 0x22)
+#define MMC_VERSION_3		(MMC_VERSION_MMC | 0x30)
+#define MMC_VERSION_4		(MMC_VERSION_MMC | 0x40)
+
+#define MMC_MODE_HS		0x001
+#define MMC_MODE_HS_52MHz	0x010
+#define MMC_MODE_4BIT		0x100
+#define MMC_MODE_8BIT		0x200
+#define MMC_MODE_SPI		0x400
+#define MMC_MODE_HC		0x800
+
+#define MMC_MODE_MASK_WIDTH_BITS (MMC_MODE_4BIT | MMC_MODE_8BIT)
+#define MMC_MODE_WIDTH_BITS_SHIFT 8
+
+#define SD_DATA_4BIT	0x00040000
+
+#define IS_SD(x) (x->version & SD_VERSION_SD)
+
+#define MMC_DATA_READ		1
+#define MMC_DATA_WRITE		2
+
+#define NO_CARD_ERR		-16 /* No SD/MMC card inserted */
+#define UNUSABLE_ERR		-17 /* Unusable Card */
+#define COMM_ERR		-18 /* Communications Error */
+#define TIMEOUT			-19
+
+#define MMC_CMD_GO_IDLE_STATE		0
+#define MMC_CMD_SEND_OP_COND		1
+#define MMC_CMD_ALL_SEND_CID		2
+#define MMC_CMD_SET_RELATIVE_ADDR	3
+#define MMC_CMD_SET_DSR			4
+#define MMC_CMD_SWITCH			6
+#define MMC_CMD_SELECT_CARD		7
+#define MMC_CMD_SEND_EXT_CSD		8
+#define MMC_CMD_SEND_CSD		9
+#define MMC_CMD_SEND_CID		10
+#define MMC_CMD_STOP_TRANSMISSION	12
+#define MMC_CMD_SEND_STATUS		13
+#define MMC_CMD_SET_BLOCKLEN		16
+#define MMC_CMD_READ_SINGLE_BLOCK	17
+#define MMC_CMD_READ_MULTIPLE_BLOCK	18
+#define MMC_CMD_WRITE_SINGLE_BLOCK	24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK	25
+#define MMC_CMD_ERASE_GROUP_START	35
+#define MMC_CMD_ERASE_GROUP_END		36
+#define MMC_CMD_ERASE			38
+#define MMC_CMD_APP_CMD			55
+#define MMC_CMD_SPI_READ_OCR		58
+#define MMC_CMD_SPI_CRC_ON_OFF		59
+
+#define SD_CMD_SEND_RELATIVE_ADDR	3
+#define SD_CMD_SWITCH_FUNC		6
+#define SD_CMD_SEND_IF_COND		8
+
+#define SD_CMD_APP_SET_BUS_WIDTH	6
+#define SD_CMD_ERASE_WR_BLK_START	32
+#define SD_CMD_ERASE_WR_BLK_END		33
+#define SD_CMD_APP_SEND_OP_COND		41
+#define SD_CMD_APP_SEND_SCR		51
+
+/* SCR definitions in different words */
+#define SD_HIGHSPEED_BUSY	0x00020000
+#define SD_HIGHSPEED_SUPPORTED	0x00020000
+
+#define MMC_HS_TIMING		0x00000100
+#define MMC_HS_52MHZ		0x2
+
+#define OCR_BUSY		0x80000000
+#define OCR_HCS			0x40000000
+#define OCR_VOLTAGE_MASK	0x007FFF80
+#define OCR_ACCESS_MODE		0x60000000
+
+#define SECURE_ERASE		0x80000000
+
+#define MMC_STATUS_MASK		(~0x0206BF7F)
+#define MMC_STATUS_RDY_FOR_DATA (1 << 8)
+#define MMC_STATUS_CURR_STATE	(0xf << 9)
+#define MMC_STATUS_ERROR	(1 << 19)
+
+#define MMC_STATE_PRG		(7 << 9)
+
+#define MMC_VDD_165_195		0x00000080	/* VDD voltage 1.65 - 1.95 */
+#define MMC_VDD_20_21		0x00000100	/* VDD voltage 2.0 ~ 2.1 */
+#define MMC_VDD_21_22		0x00000200	/* VDD voltage 2.1 ~ 2.2 */
+#define MMC_VDD_22_23		0x00000400	/* VDD voltage 2.2 ~ 2.3 */
+#define MMC_VDD_23_24		0x00000800	/* VDD voltage 2.3 ~ 2.4 */
+#define MMC_VDD_24_25		0x00001000	/* VDD voltage 2.4 ~ 2.5 */
+#define MMC_VDD_25_26		0x00002000	/* VDD voltage 2.5 ~ 2.6 */
+#define MMC_VDD_26_27		0x00004000	/* VDD voltage 2.6 ~ 2.7 */
+#define MMC_VDD_27_28		0x00008000	/* VDD voltage 2.7 ~ 2.8 */
+#define MMC_VDD_28_29		0x00010000	/* VDD voltage 2.8 ~ 2.9 */
+#define MMC_VDD_29_30		0x00020000	/* VDD voltage 2.9 ~ 3.0 */
+#define MMC_VDD_30_31		0x00040000	/* VDD voltage 3.0 ~ 3.1 */
+#define MMC_VDD_31_32		0x00080000	/* VDD voltage 3.1 ~ 3.2 */
+#define MMC_VDD_32_33		0x00100000	/* VDD voltage 3.2 ~ 3.3 */
+#define MMC_VDD_33_34		0x00200000	/* VDD voltage 3.3 ~ 3.4 */
+#define MMC_VDD_34_35		0x00400000	/* VDD voltage 3.4 ~ 3.5 */
+#define MMC_VDD_35_36		0x00800000	/* VDD voltage 3.5 ~ 3.6 */
+
+#define MMC_SWITCH_MODE_CMD_SET		0x00 /* Change the command set */
+#define MMC_SWITCH_MODE_SET_BITS	0x01 /* Set bits in EXT_CSD byte
+						addressed by index which are
+						1 in value field */
+#define MMC_SWITCH_MODE_CLEAR_BITS	0x02 /* Clear bits in EXT_CSD byte
+						addressed by index, which are
+						1 in value field */
+#define MMC_SWITCH_MODE_WRITE_BYTE	0x03 /* Set target byte to value */
+
+#define SD_SWITCH_CHECK		0
+#define SD_SWITCH_SWITCH	1
+
+/*
+ * EXT_CSD fields
+ */
+#define EXT_CSD_PARTITIONING_SUPPORT	160	/* RO */
+#define EXT_CSD_ERASE_GROUP_DEF		175	/* R/W */
+#define EXT_CSD_PART_CONF		179	/* R/W */
+#define EXT_CSD_BUS_WIDTH		183	/* R/W */
+#define EXT_CSD_HS_TIMING		185	/* R/W */
+#define EXT_CSD_REV			192	/* RO */
+#define EXT_CSD_CARD_TYPE		196	/* RO */
+#define EXT_CSD_SEC_CNT			212	/* RO, 4 bytes */
+#define EXT_CSD_HC_ERASE_GRP_SIZE	224	/* RO */
+#define EXT_CSD_BOOT_MULT		226	/* RO */
+
+/*
+ * EXT_CSD field definitions
+ */
+
+#define EXT_CSD_CMD_SET_NORMAL		(1 << 0)
+#define EXT_CSD_CMD_SET_SECURE		(1 << 1)
+#define EXT_CSD_CMD_SET_CPSECURE	(1 << 2)
+
+#define EXT_CSD_CARD_TYPE_26	(1 << 0)	/* Card can run at 26MHz */
+#define EXT_CSD_CARD_TYPE_52	(1 << 1)	/* Card can run at 52MHz */
+
+#define EXT_CSD_BUS_WIDTH_1	0	/* Card is in 1 bit mode */
+#define EXT_CSD_BUS_WIDTH_4	1	/* Card is in 4 bit mode */
+#define EXT_CSD_BUS_WIDTH_8	2	/* Card is in 8 bit mode */
+
+#define R1_ILLEGAL_COMMAND		(1 << 22)
+#define R1_APP_CMD			(1 << 5)
+
+#define MMC_RSP_PRESENT (1 << 0)
+#define MMC_RSP_136	(1 << 1)		/* 136 bit response */
+#define MMC_RSP_CRC	(1 << 2)		/* expect valid crc */
+#define MMC_RSP_BUSY	(1 << 3)		/* card may send busy */
+#define MMC_RSP_OPCODE	(1 << 4)		/* response contains opcode */
+
+#define MMC_RSP_NONE	(0)
+#define MMC_RSP_R1	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1b	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE| \
+			MMC_RSP_BUSY)
+#define MMC_RSP_R2	(MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3	(MMC_RSP_PRESENT)
+#define MMC_RSP_R4	(MMC_RSP_PRESENT)
+#define MMC_RSP_R5	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7	(MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+
+#define MMCPART_NOAVAILABLE	(0xff)
+#define PART_ACCESS_MASK	(0x7)
+#define PART_SUPPORT		(0x1)
+
+struct mmc_cid {
+	unsigned long psn;
+	unsigned short oid;
+	unsigned char mid;
+	unsigned char prv;
+	unsigned char mdt;
+	char pnm[7];
+};
+
+struct mmc_cmd {
+	ushort cmdidx;
+	uint resp_type;
+	uint cmdarg;
+	uint response[4];
+};
+
+struct mmc_data {
+	union {
+		char *dest;
+		const char *src; /* src buffers don't get written to */
+	};
+	uint flags;
+	uint blocks;
+	uint blocksize;
+};
+
+struct mmc {
+//	struct list_head link;
+	char name[32];
+	void *priv;
+	uint voltages;
+	uint version;
+	uint has_init;
+	uint f_min;
+	uint f_max;
+	int high_capacity;
+	uint bus_width;
+	uint clock;
+	uint card_caps;
+	uint host_caps;
+	uint ocr;
+	uint scr[2];
+	uint csd[4];
+	uint cid[4];
+	ushort rca;
+	char part_config;
+	char part_num;
+	uint tran_speed;
+	uint read_bl_len;
+	uint write_bl_len;
+	uint erase_grp_size;
+	size_t capacity;
+//	block_dev_desc_t block_dev;
+	int (*send_cmd)(struct mmc *mmc,
+			struct mmc_cmd *cmd, struct mmc_data *data);
+	void (*set_ios)(struct mmc *mmc);
+	int (*init)(struct mmc *mmc);
+	int (*getcd)(struct mmc *mmc);
+	uint b_max;
+};
+
+int mmc_init(struct mmc *mmc);
+size_t mmc_bread(struct mmc *mmc, size_t start, size_t blkcnt, void *dst);
+void print_mmcinfo(struct mmc *mmc);
+
+#endif /* _MMC_H_ */
diff -Naur apps-12.8.0/testing/smp/src/ocsdc.c apps/testing/smp/src/ocsdc.c
--- apps-12.8.0/testing/smp/src/ocsdc.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/src/ocsdc.c	2025-11-04 11:04:41.211227298 +0200
@@ -0,0 +1,309 @@
+/*
+ * WISHBONE SD Card Controller IP Core
+ *
+ * ocsdc.c
+ *
+ * This file is part of the WISHBONE SD Card
+ * Controller IP Core project
+ * http://opencores.org/project,sd_card_controller
+ *
+ * Description
+ * Driver for the WISHBONE SD Card Controller IP Core.
+ *
+ * Author(s):
+ *     - Marek Czerski, ma.czerski@gmail.com
+ */
+/*
+ *
+ * Copyright (C) 2013 Authors
+ *
+ * This source file may be used and distributed without
+ * restriction provided that this copyright statement is not
+ * removed from the file and that any derivative work contains
+ * the original copyright notice and the associated disclaimer.
+ *
+ * This source file is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU Lesser General
+ * Public License as published by the Free Software Foundation;
+ * either version 2.1 of the License, or (at your option) any
+ * later version.
+ *
+ * This source is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ * PURPOSE. See the GNU Lesser General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this source; if not, download it
+ * from http://www.opencores.org/lgpl.shtml
+ */
+
+#include "mmc.h"
+#include <malloc.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <debug.h>
+//#include <or1k-support.h>
+
+// Register space
+#define OCSDC_ARGUMENT           0x00
+#define OCSDC_COMMAND            0x04
+#define OCSDC_RESPONSE_1         0x08
+#define OCSDC_RESPONSE_2         0x0c
+#define OCSDC_RESPONSE_3         0x10
+#define OCSDC_RESPONSE_4         0x14
+#define OCSDC_CONTROL 			 0x1C
+#define OCSDC_TIMEOUT            0x20
+#define OCSDC_CLOCK_DIVIDER      0x24
+#define OCSDC_SOFTWARE_RESET     0x28
+#define OCSDC_POWER_CONTROL      0x2C
+#define OCSDC_CAPABILITY         0x30
+#define OCSDC_CMD_INT_STATUS     0x34
+#define OCSDC_CMD_INT_ENABLE     0x38
+#define OCSDC_DAT_INT_STATUS     0x3C
+#define OCSDC_DAT_INT_ENABLE     0x40
+#define OCSDC_BLOCK_SIZE         0x44
+#define OCSDC_BLOCK_COUNT        0x48
+#define OCSDC_DST_SRC_ADDR       0x60
+
+// OCSDC_CMD_INT_STATUS bits
+#define OCSDC_CMD_INT_STATUS_CC   0x0001
+#define OCSDC_CMD_INT_STATUS_EI   0x0002
+#define OCSDC_CMD_INT_STATUS_CTE  0x0004
+#define OCSDC_CMD_INT_STATUS_CCRC 0x0008
+#define OCSDC_CMD_INT_STATUS_CIE  0x0010
+
+// SDCMSC_DAT_INT_STATUS
+#define SDCMSC_DAT_INT_STATUS_TRS 0x01
+#define SDCMSC_DAT_INT_STATUS_CRC 0x02
+#define SDCMSC_DAT_INT_STATUS_OV  0x04
+
+struct ocsdc {
+	int iobase;
+	int clk_freq;
+};
+
+#define readl(addr) (*(volatile unsigned int *) (addr))
+#define writel(b, addr) ((*(volatile unsigned int *) (addr)) = (b))
+
+void flush_dcache_range(void * start, void * end) {
+	while (start < end) {
+		//or1k_dcache_flush((unsigned long)start);
+		start += 4;
+	}
+}
+
+static inline uint32_t ocsdc_read(struct ocsdc *dev, int offset)
+{
+	//_info("read from %x\n", (dev->iobase + offset));
+	return readl(dev->iobase + offset);
+}
+
+static inline void ocsdc_write(struct ocsdc *dev, int offset, uint32_t data)
+{
+	//_info("write to %x\n", (dev->iobase + offset));
+	writel(data, dev->iobase + offset);
+}
+
+static void ocsdc_set_buswidth(struct ocsdc * dev, uint width) {
+	if (width == 4)
+		ocsdc_write(dev, OCSDC_CONTROL, 1);
+	else if (width == 1)
+		ocsdc_write(dev, OCSDC_CONTROL, 0);
+}
+
+/* Set clock prescalar value based on the required clock in HZ */
+static void ocsdc_set_clock(struct ocsdc * dev, uint clock)
+{
+	int clk_div = dev->clk_freq / (2.0 * clock) - 1;
+
+	_info("ocsdc_set_clock %d, div %d\n\r", clock, clk_div);
+	//software reset
+	ocsdc_write(dev, OCSDC_SOFTWARE_RESET, 1);
+	//set clock devider
+	ocsdc_write(dev, OCSDC_CLOCK_DIVIDER, clk_div);
+	//clear software reset
+	ocsdc_write(dev, OCSDC_SOFTWARE_RESET, 0);
+}
+
+static int ocsdc_finish(struct ocsdc * dev, struct mmc_cmd *cmd) {
+
+	int retval = 0;
+	while (1) {
+		int r2 = ocsdc_read(dev, OCSDC_CMD_INT_STATUS);
+		//_info("ocsdc_finish: cmd %d, status %x\n", cmd->cmdidx, r2);
+		if (r2 & OCSDC_CMD_INT_STATUS_EI) {
+			//clear interrupts
+			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
+			_info("ocsdc_finish: cmd %d, status %x\n\r", cmd->cmdidx, r2);
+			retval = -1;
+			break;
+		}
+		else if (r2 & OCSDC_CMD_INT_STATUS_CC) {
+			//clear interrupts
+			ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
+			//get response
+			cmd->response[0] = ocsdc_read(dev, OCSDC_RESPONSE_1);
+			if (cmd->resp_type & MMC_RSP_136) {
+				cmd->response[1] = ocsdc_read(dev, OCSDC_RESPONSE_2);
+				cmd->response[2] = ocsdc_read(dev, OCSDC_RESPONSE_3);
+				cmd->response[3] = ocsdc_read(dev, OCSDC_RESPONSE_4);
+			}
+			_info("ocsdc_finish:  %d ok\n\r", cmd->cmdidx);
+			retval = 0;
+
+			break;
+		}
+		//else if (!(r2 & OCSDC_CMD_INT_STATUS_CIE)) {
+		//	_info("ocsdc_finish: cmd %d no exec %x\n", cmd->cmdidx, r2);
+		//}
+	}
+	return retval;
+}
+
+static int ocsdc_data_finish(struct ocsdc * dev) {
+	int status;
+
+    while ((status = ocsdc_read(dev, OCSDC_DAT_INT_STATUS)) == 0);
+    ocsdc_write(dev, OCSDC_DAT_INT_STATUS, 0);
+
+    if (status & SDCMSC_DAT_INT_STATUS_TRS) {
+    	_info("ocsdc_data_finish: ok\n\r");
+    	return 0;
+    }
+    else {
+    	_info("ocsdc_data_finish: status %x\n\r", status);
+    	return -1;
+    }
+}
+
+static void ocsdc_setup_data_xfer(struct ocsdc * dev, struct mmc_cmd *cmd, struct mmc_data *data) {
+
+	//invalidate cache
+	if (data->flags & MMC_DATA_READ) {
+		flush_dcache_range(data->dest, data->dest+data->blocksize*data->blocks);
+		ocsdc_write(dev, OCSDC_DST_SRC_ADDR, (uint32_t)data->dest);
+	}
+	else {
+		flush_dcache_range((void *)data->src, (void *)data->src+data->blocksize*data->blocks);
+		ocsdc_write(dev, OCSDC_DST_SRC_ADDR, (uint32_t)data->src);
+	}
+	ocsdc_write(dev, OCSDC_BLOCK_SIZE, data->blocksize-1);
+	ocsdc_write(dev, OCSDC_BLOCK_COUNT, data->blocks-1);
+
+	//_info("ocsdc_setup_read: addr: %x\n", (uint32_t)data->dest);
+
+}
+
+static int ocsdc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
+{
+	struct ocsdc * dev = mmc->priv;
+
+	int command = (cmd->cmdidx << 8);
+	if (cmd->resp_type & MMC_RSP_PRESENT) {
+		if (cmd->resp_type & MMC_RSP_136)
+			command |= 2;
+		else {
+			command |= 1;
+		}
+	}
+	if (cmd->resp_type & MMC_RSP_BUSY)
+		command |= (1 << 2);
+	if (cmd->resp_type & MMC_RSP_CRC)
+		command |= (1 << 3);
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		command |= (1 << 4);
+
+	if (data && ((data->flags & MMC_DATA_READ) || ((data->flags & MMC_DATA_WRITE))) && data->blocks) {
+		if (data->flags & MMC_DATA_READ)
+			command |= (1 << 5);
+		if (data->flags & MMC_DATA_WRITE)
+			command |= (1 << 6);
+		ocsdc_setup_data_xfer(dev, cmd, data);
+	}
+
+	_info("ocsdc_send_cmd %04x\n\r", command);
+
+//	getc();
+
+	ocsdc_write(dev, OCSDC_COMMAND, command);
+	ocsdc_write(dev, OCSDC_ARGUMENT, cmd->cmdarg);
+
+	int err=0;
+	if ((err = ocsdc_finish(dev, cmd)) < 0) {
+		_info("sdc_finish %d\n", err);
+		return -1;
+	}
+	if (data && data->blocks) return ocsdc_data_finish(dev);
+	else return 0;
+}
+
+/* Initialize ocsdc controller */
+static int ocsdc_init(struct mmc *mmc)
+{
+	struct ocsdc * dev = mmc->priv;
+
+	//set timeout
+	ocsdc_write(dev, OCSDC_TIMEOUT, 0x7FFF);
+	//disable all interrupts
+	ocsdc_write(dev, OCSDC_CMD_INT_ENABLE, 0);
+	ocsdc_write(dev, OCSDC_DAT_INT_ENABLE, 0);
+	//clear all interrupts
+	ocsdc_write(dev, OCSDC_CMD_INT_STATUS, 0);
+	ocsdc_write(dev, OCSDC_DAT_INT_STATUS, 0);
+	//set clock to maximum (divide by 2)
+	ocsdc_set_clock(dev, dev->clk_freq/2);
+
+	return 0;
+}
+
+static void ocsdc_set_ios(struct mmc *mmc)
+{
+	/* Support only 4 bit if */
+	ocsdc_set_buswidth(mmc->priv, mmc->bus_width);
+
+	/* Set clock speed */
+	if (mmc->clock)
+		ocsdc_set_clock(mmc->priv, mmc->clock);
+}
+
+struct mmc * ocsdc_mmc_init(int base_addr, int clk_freq)
+{
+	struct mmc *mmc;
+	struct ocsdc *priv;
+
+	mmc = malloc(sizeof(struct mmc));
+	if (!mmc) goto MMC_ALLOC;
+	priv = malloc(sizeof(struct ocsdc));
+	if (!priv) goto OCSDC_ALLOC;
+
+	memset(mmc, 0, sizeof(struct mmc));
+	memset(priv, 0, sizeof(struct ocsdc));
+
+	priv->iobase = base_addr;
+	priv->clk_freq = clk_freq;
+
+	sprintf(mmc->name, "ocsdc");
+	mmc->priv = priv;
+	mmc->send_cmd = ocsdc_send_cmd;
+	mmc->set_ios = ocsdc_set_ios;
+	mmc->init = ocsdc_init;
+	mmc->getcd = NULL;
+
+	mmc->f_min = priv->clk_freq/64; /*maximum clock division 64 */
+	mmc->f_max = priv->clk_freq/2; /*minimum clock division 2 */
+	mmc->voltages = MMC_VDD_32_33 | MMC_VDD_33_34;
+	mmc->host_caps = MMC_MODE_4BIT;//MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
+
+	mmc->b_max = 256;
+
+	return mmc;
+
+OCSDC_ALLOC:
+	free(mmc);
+MMC_ALLOC:
+	return NULL;
+}
diff -Naur apps-12.8.0/testing/smp/src/sdc_example.c apps/testing/smp/src/sdc_example.c
--- apps-12.8.0/testing/smp/src/sdc_example.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/smp/src/sdc_example.c	2025-11-04 11:04:41.210227879 +0200
@@ -0,0 +1,120 @@
+/*
+ * WISHBONE SD Card Controller IP Core
+ *
+ * sd_example.c
+ *
+ * This file is part of the WISHBONE SD Card
+ * Controller IP Core project
+ * http://opencores.org/project,sd_card_controller
+ *
+ * Description
+ * Example application using WISHBONE SD Card Controller
+ * IP Core. The app perform core initialisation,
+ * mmc/sd card initialisation and then reads one block
+ * of data from the card.
+ * This app is using some of code from u-boot project
+ * (mmc.c and mmc.h)
+ *
+ * Author(s):
+ *     - Marek Czerski, ma.czerski@gmail.com
+ */
+/*
+ *
+ * Copyright (C) 2013 Authors
+ *
+ * This source file may be used and distributed without
+ * restriction provided that this copyright statement is not
+ * removed from the file and that any derivative work contains
+ * the original copyright notice and the associated disclaimer.
+ *
+ * This source file is free software; you can redistribute it
+ * and/or modify it under the terms of the GNU Lesser General
+ * Public License as published by the Free Software Foundation;
+ * either version 2.1 of the License, or (at your option) any
+ * later version.
+ *
+ * This source is distributed in the hope that it will be
+ * useful, but WITHOUT ANY WARRANTY; without even the implied
+ * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
+ * PURPOSE. See the GNU Lesser General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this source; if not, download it
+ * from http://www.opencores.org/lgpl.shtml
+ */
+
+#include "mmc.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <debug.h>
+
+struct mmc * ocsdc_mmc_init(int base_addr, int clk_freq);
+
+#define BLKSIZE 512
+#define BLKCNT 10
+
+char buff[BLKSIZE*BLKCNT] = {'\0'};
+
+void printHex(const void *lpvbits, const unsigned int n) {
+    char* data = (char*) lpvbits;
+    unsigned int i = 0;
+    char line[17] = {};
+    _info("%.8X | ", (unsigned int)data);
+    while ( i < n ) {
+        line[i%16] = *(data+i);
+        if ((line[i%16] < 32) || (line[i%16] > 126)) {
+            line[i%16] = '.';
+        }
+        _info("%.2X", (unsigned char)*(data+i));
+        i++;
+        if (i%4 == 0) {
+            if (i%16 == 0) {
+                if (i < n-1)
+                    _info(" | %s\n\r%.8X | ", line, (unsigned int)data+i);
+            } else {
+                _info(" ");
+            }
+        }
+    }
+    while (i%16 > 0) {
+        (i%4 == 0)?_info("   "):_info("  ");
+        line[i%16] = ' ';
+        i++;
+    }
+    _info(" | %s\n\r", line);
+}
+
+int sdc_main(void) {
+	_info("Hello World !!!\n\r");
+
+	//init ocsdc driver
+	struct mmc * drv = ocsdc_mmc_init(0x40008000/*0x9e000000*/, 27000000);
+	if (!drv) {
+		_info("ocsdc_mmc_init failed\n\r");
+		return -1;
+	}
+	_info("ocsdc_mmc_init success\n\r");
+
+	drv->has_init = 0;
+	int err = mmc_init(drv);
+	if (err != 0 || drv->has_init == 0) {
+		_info("mmc_init failed err=%d has_init=%d\n\r", err, drv->has_init);
+		return -1;
+	}
+	_info("mmc_init success\n\r");
+
+	print_mmcinfo(drv);
+
+	//read 1 block
+	_info("attempting to read 1 block\n\r");
+	if (mmc_bread(drv, 0, 1, buff) == 0) {
+		_info("mmc_bread failed\n\r");
+		return -1;
+	}
+	_info("mmc_bread success\n\r");
+
+	printHex(buff, BLKSIZE);
+
+	return EXIT_SUCCESS;
+}
diff -Naur apps-12.8.0/videoutils/Kconfig apps/videoutils/Kconfig
--- apps-12.8.0/videoutils/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/videoutils/Kconfig	2025-11-04 11:04:40.928393044 +0200
@@ -0,0 +1,11 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Video Utility libraries"
+source "/home/laur/lucru/rtos/apps/videoutils/openh264/Kconfig"
+source "/home/laur/lucru/rtos/apps/videoutils/x264/Kconfig"
+endmenu # Video Utility libraries
diff -Naur apps-12.8.0/wireless/bluetooth/Kconfig apps/wireless/bluetooth/Kconfig
--- apps-12.8.0/wireless/bluetooth/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/wireless/bluetooth/Kconfig	2025-11-04 11:04:41.265195912 +0200
@@ -0,0 +1,11 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Bluetooth applications"
+source "/home/laur/lucru/rtos/apps/wireless/bluetooth/btsak/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/bluetooth/nimble/Kconfig"
+endmenu # Bluetooth applications
diff -Naur apps-12.8.0/wireless/ieee802154/Kconfig apps/wireless/ieee802154/Kconfig
--- apps-12.8.0/wireless/ieee802154/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/wireless/ieee802154/Kconfig	2025-11-04 11:04:41.286183706 +0200
@@ -0,0 +1,13 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "IEEE 802.15.4 applications"
+source "/home/laur/lucru/rtos/apps/wireless/ieee802154/i8sak/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/ieee802154/i8shark/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/ieee802154/libmac/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/ieee802154/libutils/Kconfig"
+endmenu # IEEE 802.15.4 applications
diff -Naur apps-12.8.0/wireless/Kconfig apps/wireless/Kconfig
--- apps-12.8.0/wireless/Kconfig	1970-01-01 02:00:00.000000000 +0200
+++ apps/wireless/Kconfig	2025-11-04 11:04:41.288182544 +0200
@@ -0,0 +1,14 @@
+#
+# For a description of the syntax of this configuration file,
+# see the file kconfig-language.txt in the NuttX tools repository.
+#
+# This file is autogenerated, do not edit.
+#
+
+menu "Wireless Libraries and NSH Add-Ons"
+source "/home/laur/lucru/rtos/apps/wireless/bluetooth/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/gs2200m/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/ieee802154/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/iwpan/Kconfig"
+source "/home/laur/lucru/rtos/apps/wireless/wapi/Kconfig"
+endmenu # Wireless Libraries and NSH Add-Ons

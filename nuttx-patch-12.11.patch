diff -Naur nuttx-12.11/arch/risc-v/src/common/riscv_mtimer.c nuttx/arch/risc-v/src/common/riscv_mtimer.c
--- nuttx-12.11/arch/risc-v/src/common/riscv_mtimer.c	2025-06-02 09:58:00.000000000 +0300
+++ nuttx/arch/risc-v/src/common/riscv_mtimer.c	2025-12-06 14:01:59.936724454 +0200
@@ -464,6 +464,7 @@
   return 0;
 }
 
+int tints=0;
 static int riscv_mtimer_interrupt(int irq, void *context, void *arg)
 {
   struct riscv_mtimer_lowerhalf_s *priv = arg;
@@ -473,6 +474,7 @@
       priv->callback(&priv->lower, priv->arg);
     }
 
+  tints++;
   return 0;
 }
 
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/hardware/qemu_rv_clint.h nuttx/arch/risc-v/src/qemu-rv/hardware/qemu_rv_clint.h
--- nuttx-12.11/arch/risc-v/src/qemu-rv/hardware/qemu_rv_clint.h	2024-12-06 17:03:15.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/hardware/qemu_rv_clint.h	2025-12-06 14:01:59.927723429 +0200
@@ -28,8 +28,8 @@
  ****************************************************************************/
 
 #define QEMU_RV_CLINT_MSIP      (QEMU_RV_CLINT_BASE + 0x0000)
-#define QEMU_RV_CLINT_MTIMECMP  (QEMU_RV_CLINT_BASE + 0x4000)
-#define QEMU_RV_CLINT_MTIME     (QEMU_RV_CLINT_BASE + 0xbff8)
+#define QEMU_RV_CLINT_MTIMECMP  (QEMU_RV_CLINT_BASE + 0x0010)
+#define QEMU_RV_CLINT_MTIME     (QEMU_RV_CLINT_BASE + 0x0008)
 
 #define QEMU_RV_ACLINT_SSIP     (QEMU_RV_ACLINT_BASE + 0x0000)
 
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/hardware/qemu_rv_memorymap.h nuttx/arch/risc-v/src/qemu-rv/hardware/qemu_rv_memorymap.h
--- nuttx-12.11/arch/risc-v/src/qemu-rv/hardware/qemu_rv_memorymap.h	2024-12-06 17:03:15.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/hardware/qemu_rv_memorymap.h	2025-12-06 14:01:59.927723429 +0200
@@ -32,13 +32,13 @@
 #ifdef CONFIG_ARCH_CHIP_QEMU_RV_PLIC
 #  define QEMU_RV_PLIC_BASE    CONFIG_ARCH_CHIP_QEMU_RV_PLIC
 #else
-#  define QEMU_RV_PLIC_BASE    0xc000000
+#  define QEMU_RV_PLIC_BASE    0x40000200 //0x50000000
 #endif
 
 #ifdef CONFIG_ARCH_CHIP_QEMU_RV_CLINT
 #  define QEMU_RV_CLINT_BASE   CONFIG_ARCH_CHIP_QEMU_RV_CLINT
 #else
-#  define QEMU_RV_CLINT_BASE   0x2000000
+#  define QEMU_RV_CLINT_BASE   0x40000000
 #endif
 
 #ifdef CONFIG_ARCH_CHIP_QEMU_RV_ACLINT
@@ -47,7 +47,7 @@
 #  define QEMU_RV_ACLINT_BASE  0x2f00000
 #endif
 
-#define   QEMU_RV_RESET_BASE   0x100000
+#define   QEMU_RV_RESET_BASE   0x0 //0x100000
 
 #ifdef CONFIG_ARCH_USE_S_MODE
 #  define QEMU_RV_APLIC_BASE   0x0d000000
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/hardware/qemu_rv_plic.h nuttx/arch/risc-v/src/qemu-rv/hardware/qemu_rv_plic.h
--- nuttx-12.11/arch/risc-v/src/qemu-rv/hardware/qemu_rv_plic.h	2024-12-06 17:03:15.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/hardware/qemu_rv_plic.h	2025-12-06 14:01:59.927723429 +0200
@@ -45,7 +45,7 @@
 #  define QEMU_RV_PLIC_ENABLE1   (QEMU_RV_PLIC_BASE + 0x002000)
 #  define QEMU_RV_PLIC_ENABLE2   (QEMU_RV_PLIC_BASE + 0x002004)
 #  define QEMU_RV_PLIC_THRESHOLD (QEMU_RV_PLIC_BASE + 0x200000)
-#  define QEMU_RV_PLIC_CLAIM     (QEMU_RV_PLIC_BASE + 0x200004)
+#  define QEMU_RV_PLIC_CLAIM      QEMU_RV_PLIC_BASE //(QEMU_RV_PLIC_BASE + 0x200004)
 #endif
 
 #endif /* __ARCH_RISCV_SRC_QEMU_RV_HARDWARE_QEMU_RV_PLIC_H */
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_head.S nuttx/arch/risc-v/src/qemu-rv/qemu_rv_head.S
--- nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_head.S	2024-12-06 17:03:15.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/qemu_rv_head.S	2025-12-06 14:01:59.927723429 +0200
@@ -44,10 +44,18 @@
   .global __start
 
 __start:
+  lui     t3,0x40004
+  li      t4,0x31
+  sw      t4,0xc(t3)
+
 #else
   .global __start_s
 
 __start_s:
+  lui     t3,0x40008
+  li      t4,0x31
+  sw      t4,0(t3)
+
 #endif
 
   /* Preserve a1 as it contains the pointer to DTB */
@@ -57,6 +65,8 @@
   li   t1, CONFIG_SMP_NCPUS
 
   /* If a0 (mhartid) >= t1 (the number of CPUs), stop here */
+  // laur
+  csrr a0, CSR_MHARTID
 
   blt  a0, t1, 2f
   csrw CSR_IE, zero
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_irq.c nuttx/arch/risc-v/src/qemu-rv/qemu_rv_irq.c
--- nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_irq.c	2025-03-03 14:57:13.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/qemu_rv_irq.c	2025-12-06 14:01:59.927723429 +0200
@@ -116,6 +116,8 @@
   riscv_aplic_init(QEMU_RV_APLIC_BASE, RISCV_APLIC_ENABLE_IDELIVERY,
                                        RISCV_APLIC_ENABLE_ITHRESHOLD);
 #else
+  // laur
+  #if 0
   /* Set priority for all global interrupts to 1 (lowest) */
 
   for (id = 1; id <= 52; id++)
@@ -126,6 +128,7 @@
   /* Set irq threshold to 0 (permits all global interrupts) */
 
   putreg32(0, QEMU_RV_PLIC_THRESHOLD);
+  #endif
 #endif
 
   /* Attach the common interrupt handler */
@@ -209,8 +212,10 @@
       if (0 <= extirq && extirq <= 63)
         {
 #ifndef CONFIG_ARCH_RV_HAVE_APLIC
+	  #if 0
           modifyreg32(QEMU_RV_PLIC_ENABLE1 + (4 * (extirq / 32)),
                       1 << (extirq % 32), 0);
+          #endif
 #else
           riscv_aplic_disable_irq(QEMU_RV_APLIC_BASE, extirq);
 #endif
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c nuttx/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c
--- nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c	2025-03-03 14:57:13.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/qemu_rv_irq_dispatch.c	2025-12-06 14:27:13.550010841 +0200
@@ -26,6 +26,8 @@
 
 #include <nuttx/config.h>
 
+#include <debug.h>
+
 #include <stdint.h>
 #include <assert.h>
 
@@ -80,12 +82,15 @@
 {
   int extirq;
 
+  _info("--------\n");
   while ((extirq = getreg32(QEMU_RV_PLIC_CLAIM)) != 0)
     {
+      _info("--extirq=%x\n", extirq);
       regs = riscv_doirq(irq + extirq, regs);
       putreg32(extirq, QEMU_RV_PLIC_CLAIM);
     }
 
+  _info("---extirq=%x\n", extirq);
   return regs;
 }
 #endif
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_start.c nuttx/arch/risc-v/src/qemu-rv/qemu_rv_start.c
--- nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_start.c	2025-06-02 09:58:00.000000000 +0300
+++ nuttx/arch/risc-v/src/qemu-rv/qemu_rv_start.c	2025-12-06 14:01:59.926723315 +0200
@@ -172,8 +172,10 @@
 
   if (mhartid > 0)
     {
+      up_putc('\\');
       goto cpux;
-    }
+    } else
+      up_putc('/');
 
   qemu_rv_clear_bss();
 
@@ -219,7 +221,7 @@
 #endif
 
   /* Call nx_start() */
-
+  _info("nx start ...\n");
   nx_start();
 
 cpux:
diff -Naur nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_timerisr.c nuttx/arch/risc-v/src/qemu-rv/qemu_rv_timerisr.c
--- nuttx-12.11/arch/risc-v/src/qemu-rv/qemu_rv_timerisr.c	2024-12-06 17:03:15.000000000 +0200
+++ nuttx/arch/risc-v/src/qemu-rv/qemu_rv_timerisr.c	2025-12-06 14:01:59.927723429 +0200
@@ -48,8 +48,8 @@
  * Pre-processor Definitions
  ****************************************************************************/
 
-#define MTIMER_FREQ 10000000
-#define TICK_COUNT (10000000 / TICK_PER_SEC)
+#define MTIMER_FREQ 27000000
+#define TICK_COUNT (27000000 / TICK_PER_SEC)
 
 /****************************************************************************
  * Public Functions
diff -Naur nuttx-12.11/boards/risc-v/qemu-rv/rv-virt/src/Makefile nuttx/boards/risc-v/qemu-rv/rv-virt/src/Makefile
--- nuttx-12.11/boards/risc-v/qemu-rv/rv-virt/src/Makefile	2025-06-02 09:58:01.000000000 +0300
+++ nuttx/boards/risc-v/qemu-rv/rv-virt/src/Makefile	2025-12-06 14:02:00.446785665 +0200
@@ -25,6 +25,7 @@
 RCSRCS = etc/init.d/rc.sysinit etc/init.d/rcS
 
 CSRCS = qemu_rv_appinit.c
+CSRCS += sksoc_boot.c
 
 ifeq ($(CONFIG_BUILD_KERNEL),y)
 ifeq ($(CONFIG_RISCV_SEMIHOSTING_HOSTFS),)
diff -Naur nuttx-12.11/boards/risc-v/qemu-rv/rv-virt/src/sksoc_boot.c nuttx/boards/risc-v/qemu-rv/rv-virt/src/sksoc_boot.c
--- nuttx-12.11/boards/risc-v/qemu-rv/rv-virt/src/sksoc_boot.c	1970-01-01 02:00:00.000000000 +0200
+++ nuttx/boards/risc-v/qemu-rv/rv-virt/src/sksoc_boot.c	2025-12-06 14:02:00.446785665 +0200
@@ -0,0 +1,67 @@
+/****************************************************************************
+ * boards/risc-v/rv32m1/rv32m1-vega/src/sksoc_boot.c
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+#include <debug.h>
+
+#include <nuttx/board.h>
+#include <arch/board/board.h>
+#include <arch/irq.h>
+
+int riscv_ext_int_1(int irq, void *c, void *arg)
+{
+        // interrupt ack
+        //*(int *) 0x3ffffffc = 1;
+        //_info("ext int\n");
+
+	_info("riscv_ext_int_1\n");
+	*(volatile int *) (0x4000c000+1500+4) = 0;
+        return 0;
+}
+int riscv_ext_int_2(int irq, void *c, void *arg)
+{
+        // interrupt ack
+        //*(int *) 0x3ffffffc = 1;
+        //_info("ext int\n");
+
+        _info("riscv_ext_int_2\n");
+        *(volatile int *) (0x4000c000+1500+4) = 0;
+        return 0;
+}
+void qemu_rv_boardinitialize(void)
+{
+  // net init
+  // interrupt
+  int ret=0;
+  ret = irq_attach(RISCV_IRQ_EXT+1, riscv_ext_int_1, NULL);
+  _info("irq_attach %x returns %d\n", RISCV_IRQ_EXT+1, ret);
+  ret = irq_attach(RISCV_IRQ_EXT+2, riscv_ext_int_2, NULL);
+  _info("irq_attach %x returns %d\n", RISCV_IRQ_EXT+2, ret);  
+  _info("setting enableirq");
+  *(volatile int *) (0x4000c000+1500+28) = 1;
+  _info("setting enableirq done");
+}
+
diff -Naur nuttx-12.11/drivers/mmcsd/Kconfig nuttx/drivers/mmcsd/Kconfig
--- nuttx-12.11/drivers/mmcsd/Kconfig	2025-06-02 09:58:01.000000000 +0300
+++ nuttx/drivers/mmcsd/Kconfig	2025-12-06 14:02:00.329771519 +0200
@@ -87,6 +87,10 @@
 	default y
 	depends on SPI
 
+config MMCSD_HWSOC
+	bool "MMC/SD HWSoC transfer support"
+	default n      
+
 if MMCSD_SPI
 
 config MMCSD_SPICLOCK
diff -Naur nuttx-12.11/drivers/mmcsd/Make.defs nuttx/drivers/mmcsd/Make.defs
--- nuttx-12.11/drivers/mmcsd/Make.defs	2024-12-06 17:03:15.000000000 +0200
+++ nuttx/drivers/mmcsd/Make.defs	2025-12-06 14:02:00.329771519 +0200
@@ -32,6 +32,10 @@
 CSRCS += mmcsd_spi.c mmcsd_debug.c
 endif
 
+ifeq ($(CONFIG_MMCSD_HWSOC),y)
+CSRCS += mmcsd_hwsoc.c
+endif
+
 ifeq ($(CONFIG_MMCSD_PROCFS),y)
 CSRCS += mmcsd_procfs.c
 endif
diff -Naur nuttx-12.11/drivers/mmcsd/mmcsd_hwsoc.c nuttx/drivers/mmcsd/mmcsd_hwsoc.c
--- nuttx-12.11/drivers/mmcsd/mmcsd_hwsoc.c	1970-01-01 02:00:00.000000000 +0200
+++ nuttx/drivers/mmcsd/mmcsd_hwsoc.c	2025-12-06 14:02:00.328771398 +0200
@@ -0,0 +1,693 @@
+/****************************************************************************
+ * drivers/mmcsd/mmcsd_hwsoc.c
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.  The
+ * ASF licenses this file to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance with the
+ * License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <nuttx/config.h>
+
+#if defined (CONFIG_MMCSD) && defined (CONFIG_MMCSD_HWSOC)
+
+#include <sys/types.h>
+
+#include <inttypes.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <stdio.h>
+#include <string.h>
+#include <time.h>
+#include <assert.h>
+#include <errno.h>
+#include <debug.h>
+#include <unistd.h>
+
+#include <nuttx/arch.h>
+#include <nuttx/clock.h>
+#include <nuttx/mutex.h>
+#include <nuttx/signal.h>
+#include <nuttx/spi/spi.h>
+#include <nuttx/fs/fs.h>
+#include <nuttx/mmcsd.h>
+
+#include "mmcsd.h"
+
+/****************************************************************************
+ * Pre-processor Definitions
+ ****************************************************************************/
+
+/* Configuration ************************************************************/
+
+#if !defined(CONFIG_MMCSD_READONLY)
+#  define MMCSD_MODE 0666
+#else
+#  define MMCSD_MODE 0444
+#endif
+
+#ifndef CONFIG_MMCSD_SECTOR512
+#  define CONFIG_MMCSD_SECTOR512          /* Force 512 byte sectors on all cards */
+#endif
+
+/* Slot struct info *********************************************************/
+
+/* Slot status definitions */
+
+#define MMCSD_SLOTSTATUS_NOTREADY    0x01 /* Card not initialized */
+#define MMCSD_SLOTSTATUS_NODISK      0x02 /* No card in the slot */
+#define MMCSD_SLOTSTATUS_WRPROTECT   0x04 /* Card is write protected */
+#define MMCSD_SLOTSTATUS_MEDIACHGD   0x08 /* Media changed in slot */
+
+/* HWSOC */
+#define MMCSD_HWSOC_BADDR ((volatile unsigned char *) 0x40008200)
+
+/* Values in the MMC/SD command table ***************************************/
+
+#ifdef CONFIG_MMCSD_SECTOR512
+#  define SECTORSIZE(s)              (512)
+#else
+#  define SECTORSIZE(s)              ((s)->sectorsize)
+#endif
+
+/* Time delays in units of the system clock. CLK_TCK is the number of clock
+ * ticks per second.
+ */
+
+#define MMCSD_DELAY_10MS             (CLK_TCK/100  + 1)
+#define MMCSD_DELAY_50MS             (CLK_TCK/20   + 1)
+#define MMCSD_DELAY_100MS            (CLK_TCK/10   + 1)
+#define MMCSD_DELAY_250MS            (CLK_TCK/4    + 1)
+#define MMCSD_DELAY_500MS            (CLK_TCK/2    + 1)
+#define MMCSD_DELAY_1SEC             (CLK_TCK      + 1)
+#define MMCSD_DELAY_10SEC            (10 * CLK_TCK + 1)
+
+#define ELAPSED_TIME(t)              (clock_systime_ticks()-(t))
+#define START_TIME                   (clock_systime_ticks())
+
+/****************************************************************************
+ * Private Types
+ ****************************************************************************/
+
+/* This structure represents the state of one card slot */
+
+struct mmcsd_slot_s
+{
+  FAR struct spi_dev_s *spi; /* SPI port bound to this slot */
+  mutex_t  lock;             /* Assures mutually exclusive access to card and SPI */
+  uint8_t  state;            /* State of the slot (see MMCSD_SLOTSTATUS_* definitions) */
+  uint8_t  type;             /* Disk type */
+  uint8_t  csd[16];          /* Copy of card CSD */
+#ifndef CONFIG_MMCSD_SECTOR512
+  uint16_t sectorsize;       /* Media block size (in bytes) */
+#endif
+  uint32_t nsectors;         /* Number of blocks on the media */
+  uint32_t taccess;          /* Card access time */
+  uint32_t twrite;           /* Card write time */
+  uint32_t ocr;              /* Last 4 bytes of OCR (R3) */
+  uint32_t r7;               /* Last 4 bytes of R7 */
+  uint32_t spispeed;         /* Speed to use for SPI in data mode */
+};
+
+struct mmcsd_cmdinfo_s
+{
+  uint8_t  cmd;
+  uint8_t  resp;
+  uint8_t  chksum;
+};
+
+/****************************************************************************
+ * Private Function Prototypes
+ ****************************************************************************/
+
+/* Misc *********************************************************************/
+
+static int      mmcsd_lock(FAR struct mmcsd_slot_s *slot);
+static void     mmcsd_unlock(FAR struct mmcsd_slot_s *slot);
+
+/* Block driver interfaces **************************************************/
+
+static int       mmcsd_open(FAR struct inode *inode);
+static int       mmcsd_close(FAR struct inode *inode);
+static ssize_t   mmcsd_read(FAR struct inode *inode,
+                            FAR unsigned char *buffer,
+                            blkcnt_t start_sector, unsigned int nsectors);
+#if !defined(CONFIG_MMCSD_READONLY)
+static ssize_t   mmcsd_write(FAR struct inode *inode,
+                             FAR const unsigned char *buffer,
+                             blkcnt_t start_sector,
+                             unsigned int nsectors);
+#endif
+static int       mmcsd_geometry(FAR struct inode *inode,
+                                FAR struct geometry *geometry);
+
+/****************************************************************************
+ * Private Data
+ ****************************************************************************/
+
+/* Driver state *************************************************************/
+
+/* These are the lock driver methods supported by this file */
+
+static const struct block_operations g_bops =
+{
+  mmcsd_open,     /* open     */
+  mmcsd_close,    /* close    */
+  mmcsd_read,     /* read     */
+#if !defined(CONFIG_MMCSD_READONLY)
+  mmcsd_write,    /* write    */
+#else
+  NULL,           /* write    */
+#endif
+  mmcsd_geometry, /* geometry */
+  NULL            /* ioctl    */
+};
+
+/* A slot structure allocated for each configured slot */
+
+static struct mmcsd_slot_s g_mmcsdslot[CONFIG_MMCSD_NSLOTS];
+
+/* Timing *******************************************************************/
+// the mmcsd clock frequency is board clock / 2
+
+/****************************************************************************
+ * Private Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: mmcsd_lock
+ ****************************************************************************/
+
+static int mmcsd_lock(FAR struct mmcsd_slot_s *slot)
+{
+  int ret;
+
+  /* Get exclusive access to the MMC/SD device (possibly unnecessary if
+   * SPI_LOCK is also implemented as a mutex).
+   */
+
+  ret = nxmutex_lock(&slot->lock);
+  if (ret < 0)
+    {
+      return ret;
+    }
+
+  return ret;
+}
+
+/****************************************************************************
+ * Name: mmcsd_unlock
+ ****************************************************************************/
+
+static void mmcsd_unlock(FAR struct mmcsd_slot_s *slot)
+{
+  nxmutex_unlock(&slot->lock);
+}
+
+/****************************************************************************
+ * Name: mmcsd_waitready
+ *
+ * Description:
+ *   Wait until the card is no longer busy
+ *
+ * Assumptions:
+ *   MMC/SD card already selected
+ *
+ ****************************************************************************/
+
+/*
+static int mmcsd_waitready(FAR struct mmcsd_slot_s *slot)
+{
+  nxsig_usleep(10000);
+  return 0;//-EBUSY;
+}
+*/
+
+/****************************************************************************
+ * Name: mmcsd_getcardinfo
+ *
+ * Description:
+ *   Read CSD or CID  registers
+ *
+ * Assumptions:
+ *   MMC/SD card already selected
+ *
+ ****************************************************************************/
+
+/****************************************************************************
+ * Block Driver Operations
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: mmcsd_open
+ *
+ * Description: Open the block device
+ *
+ ****************************************************************************/
+
+static int mmcsd_open(FAR struct inode *inode)
+{
+  FAR struct mmcsd_slot_s *slot;
+  int ret;
+
+  //_info("Entry\n");
+
+#ifdef CONFIG_DEBUG_FEATURES
+  if (!inode || !inode->i_private)
+    {
+      _info("ERROR: Internal confusion\n");
+      return -EIO;
+    }
+#endif
+
+  /* Extract our private data from the inode structure */
+
+  slot = inode->i_private;
+
+  ret = mmcsd_lock(slot);
+  if (ret < 0)
+    {
+      return ret;
+    }
+
+  /* Verify that an MMC/SD card has been inserted */
+  ret = 0; //-ENODEV;
+
+  mmcsd_unlock(slot);
+  return ret;
+}
+
+/****************************************************************************
+ * Name: mmcsd_close
+ *
+ * Description: close the block device
+ *
+ ****************************************************************************/
+
+static int mmcsd_close(FAR struct inode *inode)
+{
+  //_info("Entry\n");
+  return OK;
+}
+
+/****************************************************************************
+ * Name: mmcsd_read
+ *
+ * Description:  Read the specified number of sectors
+ *
+ ****************************************************************************/
+
+#define wait_not_busy(baddr, status) \
+          do { \
+                nxsig_usleep(10); \
+                status = *(volatile int *)(baddr - 0x200); \
+                /*if(status & 0x100ff) _info("r status=%x\n", status);*/ \
+          } while ((status & 0x100ff))
+
+static ssize_t mmcsd_read(FAR struct inode *inode, FAR unsigned char *buffer,
+                          blkcnt_t start_sector, unsigned int nsectors)
+{
+  FAR struct mmcsd_slot_s *slot;
+  size_t nbytes;
+  off_t offset;
+  volatile unsigned int i, j, status;
+  int ret;
+  volatile unsigned char *baddr=MMCSD_HWSOC_BADDR;
+
+  //_info("start_sector=%" PRIuOFF " nsectors=%u\n", start_sector, nsectors);
+
+#ifdef CONFIG_DEBUG_FEATURES
+  if (!buffer)
+    {
+      _info("ERROR: Invalid parameters\n");
+      return -EINVAL;
+    }
+
+  if (!inode || !inode->i_private)
+    {
+      _info("ERROR: Internal confusion\n");
+      return -EIO;
+    }
+#endif
+
+  /* Extract our private data from the inode structure */
+
+  slot = inode->i_private;
+
+  /* Verify that card is available */
+
+  /* Do nothing on zero-length transfer */
+
+  if (nsectors < 1)
+    {
+      return 0;
+    }
+
+  /* Convert sector and nsectors to nbytes and byte offset */
+
+  nbytes = nsectors * SECTORSIZE(slot);
+  UNUSED(nbytes);
+
+      offset = start_sector;
+      //_info("nbytes=%zu sector offset=%" PRIdOFF "\n", nbytes, offset);
+
+  /* Select the slave */
+
+  ret = mmcsd_lock(slot);
+  if (ret < 0)
+    {
+      return (ssize_t)ret;
+    }
+
+  /* Single or multiple block read? */
+  wait_not_busy(baddr, status);
+
+  if (nsectors == 1)
+    {
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = offset;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        buffer[i] = *(volatile unsigned char *)(baddr + i);
+    }
+  else
+    {
+      /* Receive each block */
+      for (j = 0; j < nsectors; j++)
+        {
+          // tell hw what sector to read
+          *(volatile int *)(baddr - 0x200 + 0) = offset+j;
+          // wait for the hardware to fill its buffer
+          wait_not_busy(baddr, status);
+          for(i=0; i<0x200; i++)
+            buffer[(j<<9)+i] = *(volatile unsigned char *)(baddr + i);
+        }
+    }
+
+  /* On success, return the number of sectors transfer */
+
+  mmcsd_unlock(slot);
+
+  //_info("Read %zu bytes:\n", nbytes);
+  mmcsd_dumpbuffer("Read buffer", buffer, nbytes);
+  return nsectors;
+
+}
+
+/****************************************************************************
+ * Name: mmcsd_write
+ *
+ * Description:
+ *   Write the specified number of sectors
+ *
+ ****************************************************************************/
+
+#if !defined(CONFIG_MMCSD_READONLY)
+static ssize_t mmcsd_write(FAR struct inode *inode,
+                           FAR const unsigned char *buffer,
+                           blkcnt_t start_sector, unsigned int nsectors)
+{
+  FAR struct mmcsd_slot_s *slot;
+  size_t nbytes;
+  off_t offset;
+  volatile unsigned int i, j, status;
+  int ret;
+  volatile unsigned char *baddr=MMCSD_HWSOC_BADDR;
+
+  //_info("start_sector=%" PRIuOFF " nsectors=%u\n", start_sector, nsectors);
+
+#ifdef CONFIG_DEBUG_FEATURES
+  if (!buffer)
+    {
+      _info("ERROR: Invalid parameters\n");
+      return -EINVAL;
+    }
+
+  if (!inode || !inode->i_private)
+    {
+      _info("ERROR: Internal confusion\n");
+      return -EIO;
+    }
+#endif
+
+  /* Extract our private data from the inode structure */
+
+  slot = inode->i_private;
+
+  /* Verify that card is available */
+
+  /* Verify that the card is write enabled */
+
+  /* Do nothing on zero-length transfer */
+
+  if (nsectors < 1)
+    {
+      return 0;
+    }
+
+  /* Convert sector and nsectors to nbytes and byte offset */
+
+  nbytes = nsectors * SECTORSIZE(slot);
+  UNUSED(nbytes);
+
+      offset = start_sector;
+      //_info("nbytes=%zu sector offset=%" PRIdOFF "\n", nbytes, offset);
+
+  mmcsd_dumpbuffer("Write buffer", buffer, nbytes);
+
+  /* Select the slave */
+
+  ret = mmcsd_lock(slot);
+  if (ret < 0)
+    {
+      return (ssize_t)ret;
+    }
+
+  /* Single or multiple block transfer? */
+  wait_not_busy(baddr, status);
+
+  if (nsectors == 1)
+    {
+      // fill hw buffer with user data
+      for(i = 0; i < 0x200; i++) {
+                *(volatile unsigned char*)(baddr+i) = buffer[i];
+        }
+      /* Then transfer the sector */
+      *(volatile int *)(baddr - 0x200 + 4) = offset;
+      // wait writing
+      wait_not_busy(baddr, status);
+    }
+  else
+    {
+      for(j=0; j < nsectors; j++) {
+        // fill hw buffer with user data
+        for(i = 0; i < 0x200; i++) {
+                *(volatile unsigned char*)(baddr+i) = buffer[(j<<9)+i];
+        }
+        /* Then transfer the sector */
+        *(volatile int *)(baddr - 0x200 + 4) = offset+j;
+        // wait writing
+        wait_not_busy(baddr, status);
+      }
+    }
+
+  /* Wait until the card is no longer busy */
+  mmcsd_unlock(slot);
+
+  /* The success return value is the number of sectors written */
+
+  return nsectors;
+}
+#endif
+
+/****************************************************************************
+ * Name: mmcsd_geometry
+ *
+ * Description:
+ *   Return device geometry
+ *
+ ****************************************************************************/
+
+// we use only 8GB cards, so 16*2**30/2**10=16M of 512 byte blocks.
+// nsectors must be equal to partition total sectors
+// else modify fs/fat/fs_fat32util.c  if (!fs->fs_fattotsec || fs->fs_fattotsec > fs->fs_hwnsectors)
+int real_geometry_nsectors=16*1024*1024; //15562744;
+void set_real_geometry_nsectors(int nsectors)
+{
+  _info("set real_geometry_nsectors to %d\n", nsectors);
+  real_geometry_nsectors = nsectors;
+}
+
+static int mmcsd_geometry(FAR struct inode *inode,
+                          FAR struct geometry *geometry)
+{
+  FAR struct mmcsd_slot_s *slot;
+  int ret;
+
+#ifdef CONFIG_DEBUG_FEATURES
+  if (!geometry)
+    {
+      _info("ERROR: Invalid parameters\n");
+      return -EINVAL;
+    }
+
+  if (!inode || !inode->i_private)
+    {
+      _info("ERROR: Internal confusion\n");
+      return -EIO;
+    }
+#endif
+
+  /* Extract our private data from the inode structure */
+
+  slot = inode->i_private;
+
+  /* Re-sample the CSD */
+
+  ret = mmcsd_lock(slot);
+  if (ret < 0)
+    {
+      return ret;
+    }
+
+  /* Then return the card geometry */
+
+  memset(geometry, 0, sizeof(*geometry));
+
+  // we boot from this card
+  geometry->geo_available = 1;
+  geometry->geo_mediachanged = ((slot->state & MMCSD_SLOTSTATUS_MEDIACHGD) != 0);
+  geometry->geo_nsectors   =  real_geometry_nsectors;
+#if !defined(CONFIG_MMCSD_READONLY)
+  geometry->geo_writeenabled = 1;
+#else
+  geometry->geo_writeenabled = false;
+#endif
+  geometry->geo_sectorsize = SECTORSIZE(slot);
+
+  /* After reporting mediachanged, clear the indication so that it is not
+   * reported again.
+   */
+  slot->state &= ~MMCSD_SLOTSTATUS_MEDIACHGD;
+
+  mmcsd_unlock(slot);
+
+  finfo("geo_available:     %d\n", geometry->geo_available);
+  finfo("geo_mediachanged:  %d\n", geometry->geo_mediachanged);
+  finfo("geo_writeenabled:  %d\n", geometry->geo_writeenabled);
+  finfo("geo_nsectors:      %" PRIuOFF "\n", geometry->geo_nsectors);
+  finfo("geo_sectorsize:    %" PRIi16 "\n", geometry->geo_sectorsize);
+
+  return OK;
+}
+
+/****************************************************************************
+ * Public Functions
+ ****************************************************************************/
+
+/****************************************************************************
+ * Name: mmcsd_spislotinitialize
+ *
+ * Description:
+ *   Initialize one slot for operation using the SPI MMC/SD interface
+ *
+ * Input Parameters:
+ *   minor - The MMC/SD minor device number.  The MMC/SD device will be
+ *     registered as /dev/mmcsdN where N is the minor number
+ *   slotno - The slot number to use.  This is only meaningful for
+ *     architectures that support multiple MMC/SD slots.  This value must be
+ *     in the range {0, ..., CONFIG_MMCSD_NSLOTS}.
+ *   spi - And instance of an SPI interface obtained by called the
+ *     appropriate xyz_spibus_initialize() function for the MCU "xyz" with
+ *     the appropriate port number.
+ *
+ ****************************************************************************/
+
+int mmcsd_spislotinitialize(int minor, int slotno, FAR struct spi_dev_s *spi)
+{
+  struct mmcsd_slot_s *slot;
+  char devname[16];
+  int ret;
+
+#ifdef CONFIG_DEBUG_FEATURES
+  if ((unsigned)slotno >= CONFIG_MMCSD_NSLOTS || (unsigned)minor > 255)
+    {
+      _info("ERROR: Invalid arguments\n");
+      return -EINVAL;
+    }
+#endif
+
+  /* Select the slot structure */
+
+  slot = &g_mmcsdslot[slotno];
+  memset(slot, 0, sizeof(struct mmcsd_slot_s));
+  nxmutex_init(&slot->lock);
+
+  /* Bind the SPI port to the slot */
+  // not using spi directly
+
+  /* Get exclusive access to the SPI bus and make sure that SPI is properly
+   * configured for the MMC/SD card
+   */
+
+  ret = mmcsd_lock(slot);
+  if (ret < 0)
+    {
+      return ret;
+    }
+
+  /* Initialize for the media in the slot (if any) */
+
+  ret = 0; //mmcsd_mediainitialize(slot);
+  mmcsd_unlock(slot);
+  if (ret == 0)
+    {
+      slot->state |= MMCSD_SLOTSTATUS_MEDIACHGD;
+    }
+
+  /* Create a MMC/SD device name */
+
+  snprintf(devname, sizeof(devname), "/dev/mmcsd%d", minor);
+  _info("devname=%s", devname);
+
+  /* Register the driver, even on a failure condition.  A
+   * card may be inserted later, for example.
+   */
+
+  ret = register_blockdriver(devname, &g_bops, MMCSD_MODE, slot);
+  if (ret < 0)
+    {
+      _info("ERROR: register_blockdriver failed: %d\n", -ret);
+      nxmutex_destroy(&slot->lock);
+      return ret;
+    }
+
+  /* Register a media change callback to handle insertion and
+   * removal of cards.
+   */
+
+  //SPI_REGISTERCALLBACK(spi, mmcsd_mediachanged, slot);
+  //_info("mmcsd_spislotinitialize ok");
+
+  return OK;
+}
+
+#endif /* defined (CONFIG_MMCSD) && defined (CONFIG_MMCSD_HWSOC) */
diff -Naur nuttx-12.11/drivers/serial/serial.c nuttx/drivers/serial/serial.c
--- nuttx-12.11/drivers/serial/serial.c	2025-09-01 14:53:07.000000000 +0300
+++ nuttx/drivers/serial/serial.c	2025-12-06 14:02:00.331771761 +0200
@@ -1496,7 +1496,10 @@
 
           if ((ch == '\n') && (dev->tc_oflag & (ONLCR | ONLRET)) != 0)
             {
-              ret = uart_putxmitchar(dev, '\r', oktoblock);
+	      // laur
+              ret = 1;
+              up_putc('\r');
+              //ret = uart_putxmitchar(dev, '\r', oktoblock);
             }
 
           /* Specifically not handled:
@@ -1512,7 +1515,10 @@
 
       if (ret >= 0)
         {
-          ret = uart_putxmitchar(dev, ch, oktoblock);
+          // laur
+          ret = 1;
+          up_putc(ch);
+          //ret = uart_putxmitchar(dev, ch, oktoblock);
         }
 
       /* uart_putxmitchar() might return an error under one of two
diff -Naur nuttx-12.11/drivers/serial/uart_16550.c nuttx/drivers/serial/uart_16550.c
--- nuttx-12.11/drivers/serial/uart_16550.c	2025-06-02 09:58:01.000000000 +0300
+++ nuttx/drivers/serial/uart_16550.c	2025-12-06 14:02:00.332771881 +0200
@@ -645,10 +645,11 @@
 static inline uart_datawidth_t u16550_serialin(FAR struct u16550_s *priv,
                                                int offset)
 {
+  return 0;
   /* Get correct offset */
 
-  offset *= (priv->regincr * sizeof(uart_datawidth_t));
-  return priv->ops->getreg(priv, offset);
+  //offset *= (priv->regincr * sizeof(uart_datawidth_t));
+  //return priv->ops->getreg(priv, offset);
 }
 
 /****************************************************************************
@@ -660,8 +661,8 @@
 {
   /* Get correct offset */
 
-  offset *= (priv->regincr * sizeof(uart_datawidth_t));
-  priv->ops->putreg(priv, offset, value);
+  //offset *= (priv->regincr * sizeof(uart_datawidth_t));
+  //priv->ops->putreg(priv, offset, value);
 }
 
 #ifdef CONFIG_16550_WAIT_LCR
@@ -682,6 +683,8 @@
 
 static int u16550_wait(FAR struct u16550_s *priv)
 {
+  return OK;
+#if 0
   int i;
 
   for (i = 0; i < UART_TIMEOUT_MS; i++)
@@ -698,6 +701,7 @@
 
   _err("UART timeout\n");
   return ERROR;
+#endif
 }
 #endif /* CONFIG_16550_WAIT_LCR */
 
@@ -1702,12 +1706,18 @@
  *
  ****************************************************************************/
 
+inline void console_putchar(int ch)
+{
+  *(volatile int *) 0x4000400c = ch;
+}
+
 #ifdef HAVE_16550_CONSOLE
 void up_putc(int ch)
 {
-  FAR struct u16550_s *priv = (FAR struct u16550_s *)CONSOLE_DEV.priv;
+  console_putchar(ch);
+  //FAR struct u16550_s *priv = (FAR struct u16550_s *)CONSOLE_DEV.priv;
 
-  u16550_putc(priv, ch);
+  //u16550_putc(priv, ch);
 }
 #endif
 
diff -Naur nuttx-12.11/fs/fat/fs_fat32util.c nuttx/fs/fat/fs_fat32util.c
--- nuttx-12.11/fs/fat/fs_fat32util.c	2024-12-17 07:34:13.000000000 +0200
+++ nuttx/fs/fat/fs_fat32util.c	2025-12-06 14:01:59.899720240 +0200
@@ -48,6 +48,8 @@
  * Private Functions
  ****************************************************************************/
 
+extern void set_real_geometry_nsectors(int nsectors);
+
 /****************************************************************************
  * Name: fat_checkfsinfo
  *
@@ -169,13 +171,26 @@
       fs->fs_fattotsec = FBR_GETTOTSEC32(fs->fs_buffer);
     }
 
-  if (!fs->fs_fattotsec || fs->fs_fattotsec > fs->fs_hwnsectors)
+  //if (!fs->fs_fattotsec || fs->fs_fattotsec > fs->fs_hwnsectors)
+  // laur
+  if (!fs->fs_fattotsec)
+    {
+       fwarn("WARNING: fs_fattotsec %" PRId32
+            "\n",
+            fs->fs_fattotsec);
+      return -EINVAL;
+    }
+  if (fs->fs_fattotsec != fs->fs_hwnsectors)
     {
       fwarn("WARNING: fs_fattotsec %" PRId32
-            " fs_hwnsectors: %" PRIdOFF "\n",
+            //" fs_hwnsectors: %" PRIdOFF "\n",
+	    " fs_hwnsectors: %" PRIdOFF "... setting hwnsectors to fattotsec\n",
             fs->fs_fattotsec, fs->fs_hwnsectors);
 
-      return -EINVAL;
+      // laur
+      //return -EINVAL;
+      fs->fs_hwnsectors = fs->fs_fattotsec;
+      set_real_geometry_nsectors(fs->fs_fattotsec);      
     }
 
   /* Get the total number of reserved sectors */
@@ -540,6 +555,8 @@
    */
 
   ret = fat_checkbootrecord(fs);
+  // laur
+  geo.geo_nsectors = fs->fs_fattotsec;  
   if (ret != OK)
     {
       /* The contents of sector 0 is not a boot record.  It could be have
diff -Naur nuttx-12.11/sched/init/nx_start.c nuttx/sched/init/nx_start.c
--- nuttx-12.11/sched/init/nx_start.c	2025-09-01 14:53:07.000000000 +0300
+++ nuttx/sched/init/nx_start.c	2025-12-06 14:01:59.696697118 +0200
@@ -63,6 +63,8 @@
 #include "instrument/instrument.h"
 #include "tls/tls.h"
 
+extern void qemu_rv_boardinitialize(void);
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
@@ -624,7 +626,7 @@
   fs_initialize();
 
   /* Initialize the interrupt handling subsystem (if included) */
-
+  _info("irq initialize");
   irq_initialize();
 
   /* Initialize the POSIX timer facility (if included in the link) */
@@ -734,6 +736,8 @@
   /* Create initial tasks and bring-up the system */
 
   DEBUGVERIFY(nx_bringup());
+  _info("nx bringup done");
+  qemu_rv_boardinitialize();
 
   /* Enter to idleloop */
 

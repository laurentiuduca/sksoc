diff -Naur apps-12.11/examples/mount/mount_main.c apps/examples/mount/mount_main.c
--- apps-12.11/examples/mount/mount_main.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/examples/mount/mount_main.c	2025-12-06 14:21:22.907996551 +0200
@@ -35,8 +35,10 @@
 #include <fcntl.h>
 #include <dirent.h>
 #include <errno.h>
+#include <debug.h>
 
 #include "mount.h"
+#include <nuttx/mmcsd.h>
 
 /****************************************************************************
  * Pre-processor Definitions
@@ -65,6 +67,10 @@
 #ifdef CONFIG_EXAMPLES_MOUNT_DEVNAME
 static const char g_testfile1[]      = "/mnt/fs/TestDir/TestFile.txt";
 #endif
+static const char g_testdiri[]      = "/mnt/fs/i";
+static const char g_testdirj[]      = "/mnt/fs/j";
+static const char g_testfilej[]      = "/mnt/fs/j/j.txt";
+static const char g_testfilel[]      = "/mnt/fs/WrTest1.txt";
 static const char g_testfile2[]      = "/mnt/fs/TestDir/WrTest1.txt";
 static const char g_testfile3[]      = "/mnt/fs/NewDir1/WrTest2.txt";
 static const char g_testfile4[]      = "/mnt/fs/NewDir3/Renamed.txt";
@@ -606,15 +612,18 @@
 
 #ifndef CONFIG_EXAMPLES_MOUNT_DEVNAME
   /* Create a RAM disk for the test */
-
+  _info("mount_main: creating RAM disk\n");
   ret = create_ramdisk();
   if (ret < 0)
     {
       printf("mount_main: ERROR failed to create RAM disk\n");
       return 1;
-    }
+    } else
+      _info("mount_main: created RAM disk\n");
 #endif
 
+  mmcsd_spislotinitialize(0, 0, 0);
+
   /* Mount the test file system (see arch/sim/src/up_deviceimage.c */
 
   printf("mount_main: mounting %s filesystem at target=%s with source=%s\n",
@@ -625,12 +634,19 @@
 
   if (ret == 0)
     {
-      show_statfs(g_mntdir);
-      show_statfs(g_target);
-
+      //show_statfs(g_mntdir);
+      //show_statfs(g_target);
+      write_test_file(g_testfilel);
+      read_test_file(g_testfilel);
+      succeed_unlink(g_testfilel);
 #ifdef CONFIG_EXAMPLES_MOUNT_DEVNAME
-      /* Read a test file that is already on the test file system image */
+      succeed_mkdir(g_testdir1);
+      show_directories("", 0);
+      succeed_stat(g_testdir1);
+      show_statfs(g_testdir1);
 
+      /* Read a test file that is already on the test file system image */
+      write_test_file(g_testfile1);
       show_directories("", 0);
       succeed_stat(g_testfile1);
       show_statfs(g_testfile1);
diff -Naur apps-12.11/include/fsutils/mkfatfs.h apps/include/fsutils/mkfatfs.h
--- apps-12.11/include/fsutils/mkfatfs.h	2024-12-31 07:17:30.000000000 +0200
+++ apps/include/fsutils/mkfatfs.h	2025-12-06 13:05:30.164215060 +0200
@@ -35,7 +35,7 @@
  ****************************************************************************/
 
 #define MKFATFS_DEFAULT_NFATS        2     /* 2: Default number of FATs */
-#define MKFATFS_DEFAULT_FATTYPE      0     /* 0: Autoselect FAT size */
+#define MKFATFS_DEFAULT_FATTYPE      32     /* 0: Autoselect FAT size */
 #define MKFATFS_DEFAULT_CLUSTSHIFT   0xff  /* 0xff: Autoselect cluster size */
 #define MKFATFS_DEFAULT_VOLUMELABEL  { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' }
 #define MKFATFS_DEFAULT_BKUPBOOT     0     /* 0: Determine sector number of the backup boot sector */
diff -Naur apps-12.11/system/nsh/dhrystone.h apps/system/nsh/dhrystone.h
--- apps-12.11/system/nsh/dhrystone.h	1970-01-01 02:00:00.000000000 +0200
+++ apps/system/nsh/dhrystone.h	2025-12-06 13:06:08.412827354 +0200
@@ -0,0 +1,432 @@
+// See LICENSE for license details.
+
+#ifndef _DHRYSTONE_H
+#define _DHRYSTONE_H
+
+/****************** "DHRYSTONE" Benchmark Program ***************************/
+#define Version "C, Version 2.2"
+/*  File:       dhry_1.c (part 2 of 3)
+ *  Author:     Reinhold P. Weicker
+ *              Siemens Nixdorf, Paderborn/Germany
+ *              weicker@specbench.org
+ *  Date:       May 25, 1988
+ *  Modified:	Steven Pemberton, CWI, Amsterdam; Steven.Pemberton@cwi.nl
+ *  Date:       October, 1993; March 1995
+ *              Included both files into one source, that gets compiled
+ *              in two passes. Made program auto-compiling, and auto-running,
+ *              and generally made it much easier to use.
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
+ *              are used for execution time measurement. For measurements
+ *              on other systems, these calls have to be changed.
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *              
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 389-8963 (9-17 EST)               
+ *                      Usenet: ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software used.
+ *      Hardware information includes: Machine type, CPU, type and size
+ *      of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states).
+ *      Software information includes: Compiler (and runtime library)
+ *      manufacturer and version, compilation switches, OS version.
+ *      The Operating System version may give an indication about the compiler;
+ *      Dhrystone itself performs no OS calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ ***************************************************************************
+ *
+ * Defines:     The following "Defines" are possible:
+ *      -DREG          (default: Not defined)
+ *              As an approximation to what an average C programmer
+ *              might do, causes the "register" storage class to be applied
+ *              - for local variables, if they are used (dynamically)
+ *                five or more times
+ *              - for parameters if they are used (dynamically)
+ *                six or more times
+ *              Note that an optimal "register" strategy is
+ *              compiler-dependent, and that "register" declarations
+ *              do not necessarily lead to faster execution.
+ *      -DNOSTRUCTASSIGN        (default: Not defined)
+ *              Define if the C compiler does not support
+ *              assignment of structures.
+ *      -DNOENUMS               (default: Not defined)
+ *              Define if the C compiler does not support
+ *              enumeration types.
+ *      -DTIMES                 (default)
+ *      -DTIME
+ *              The "times" function of UNIX (returning process times)
+ *              or the "time" function (returning wallclock time)
+ *              is used for measurement. 
+ *              For single user machines, "time ()" is adequate. For
+ *              multi-user machines where you cannot get single-user
+ *              access, use the "times ()" function. If you have
+ *              neither, use a stopwatch in the dead of night.
+ *              "printf"s are provided marking the points "Start Timer"
+ *              and "Stop Timer". DO NOT use the UNIX "time(1)"
+ *              command, as this will measure the total time to
+ *              run this program, which will (erroneously) include
+ *              the time to allocate storage (malloc) and to perform
+ *              the initialization.
+ *      -DHZ=nnn
+ *              In Berkeley UNIX, the function "times" returns process
+ *              time in 1/HZ seconds, with HZ = 60 for most systems.
+ *              CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
+ *              A VALUE.
+ *
+ ***************************************************************************
+ *
+ *  History:	Version C/2.1 was made for two reasons:
+ *
+ *	1) There was an obvious need for a common C version of
+ *      Dhrystone, since C is at present the most popular system
+ *      programming language for the class of processors
+ *      (microcomputers, minicomputers) where Dhrystone is used most.
+ *      There should be, as far as possible, only one C version of
+ *      Dhrystone such that results can be compared without
+ *      restrictions. In the past, the C versions distributed
+ *      by Rick Richardson (Version 1.1) and by Reinhold Weicker
+ *      had small (though not significant) differences.
+ *
+ *      2) As far as it is possible without changes to the Dhrystone
+ *      statistics, optimizing compilers should be prevented from
+ *      removing significant statements.
+ *
+ *      This C version has been developed in cooperation with
+ *      Rick Richardson (Tinton Falls, NJ), it incorporates many
+ *      ideas from the "Version 1.1" distributed previously by
+ *      him over the UNIX network Usenet.
+ *      I also thank Chaim Benedelac (National Semiconductor),
+ *      David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
+ *      Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
+ *      for their help with comments on earlier versions of the
+ *      benchmark.
+ *
+ *  Changes:    In the initialization part, this version follows mostly
+ *      Rick Richardson's version distributed via Usenet, not the
+ *      version distributed earlier via floppy disk by Reinhold Weicker.
+ *      As a concession to older compilers, names have been made
+ *      unique within the first 8 characters.
+ *      Inside the measurement loop, this version follows the
+ *      version previously distributed by Reinhold Weicker.
+ *
+ *      At several places in the benchmark, code has been added,
+ *      but within the measurement loop only in branches that 
+ *      are not executed. The intention is that optimizing compilers
+ *      should be prevented from moving code out of the measurement
+ *      loop, or from removing code altogether. Since the statements
+ *      that are executed within the measurement loop have NOT been
+ *      changed, the numbers defining the "Dhrystone distribution"
+ *      (distribution of statements, operand types and locality)
+ *      still hold. Except for sophisticated optimizing compilers,
+ *      execution times for this version should be the same as
+ *      for previous versions.
+ *
+ *      Since it has proven difficult to subtract the time for the
+ *      measurement loop overhead in a correct way, the loop check
+ *      has been made a part of the benchmark. This does have
+ *      an impact - though a very minor one - on the distribution
+ *      statistics which have been updated for this version.
+ *
+ *      All changes within the measurement loop are described
+ *      and discussed in the companion paper "Rationale for
+ *      Dhrystone version 2".
+ *
+ *      Because of the self-imposed limitation that the order and
+ *      distribution of the executed statements should not be
+ *      changed, there are still cases where optimizing compilers
+ *      may not generate code for some statements. To a certain
+ *      degree, this is unavoidable for small synthetic benchmarks.
+ *      Users of the benchmark are advised to check code listings
+ *      whether code is generated for all statements of Dhrystone.
+ *
+ *      Version 2.1 is identical to version 2.0 distributed via
+ *      the UNIX network Usenet in March 1988 except that it corrects
+ *      some minor deficiencies that were found by users of version 2.0.
+ *      The only change within the measurement loop is that a
+ *      non-executed "else" part was added to the "if" statement in
+ *      Func_3, and a non-executed "else" part removed from Proc_3.
+ *
+ * Version C/2.2, Steven Pemberton, October 1993
+ *	Functionally, identical to version 2.2; the changes are in
+ *	how you compile and use it:
+ *	- Everything is in one file now, but compiled in 2 passes
+ *	- Compile (and run) by running the file through the shell: 'sh dhry.c"
+ *	- Uses the system definition of HZ if one can be found
+ *	- HZ must be defined, otherwise it won't compile (no defaults here)
+ *	- The (uninteresting) output is printed to stderr (dhry2 > /dev/null)
+ *	- The number of loops is passed as a parameter, rather than read
+ *	  (dhry2 500000)
+ *	- If the number of loops is insufficient to get a good result,
+ *	  it repeats it with loops*10 until it is enough (rather than just
+ *	  stopping)
+ *	- Output says which sort of clock it is using, and the HZ value
+ *	- You can use -DREG instead of the -DREG=register of previous versions
+ *	- Some stylistic cleanups.
+ *		
+ ***************************************************************************
+ *
+ *  Compilation model and measurement (IMPORTANT):
+ *
+ *  The following "ground rules" apply for measurements:
+ *  - Separate compilation
+ *  - No procedure merging
+ *  - Otherwise, compiler optimizations are allowed but should be indicated
+ *  - Default results are those without register declarations
+ *  See the companion paper "Rationale for Dhrystone Version 2" for a more
+ *  detailed discussion of these ground rules.
+ *
+ *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
+ *  models ("small", "medium", "large" etc.) should be given if possible,
+ *  together with a definition of these models for the compiler system used.
+ *
+ **************************************************************************
+ *
+ *  Dhrystone (C version) statistics:
+ *
+ *  [Comment from the first distribution, updated for version 2.
+ *   Note that because of language differences, the numbers are slightly
+ *   different from the Ada version.]
+ *
+ *  The following program contains statements of a high level programming
+ *  language (here: C) in a distribution considered representative:           
+ *
+ *    assignments                  52 (51.0 %)
+ *    control statements           33 (32.4 %)
+ *    procedure, function calls    17 (16.7 %)
+ *
+ *  103 statements are dynamically executed. The program is balanced with
+ *  respect to the three aspects:                                             
+ *
+ *    - statement type
+ *    - operand type
+ *    - operand locality
+ *         operand global, local, parameter, or constant.                     
+ *
+ *  The combination of these three aspects is balanced only approximately.    
+ *
+ *  1. Statement Type:                                                        
+ *  -----------------             number
+ *
+ *     V1 = V2                     9
+ *       (incl. V1 = F(..)
+ *     V = Constant               12
+ *     Assignment,                 7
+ *       with array element
+ *     Assignment,                 6
+ *       with record component
+ *                                --
+ *                                34       34
+ *
+ *     X = Y +|-|"&&"|"|" Z        5
+ *     X = Y +|-|"==" Constant     6
+ *     X = X +|- 1                 3
+ *     X = Y *|/ Z                 2
+ *     X = Expression,             1
+ *           two operators
+ *     X = Expression,             1
+ *           three operators
+ *                                --
+ *                                18       18
+ *
+ *     if ....                    14
+ *       with "else"      7
+ *       without "else"   7
+ *           executed        3
+ *           not executed    4
+ *     for ...                     7  |  counted every time
+ *     while ...                   4  |  the loop condition
+ *     do ... while                1  |  is evaluated
+ *     switch ...                  1
+ *     break                       1
+ *     declaration with            1
+ *       initialization
+ *                                --
+ *                                34       34
+ *
+ *     P (...)  procedure call    11
+ *       user procedure      10
+ *       library procedure    1
+ *     X = F (...)
+ *             function  call      6
+ *       user function        5                                         
+ *       library function     1                                               
+ *                                --                                          
+ *                                17       17
+ *                                        ---
+ *                                        103
+ *
+ *    The average number of parameters in procedure or function calls
+ *    is 1.82 (not counting the function values aX *
+ *
+ *  2. Operators
+ *  ------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *    Arithmetic             32          50.8                                 
+ *
+ *       +                     21          33.3                              
+ *       -                      7          11.1                              
+ *       *                      3           4.8
+ *       / (int div)            1           1.6
+ *
+ *    Comparison             27           42.8
+ *
+ *       ==                     9           14.3
+ *       /=                     4            6.3
+ *       >                      1            1.6
+ *       <                      3            4.8
+ *       >=                     1            1.6
+ *       <=                     9           14.3
+ *
+ *    Logic                   4            6.3
+ *
+ *       && (AND-THEN)          1            1.6
+ *       |  (OR)                1            1.6
+ *       !  (NOT)               2            3.2
+ * 
+ *                           --          -----
+ *                           63          100.1
+ *
+ *
+ *  3. Operand Type (counted once per operand reference):
+ *  ---------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *     Integer               175        72.3 %
+ *     Character              45        18.6 %
+ *     Pointer                12         5.0 %
+ *     String30                6         2.5 %
+ *     Array                   2         0.8 %
+ *     Record                  2         0.8 %
+ *                           ---       -------
+ *                           242       100.0 %
+ *
+ *  When there is an access path leading to the final operand (e.g. a record
+ *  component), only the final data type on the access path is counted.       
+ *
+ *
+ *  4. Operand Locality:                                                      
+ *  -------------------
+ *                                number    approximate
+ *                                          percentage
+ *
+ *     local variable              114        47.1 %
+ *     global variable              22         9.1 %
+ *     parameter                    45        18.6 %
+ *        value                        23         9.5 %
+ *        reference                    22         9.1 %
+ *     function result               6         2.5 %
+ *     constant                     55        22.7 %
+ *                                 ---       -------
+ *                                 242       100.0 %
+ *
+ *  The program does not compute anything meaningful, but it is syntactically
+ *  and semantically correct. All variables have a value assigned to them
+ *  before they are used as a source operand.
+ *
+ *  There has been no explicit effort to account for the effects of a
+ *  cache, or to balance the use of long or short displacements for code or
+ *  data.
+ *
+ ***************************************************************************
+ */
+
+/* Compiler and system dependent definitions: */
+
+/* variables for time measurement: */
+
+#define HZ 1000000
+#define Too_Small_Time 1
+#define CLOCK_TYPE "rdcycle()"
+#define Start_Timer() Begin_Time = read_csr(mcycle)
+#define Stop_Timer() End_Time = read_csr(mcycle)
+
+
+
+#define Mic_secs_Per_Second     1000000
+#define NUMBER_OF_RUNS		500 /* Default number of runs */
+
+#ifdef  NOSTRUCTASSIGN
+#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
+#else
+#define structassign(d, s)      d = s
+#endif
+
+#ifdef  NOENUM
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+  typedef int   Enumeration;
+#else
+  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+#endif
+        /* for boolean and enumeration types in Ada, Pascal */
+
+/* General definitions: */
+
+#include <stdio.h>
+#include <string.h>
+                /* for strcpy, strcmp */
+
+#define Null 0 
+                /* Value of a Null pointer */
+#ifndef true
+#define true  1
+#endif
+#ifndef false
+#define false 0
+#endif
+
+typedef int     One_Thirty;
+typedef int     One_Fifty;
+typedef char    Capital_Letter;
+typedef int     Boolean;
+typedef char    Str_30 [31];
+typedef int     Arr_1_Dim [50];
+typedef int     Arr_2_Dim [50] [50];
+
+typedef struct record 
+    {
+    struct record *Ptr_Comp;
+    Enumeration    Discr;
+    union {
+          struct {
+                  Enumeration Enum_Comp;
+                  int         Int_Comp;
+                  char        Str_Comp [31];
+                  } var_1;
+          struct {
+                  Enumeration E_Comp_2;
+                  char        Str_2_Comp [31];
+                  } var_2;
+          struct {
+                  char        Ch_1_Comp;
+                  char        Ch_2_Comp;
+                  } var_3;
+          } variant;
+      } Rec_Type, *Rec_Pointer;
+
+#endif
diff -Naur apps-12.11/testing/ostest/ostest_main.c apps/testing/ostest/ostest_main.c
--- apps-12.11/testing/ostest/ostest_main.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/ostest_main.c	2025-12-06 13:12:44.781453940 +0200
@@ -52,7 +52,7 @@
 
 #define PRIORITY         100
 #define NARGS              4
-#define HALF_SECOND_USEC 500000L
+#define HALF_SECOND_USEC 10 //500000L
 
 /****************************************************************************
  * Private Data
diff -Naur apps-12.11/testing/ostest/prioinherit.c apps/testing/ostest/prioinherit.c
--- apps-12.11/testing/ostest/prioinherit.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/prioinherit.c	2025-12-06 13:14:30.602423045 +0200
@@ -215,7 +215,8 @@
 
   printf("highpri_thread-%d: Started\n", threadno);
   FFLUSH();
-  sleep(1);
+  //sleep(1);
+  usleep(1);
 
   printf("highpri_thread-%d: Calling sem_wait()\n", threadno);
   g_highstate[threadno - 1] = WAITING;
@@ -363,7 +364,8 @@
           printf("    I still have a count on the semaphore\n");
           sem_enumholders(&g_sem);
           FFLUSH();
-          sleep(1);
+          //sleep(1);
+	  usleep(1);
         }
 
       /* Account for all of the semaphore counts.  At any given time if there
@@ -574,7 +576,8 @@
     }
 
   printf("priority_inheritance: Waiting...\n");
-  sleep(2);
+  //sleep(2);
+  usleep(1);
   dump_nfreeholders("priority_inheritance:");
 
   /* Start the medium priority thread */
diff -Naur apps-12.11/testing/ostest/pthread_exit.c apps/testing/ostest/pthread_exit.c
--- apps-12.11/testing/ostest/pthread_exit.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/pthread_exit.c	2025-12-06 13:16:05.667956514 +0200
@@ -52,9 +52,11 @@
   unsigned me = (unsigned)pthread_self();
 
   printf("pthread_exit_thread %u: Sleeping for 10 second\n", me);
-  sleep(5);
+  //sleep(5);
+  usleep(5);
   printf("pthread_exit_thread %u: Still running...\n", me);
-  sleep(5);
+  //sleep(5);
+  usleep(5);
   printf("pthread_exit_thread %u: Exiting\n", me);
   return NULL;
 }
@@ -82,7 +84,8 @@
 
   printf("pthread_exit_main %u: Sleeping for 5 seconds\n", me);
   fflush(stdout);
-  sleep(5);
+  //sleep(5);
+  usleep(5);
 
   printf("pthread_exit_main %u: Calling pthread_exit()\n", me);
   pthread_exit(NULL);
diff -Naur apps-12.11/testing/ostest/pthread_rwlock.c apps/testing/ostest/pthread_rwlock.c
--- apps-12.11/testing/ostest/pthread_rwlock.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/pthread_rwlock.c	2025-12-06 13:17:32.604693046 +0200
@@ -336,7 +336,7 @@
   pthread_yield();
 
   status = clock_gettime(CLOCK_REALTIME, &time);
-  time.tv_sec += 2;
+  time.tv_nsec += 2;
 
   status = pthread_rwlock_timedwrlock(rc->rw_lock, &time);
   if (status != ETIMEDOUT)
@@ -347,7 +347,7 @@
     }
 
   status = clock_gettime(CLOCK_REALTIME, &time);
-  time.tv_sec += 2;
+  time.tv_nsec += 2;
 
   status = pthread_rwlock_timedrdlock(rc->rw_lock, &time);
   if (status != ETIMEDOUT)
@@ -357,7 +357,7 @@
     }
 
   status = clock_gettime(CLOCK_REALTIME, &time);
-  time.tv_sec += 2;
+  time.tv_nsec += 2;
 
   sem_post(rc->sem1);
   status = pthread_rwlock_timedrdlock(rc->rw_lock, &time);
diff -Naur apps-12.11/testing/ostest/pthread_rwlock_cancel.c apps/testing/ostest/pthread_rwlock_cancel.c
--- apps-12.11/testing/ostest/pthread_rwlock_cancel.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/pthread_rwlock_cancel.c	2025-12-06 13:18:12.345170010 +0200
@@ -54,7 +54,7 @@
   while (1)
     {
       clock_gettime(CLOCK_REALTIME, &time);
-      time.tv_sec += 1;
+      time.tv_nsec += 1;
 
       status = pthread_rwlock_timedrdlock(sync->write_lock, &time);
       if (status != ETIMEDOUT)
@@ -77,7 +77,7 @@
   while (1)
     {
       clock_gettime(CLOCK_REALTIME, &time);
-      time.tv_sec += 1;
+      time.tv_nsec += 1;
 
       status = pthread_rwlock_timedrdlock(sync->read_lock, &time);
       if (status != 0)
@@ -102,7 +102,7 @@
         }
 
       clock_gettime(CLOCK_REALTIME, &time);
-      time.tv_sec += 1;
+      time.tv_nsec += 1;
 
       status = pthread_rwlock_timedwrlock(sync->read_lock, &time);
       if (status != ETIMEDOUT)
diff -Naur apps-12.11/testing/ostest/restart.c apps/testing/ostest/restart.c
--- apps-12.11/testing/ostest/restart.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/restart.c	2025-12-06 13:18:57.106724091 +0200
@@ -134,7 +134,7 @@
       case 0:
         for (; ; )
           {
-            sleep(2);
+            usleep(2);
             printf("restart_main: I am still here\n");
           }
         break;
@@ -194,7 +194,7 @@
 
       /* Wait a bit and restart the task */
 
-      sleep(5);
+      usleep(5);
 
       g_restartstep = 1;
 
@@ -211,7 +211,7 @@
 
       /* Wait a bit and restart the task */
 
-      sleep(5);
+      usleep(5);
 
       g_restartstep = 2;
 
@@ -222,7 +222,7 @@
           ASSERT(false);
         }
 
-      sleep(1);
+      usleep(1);
     }
 
   sem_destroy(&g_sem);
diff -Naur apps-12.11/testing/ostest/robust.c apps/testing/ostest/robust.c
--- apps-12.11/testing/ostest/robust.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/robust.c	2025-12-06 13:21:28.424494072 +0200
@@ -71,7 +71,7 @@
       printf("robust_waiter: Exiting with mutex\n");
     }
 
-  sleep(2);
+  usleep(2);
   return NULL;
 }
 
@@ -161,7 +161,7 @@
 
   /* Wait one second.. the robust waiter should still be waiting */
 
-  sleep(1);
+  usleep(1);
 
   /* Now try to take the mutex held by the robust waiter.  This should wait
    * one second there fail with EOWNERDEAD.
@@ -208,7 +208,7 @@
 
   do
     {
-      sleep(1);
+      usleep(1);
     }
   while (kill(waiter, 0) == 0 || errno != ESRCH);
 
diff -Naur apps-12.11/testing/ostest/schedlock.c apps/testing/ostest/schedlock.c
--- apps-12.11/testing/ostest/schedlock.c	2025-03-03 14:57:07.000000000 +0200
+++ apps/testing/ostest/schedlock.c	2025-12-06 13:22:33.434425896 +0200
@@ -252,7 +252,7 @@
         }
 
       printf("sched_lock: Waiting...\n");
-      sleep(1);
+      usleep(1);
 
       pthread_join(g_highpri, NULL);
       pthread_join(g_lowpri, NULL);
diff -Naur apps-12.11/testing/ostest/semtimed.c apps/testing/ostest/semtimed.c
--- apps-12.11/testing/ostest/semtimed.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/semtimed.c	2025-12-06 13:25:27.647476312 +0200
@@ -126,8 +126,8 @@
 
   ostest_gettime(&before);
 
-  abstime.tv_sec  = before.tv_sec + 2;
-  abstime.tv_nsec = before.tv_nsec;
+  abstime.tv_sec  = before.tv_sec;
+  abstime.tv_nsec = before.tv_nsec + 1000000;
 
   printf("semtimed_test: Waiting for two second timeout\n");
   status  = sem_timedwait(&sem, &abstime);
@@ -230,8 +230,8 @@
 
   ostest_gettime(&before);
 
-  abstime.tv_sec  = before.tv_sec + 2;
-  abstime.tv_nsec = before.tv_nsec;
+  abstime.tv_sec  = before.tv_sec;
+  abstime.tv_nsec = before.tv_nsec + 100000;
 
   printf("semtimed_test: Waiting for two second timeout\n");
   status  = sem_timedwait(&sem, &abstime);
diff -Naur apps-12.11/testing/ostest/sigev_thread.c apps/testing/ostest/sigev_thread.c
--- apps-12.11/testing/ostest/sigev_thread.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/sigev_thread.c	2025-12-06 13:25:46.134006792 +0200
@@ -100,10 +100,10 @@
 
   printf("sigev_thread_test: Starting timer\n");
 
-  timer.it_value.tv_sec     = 2;
-  timer.it_value.tv_nsec    = 0;
-  timer.it_interval.tv_sec  = 2;
-  timer.it_interval.tv_nsec = 0;
+  timer.it_value.tv_sec     = 0;
+  timer.it_value.tv_nsec    = 1000;
+  timer.it_interval.tv_sec  = 0;
+  timer.it_interval.tv_nsec = 1000;
 
   status = timer_settime(timerid, 0, &timer, NULL);
   if (status != OK)
diff -Naur apps-12.11/testing/ostest/sighand.c apps/testing/ostest/sighand.c
--- apps-12.11/testing/ostest/sighand.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/sighand.c	2025-12-06 13:26:58.906090195 +0200
@@ -285,7 +285,7 @@
   /* Wait a bit */
 
   FFLUSH();
-  sleep(2);
+  usleep(2);
 
   /* Then signal the waiter thread. */
 
@@ -304,10 +304,10 @@
   /* Wait a bit */
 
   FFLUSH();
-  status = sleep(2);
+  status = usleep(2);
   while (status)
     {
-      status = sleep(status);
+      status = usleep(status);
     }
 
   /* Then check the result */
diff -Naur apps-12.11/testing/ostest/signest.c apps/testing/ostest/signest.c
--- apps-12.11/testing/ostest/signest.c	2025-06-02 09:57:52.000000000 +0300
+++ apps/testing/ostest/signest.c	2025-12-06 13:28:29.972206196 +0200
@@ -249,7 +249,7 @@
   while (wait_times > 0)
     {
       clock_gettime(CLOCK_REALTIME, &ts);
-      ts.tv_sec += 2;
+      ts.tv_nsec += 100000;
       if (sem_timedwait(&g_sem_signal_finish, &ts) != OK)
         {
           sinfo("signest_test wait too long");
@@ -522,7 +522,7 @@
   sem_post(&g_interferer_sem);
   do
     {
-      usleep(500 * 1000L);
+      usleep(5 * 100L);
     }
   while (g_waiter_running || g_interferer_running);
 
diff -Naur apps-12.11/testing/ostest/sporadic2.c apps/testing/ostest/sporadic2.c
--- apps-12.11/testing/ostest/sporadic2.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/sporadic2.c	2025-12-06 13:47:20.190708350 +0200
@@ -222,7 +222,7 @@
   sparam.sched_priority               = PRIO_HIGH1;
   sparam.sched_ss_low_priority        = PRIO_LOW1;
   sparam.sched_ss_repl_period.tv_sec  = 0;
-  sparam.sched_ss_repl_period.tv_nsec = REPL_INTERVAL;
+  sparam.sched_ss_repl_period.tv_nsec = 0; //REPL_INTERVAL;
   sparam.sched_ss_init_budget.tv_sec  = 0;
   sparam.sched_ss_init_budget.tv_nsec = budget_1_ns;
   sparam.sched_ss_max_repl            = CONFIG_SCHED_SPORADIC_MAXREPL;
@@ -290,7 +290,7 @@
   sem_post(&g_sporadic_sem);
   sem_post(&g_sporadic_sem);
 
-  sleep(100);
+  usleep(100);
 
   ret = pthread_cancel(sporadic_thread1);
   pthread_join(sporadic_thread1, &result);
diff -Naur apps-12.11/testing/ostest/sporadic.c apps/testing/ostest/sporadic.c
--- apps-12.11/testing/ostest/sporadic.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/sporadic.c	2025-12-06 13:48:41.383388191 +0200
@@ -88,7 +88,7 @@
     {
       /* Sleep gracefully for awhile */
 
-      usleep(500 * 1000);
+      usleep(5 * 1000);
 
       /* Then hog some CPU time */
 
@@ -312,10 +312,10 @@
 
   sparam.sched_priority               = prio_high;
   sparam.sched_ss_low_priority        = prio_low;
-  sparam.sched_ss_repl_period.tv_sec  = 5;
-  sparam.sched_ss_repl_period.tv_nsec = 0;
-  sparam.sched_ss_init_budget.tv_sec  = 2;
-  sparam.sched_ss_init_budget.tv_nsec = 0;
+  sparam.sched_ss_repl_period.tv_sec  = 0;
+  sparam.sched_ss_repl_period.tv_nsec = 10000;
+  sparam.sched_ss_init_budget.tv_sec  = 0;
+  sparam.sched_ss_init_budget.tv_nsec = 10000;
   sparam.sched_ss_max_repl            = CONFIG_SCHED_SPORADIC_MAXREPL;
 
   ret = pthread_attr_setschedparam(&attr, &sparam);
@@ -344,19 +344,19 @@
 
   /* Wait a while then kill the FIFO thread */
 
-  sleep(15);
+  usleep(15);
   ret = pthread_cancel(fifo_thread);
   pthread_join(fifo_thread, &result);
 
   /* Wait a bit longer then kill the nuisance thread */
 
-  sleep(10);
+  usleep(10);
   ret = pthread_cancel(nuisance_thread);
   pthread_join(nuisance_thread, &result);
 
   /* Wait a bit longer then kill the sporadic thread */
 
-  sleep(10);
+  usleep(10);
   ret = pthread_cancel(sporadic_thread);
   pthread_join(sporadic_thread, &result);
   sched_unlock();
diff -Naur apps-12.11/testing/ostest/suspend.c apps/testing/ostest/suspend.c
--- apps-12.11/testing/ostest/suspend.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/suspend.c	2025-12-06 13:49:34.819695956 +0200
@@ -55,7 +55,7 @@
 
   for (; ; )
     {
-      sleep(3);
+      usleep(3);
       printf("victim_main: Wasting time\n");
       FFLUSH();
     }
@@ -96,7 +96,7 @@
 
   printf("suspend_test:  Is the victim saying anything?\n");
   FFLUSH();
-  sleep(10);
+  usleep(10);
 
   /* Then signal the victim thread. */
 
@@ -110,7 +110,7 @@
 
   printf("suspend_test:  Is the victim still jabbering?\n");
   FFLUSH();
-  sleep(10);
+  usleep(10);
 
   printf("suspend_test: Signaling pid=%d with SIGCONT\n", victim);
   ret = kill(victim, SIGCONT);
@@ -122,7 +122,7 @@
 
   printf("suspend_test:  The victim should continue the rant.\n");
   FFLUSH();
-  sleep(10);
+  usleep(10);
 
   printf("suspend_test: Signaling pid=%d with SIGKILL\n", victim);
   ret = kill(victim, SIGKILL);
@@ -133,7 +133,7 @@
     }
 
   FFLUSH();
-  sleep(1);
+  usleep(1);
   ret = kill(victim, 0);
   if (ret >= 0)
     {
diff -Naur apps-12.11/testing/ostest/timedmqueue.c apps/testing/ostest/timedmqueue.c
--- apps-12.11/testing/ostest/timedmqueue.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/timedmqueue.c	2025-12-06 13:50:43.340619799 +0200
@@ -135,7 +135,7 @@
           ASSERT(false);
         }
 
-      ts.tv_sec += 5;
+      ts.tv_nsec += 5;
 
       /* The first TEST_SEND_NMSGS-1 send should succeed.  The last
        * one should fail with errno == ETIMEDOUT
@@ -236,7 +236,7 @@
           ASSERT(false);
         }
 
-      ts.tv_sec += 5;
+      ts.tv_nsec += 5;
 
       /* The first TEST_SEND_NMSGS-1 send should succeed.  The last
        * one should fail with errno == ETIMEDOUT
diff -Naur apps-12.11/testing/ostest/timedmutex.c apps/testing/ostest/timedmutex.c
--- apps-12.11/testing/ostest/timedmutex.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/timedmutex.c	2025-12-06 13:51:28.138926012 +0200
@@ -79,7 +79,7 @@
        * blocked for two seconds here!)
        */
 
-      ts.tv_sec += 2;
+      ts.tv_nsec += 2;
 
       /* Now wait until either we get the lock or until the timeout occurs */
 
@@ -188,7 +188,7 @@
    * time, the pthread should no longer be running.
    */
 
-  sleep(4);
+  usleep(4);
 
   /* The pthread should no longer be running and it should have terminated
    * because of EAGAIN.
diff -Naur apps-12.11/testing/ostest/timedwait.c apps/testing/ostest/timedwait.c
--- apps-12.11/testing/ostest/timedwait.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/timedwait.c	2025-12-06 13:52:11.708849066 +0200
@@ -74,7 +74,7 @@
       ASSERT(false);
     }
 
-  ts.tv_sec += 5;
+  ts.tv_nsec += 5;
 
   /* The wait -- no-one is ever going to awaken us */
 
diff -Naur apps-12.11/testing/ostest/vfork.c apps/testing/ostest/vfork.c
--- apps-12.11/testing/ostest/vfork.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/vfork.c	2025-12-06 13:52:44.769431912 +0200
@@ -70,7 +70,7 @@
     }
   else
     {
-      sleep(1);
+      usleep(1);
       if (g_vforkchild)
         {
           printf("vfork_test: Child %d ran successfully\n", pid);
diff -Naur apps-12.11/testing/ostest/waitpid.c apps/testing/ostest/waitpid.c
--- apps-12.11/testing/ostest/waitpid.c	2024-12-31 07:17:30.000000000 +0200
+++ apps/testing/ostest/waitpid.c	2025-12-06 13:53:11.921130010 +0200
@@ -66,7 +66,7 @@
   pid_t me = getpid();
 
   printf("waitpid_main: PID %d Started\n", me);
-  sleep(3);
+  usleep(3);
   printf("waitpid_main: PID %d exitting with result=%d\n",
           me, RETURN_STATUS);
   return RETURN_STATUS;
@@ -237,7 +237,7 @@
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 
 #ifdef CONFIG_SCHED_HAVE_PARENT
   /* Start the children and wait for first one to complete */
@@ -294,7 +294,7 @@
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 
   /* Start the children and wait for any one to complete */
 
@@ -343,7 +343,7 @@
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 
   /* Start the children and wait for first one to complete */
 
@@ -392,7 +392,7 @@
   /* Wait a bit to make sure that the other threads complete */
 
   waitpid_last();
-  sleep(1);
+  usleep(1);
 #endif
 
   return 0;
diff -Naur apps-12.11/testing/sched/smp/dhrystone.h apps/testing/sched/smp/dhrystone.h
--- apps-12.11/testing/sched/smp/dhrystone.h	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/sched/smp/dhrystone.h	2025-12-06 13:55:29.865066443 +0200
@@ -0,0 +1,432 @@
+// See LICENSE for license details.
+
+#ifndef _DHRYSTONE_H
+#define _DHRYSTONE_H
+
+/****************** "DHRYSTONE" Benchmark Program ***************************/
+#define Version "C, Version 2.2"
+/*  File:       dhry_1.c (part 2 of 3)
+ *  Author:     Reinhold P. Weicker
+ *              Siemens Nixdorf, Paderborn/Germany
+ *              weicker@specbench.org
+ *  Date:       May 25, 1988
+ *  Modified:	Steven Pemberton, CWI, Amsterdam; Steven.Pemberton@cwi.nl
+ *  Date:       October, 1993; March 1995
+ *              Included both files into one source, that gets compiled
+ *              in two passes. Made program auto-compiling, and auto-running,
+ *              and generally made it much easier to use.
+ *
+ *              Original Version (in Ada) published in
+ *              "Communications of the ACM" vol. 27., no. 10 (Oct. 1984),
+ *              pp. 1013 - 1030, together with the statistics
+ *              on which the distribution of statements etc. is based.
+ *
+ *              In this C version, the following C library functions are used:
+ *              - strcpy, strcmp (inside the measurement loop)
+ *              - printf, scanf (outside the measurement loop)
+ *              In addition, Berkeley UNIX system calls "times ()" or "time ()"
+ *              are used for execution time measurement. For measurements
+ *              on other systems, these calls have to be changed.
+ *
+ *  Collection of Results:
+ *              Reinhold Weicker (address see above) and
+ *              
+ *              Rick Richardson
+ *              PC Research. Inc.
+ *              94 Apple Orchard Drive
+ *              Tinton Falls, NJ 07724
+ *                      Phone:  (201) 389-8963 (9-17 EST)               
+ *                      Usenet: ...!uunet!pcrat!rick
+ *
+ *      Please send results to Rick Richardson and/or Reinhold Weicker.
+ *      Complete information should be given on hardware and software used.
+ *      Hardware information includes: Machine type, CPU, type and size
+ *      of caches; for microprocessors: clock frequency, memory speed
+ *      (number of wait states).
+ *      Software information includes: Compiler (and runtime library)
+ *      manufacturer and version, compilation switches, OS version.
+ *      The Operating System version may give an indication about the compiler;
+ *      Dhrystone itself performs no OS calls in the measurement loop.
+ *
+ *      The complete output generated by the program should be mailed
+ *      such that at least some checks for correctness can be made.
+ *
+ ***************************************************************************
+ *
+ * Defines:     The following "Defines" are possible:
+ *      -DREG          (default: Not defined)
+ *              As an approximation to what an average C programmer
+ *              might do, causes the "register" storage class to be applied
+ *              - for local variables, if they are used (dynamically)
+ *                five or more times
+ *              - for parameters if they are used (dynamically)
+ *                six or more times
+ *              Note that an optimal "register" strategy is
+ *              compiler-dependent, and that "register" declarations
+ *              do not necessarily lead to faster execution.
+ *      -DNOSTRUCTASSIGN        (default: Not defined)
+ *              Define if the C compiler does not support
+ *              assignment of structures.
+ *      -DNOENUMS               (default: Not defined)
+ *              Define if the C compiler does not support
+ *              enumeration types.
+ *      -DTIMES                 (default)
+ *      -DTIME
+ *              The "times" function of UNIX (returning process times)
+ *              or the "time" function (returning wallclock time)
+ *              is used for measurement. 
+ *              For single user machines, "time ()" is adequate. For
+ *              multi-user machines where you cannot get single-user
+ *              access, use the "times ()" function. If you have
+ *              neither, use a stopwatch in the dead of night.
+ *              "printf"s are provided marking the points "Start Timer"
+ *              and "Stop Timer". DO NOT use the UNIX "time(1)"
+ *              command, as this will measure the total time to
+ *              run this program, which will (erroneously) include
+ *              the time to allocate storage (malloc) and to perform
+ *              the initialization.
+ *      -DHZ=nnn
+ *              In Berkeley UNIX, the function "times" returns process
+ *              time in 1/HZ seconds, with HZ = 60 for most systems.
+ *              CHECK YOUR SYSTEM DESCRIPTION BEFORE YOU JUST APPLY
+ *              A VALUE.
+ *
+ ***************************************************************************
+ *
+ *  History:	Version C/2.1 was made for two reasons:
+ *
+ *	1) There was an obvious need for a common C version of
+ *      Dhrystone, since C is at present the most popular system
+ *      programming language for the class of processors
+ *      (microcomputers, minicomputers) where Dhrystone is used most.
+ *      There should be, as far as possible, only one C version of
+ *      Dhrystone such that results can be compared without
+ *      restrictions. In the past, the C versions distributed
+ *      by Rick Richardson (Version 1.1) and by Reinhold Weicker
+ *      had small (though not significant) differences.
+ *
+ *      2) As far as it is possible without changes to the Dhrystone
+ *      statistics, optimizing compilers should be prevented from
+ *      removing significant statements.
+ *
+ *      This C version has been developed in cooperation with
+ *      Rick Richardson (Tinton Falls, NJ), it incorporates many
+ *      ideas from the "Version 1.1" distributed previously by
+ *      him over the UNIX network Usenet.
+ *      I also thank Chaim Benedelac (National Semiconductor),
+ *      David Ditzel (SUN), Earl Killian and John Mashey (MIPS),
+ *      Alan Smith and Rafael Saavedra-Barrera (UC at Berkeley)
+ *      for their help with comments on earlier versions of the
+ *      benchmark.
+ *
+ *  Changes:    In the initialization part, this version follows mostly
+ *      Rick Richardson's version distributed via Usenet, not the
+ *      version distributed earlier via floppy disk by Reinhold Weicker.
+ *      As a concession to older compilers, names have been made
+ *      unique within the first 8 characters.
+ *      Inside the measurement loop, this version follows the
+ *      version previously distributed by Reinhold Weicker.
+ *
+ *      At several places in the benchmark, code has been added,
+ *      but within the measurement loop only in branches that 
+ *      are not executed. The intention is that optimizing compilers
+ *      should be prevented from moving code out of the measurement
+ *      loop, or from removing code altogether. Since the statements
+ *      that are executed within the measurement loop have NOT been
+ *      changed, the numbers defining the "Dhrystone distribution"
+ *      (distribution of statements, operand types and locality)
+ *      still hold. Except for sophisticated optimizing compilers,
+ *      execution times for this version should be the same as
+ *      for previous versions.
+ *
+ *      Since it has proven difficult to subtract the time for the
+ *      measurement loop overhead in a correct way, the loop check
+ *      has been made a part of the benchmark. This does have
+ *      an impact - though a very minor one - on the distribution
+ *      statistics which have been updated for this version.
+ *
+ *      All changes within the measurement loop are described
+ *      and discussed in the companion paper "Rationale for
+ *      Dhrystone version 2".
+ *
+ *      Because of the self-imposed limitation that the order and
+ *      distribution of the executed statements should not be
+ *      changed, there are still cases where optimizing compilers
+ *      may not generate code for some statements. To a certain
+ *      degree, this is unavoidable for small synthetic benchmarks.
+ *      Users of the benchmark are advised to check code listings
+ *      whether code is generated for all statements of Dhrystone.
+ *
+ *      Version 2.1 is identical to version 2.0 distributed via
+ *      the UNIX network Usenet in March 1988 except that it corrects
+ *      some minor deficiencies that were found by users of version 2.0.
+ *      The only change within the measurement loop is that a
+ *      non-executed "else" part was added to the "if" statement in
+ *      Func_3, and a non-executed "else" part removed from Proc_3.
+ *
+ * Version C/2.2, Steven Pemberton, October 1993
+ *	Functionally, identical to version 2.2; the changes are in
+ *	how you compile and use it:
+ *	- Everything is in one file now, but compiled in 2 passes
+ *	- Compile (and run) by running the file through the shell: 'sh dhry.c"
+ *	- Uses the system definition of HZ if one can be found
+ *	- HZ must be defined, otherwise it won't compile (no defaults here)
+ *	- The (uninteresting) output is printed to stderr (dhry2 > /dev/null)
+ *	- The number of loops is passed as a parameter, rather than read
+ *	  (dhry2 500000)
+ *	- If the number of loops is insufficient to get a good result,
+ *	  it repeats it with loops*10 until it is enough (rather than just
+ *	  stopping)
+ *	- Output says which sort of clock it is using, and the HZ value
+ *	- You can use -DREG instead of the -DREG=register of previous versions
+ *	- Some stylistic cleanups.
+ *		
+ ***************************************************************************
+ *
+ *  Compilation model and measurement (IMPORTANT):
+ *
+ *  The following "ground rules" apply for measurements:
+ *  - Separate compilation
+ *  - No procedure merging
+ *  - Otherwise, compiler optimizations are allowed but should be indicated
+ *  - Default results are those without register declarations
+ *  See the companion paper "Rationale for Dhrystone Version 2" for a more
+ *  detailed discussion of these ground rules.
+ *
+ *  For 16-Bit processors (e.g. 80186, 80286), times for all compilation
+ *  models ("small", "medium", "large" etc.) should be given if possible,
+ *  together with a definition of these models for the compiler system used.
+ *
+ **************************************************************************
+ *
+ *  Dhrystone (C version) statistics:
+ *
+ *  [Comment from the first distribution, updated for version 2.
+ *   Note that because of language differences, the numbers are slightly
+ *   different from the Ada version.]
+ *
+ *  The following program contains statements of a high level programming
+ *  language (here: C) in a distribution considered representative:           
+ *
+ *    assignments                  52 (51.0 %)
+ *    control statements           33 (32.4 %)
+ *    procedure, function calls    17 (16.7 %)
+ *
+ *  103 statements are dynamically executed. The program is balanced with
+ *  respect to the three aspects:                                             
+ *
+ *    - statement type
+ *    - operand type
+ *    - operand locality
+ *         operand global, local, parameter, or constant.                     
+ *
+ *  The combination of these three aspects is balanced only approximately.    
+ *
+ *  1. Statement Type:                                                        
+ *  -----------------             number
+ *
+ *     V1 = V2                     9
+ *       (incl. V1 = F(..)
+ *     V = Constant               12
+ *     Assignment,                 7
+ *       with array element
+ *     Assignment,                 6
+ *       with record component
+ *                                --
+ *                                34       34
+ *
+ *     X = Y +|-|"&&"|"|" Z        5
+ *     X = Y +|-|"==" Constant     6
+ *     X = X +|- 1                 3
+ *     X = Y *|/ Z                 2
+ *     X = Expression,             1
+ *           two operators
+ *     X = Expression,             1
+ *           three operators
+ *                                --
+ *                                18       18
+ *
+ *     if ....                    14
+ *       with "else"      7
+ *       without "else"   7
+ *           executed        3
+ *           not executed    4
+ *     for ...                     7  |  counted every time
+ *     while ...                   4  |  the loop condition
+ *     do ... while                1  |  is evaluated
+ *     switch ...                  1
+ *     break                       1
+ *     declaration with            1
+ *       initialization
+ *                                --
+ *                                34       34
+ *
+ *     P (...)  procedure call    11
+ *       user procedure      10
+ *       library procedure    1
+ *     X = F (...)
+ *             function  call      6
+ *       user function        5                                         
+ *       library function     1                                               
+ *                                --                                          
+ *                                17       17
+ *                                        ---
+ *                                        103
+ *
+ *    The average number of parameters in procedure or function calls
+ *    is 1.82 (not counting the function values aX *
+ *
+ *  2. Operators
+ *  ------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *    Arithmetic             32          50.8                                 
+ *
+ *       +                     21          33.3                              
+ *       -                      7          11.1                              
+ *       *                      3           4.8
+ *       / (int div)            1           1.6
+ *
+ *    Comparison             27           42.8
+ *
+ *       ==                     9           14.3
+ *       /=                     4            6.3
+ *       >                      1            1.6
+ *       <                      3            4.8
+ *       >=                     1            1.6
+ *       <=                     9           14.3
+ *
+ *    Logic                   4            6.3
+ *
+ *       && (AND-THEN)          1            1.6
+ *       |  (OR)                1            1.6
+ *       !  (NOT)               2            3.2
+ * 
+ *                           --          -----
+ *                           63          100.1
+ *
+ *
+ *  3. Operand Type (counted once per operand reference):
+ *  ---------------
+ *                          number    approximate
+ *                                    percentage
+ *
+ *     Integer               175        72.3 %
+ *     Character              45        18.6 %
+ *     Pointer                12         5.0 %
+ *     String30                6         2.5 %
+ *     Array                   2         0.8 %
+ *     Record                  2         0.8 %
+ *                           ---       -------
+ *                           242       100.0 %
+ *
+ *  When there is an access path leading to the final operand (e.g. a record
+ *  component), only the final data type on the access path is counted.       
+ *
+ *
+ *  4. Operand Locality:                                                      
+ *  -------------------
+ *                                number    approximate
+ *                                          percentage
+ *
+ *     local variable              114        47.1 %
+ *     global variable              22         9.1 %
+ *     parameter                    45        18.6 %
+ *        value                        23         9.5 %
+ *        reference                    22         9.1 %
+ *     function result               6         2.5 %
+ *     constant                     55        22.7 %
+ *                                 ---       -------
+ *                                 242       100.0 %
+ *
+ *  The program does not compute anything meaningful, but it is syntactically
+ *  and semantically correct. All variables have a value assigned to them
+ *  before they are used as a source operand.
+ *
+ *  There has been no explicit effort to account for the effects of a
+ *  cache, or to balance the use of long or short displacements for code or
+ *  data.
+ *
+ ***************************************************************************
+ */
+
+/* Compiler and system dependent definitions: */
+
+/* variables for time measurement: */
+
+#define HZ 1000000
+#define Too_Small_Time 1
+#define CLOCK_TYPE "rdcycle()"
+#define Start_Timer() Begin_Time = read_csr(mcycle)
+#define Stop_Timer() End_Time = read_csr(mcycle)
+
+
+
+#define Mic_secs_Per_Second     1000000
+#define NUMBER_OF_RUNS		500 /* Default number of runs */
+
+#ifdef  NOSTRUCTASSIGN
+#define structassign(d, s)      memcpy(&(d), &(s), sizeof(d))
+#else
+#define structassign(d, s)      d = s
+#endif
+
+#ifdef  NOENUM
+#define Ident_1 0
+#define Ident_2 1
+#define Ident_3 2
+#define Ident_4 3
+#define Ident_5 4
+  typedef int   Enumeration;
+#else
+  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}
+                Enumeration;
+#endif
+        /* for boolean and enumeration types in Ada, Pascal */
+
+/* General definitions: */
+
+#include <stdio.h>
+#include <string.h>
+                /* for strcpy, strcmp */
+
+#define Null 0 
+                /* Value of a Null pointer */
+#ifndef true
+#define true  1
+#endif
+#ifndef false
+#define false 0
+#endif
+
+typedef int     One_Thirty;
+typedef int     One_Fifty;
+typedef char    Capital_Letter;
+typedef int     Boolean;
+typedef char    Str_30 [31];
+typedef int     Arr_1_Dim [50];
+typedef int     Arr_2_Dim [50] [50];
+
+typedef struct record 
+    {
+    struct record *Ptr_Comp;
+    Enumeration    Discr;
+    union {
+          struct {
+                  Enumeration Enum_Comp;
+                  int         Int_Comp;
+                  char        Str_Comp [31];
+                  } var_1;
+          struct {
+                  Enumeration E_Comp_2;
+                  char        Str_2_Comp [31];
+                  } var_2;
+          struct {
+                  char        Ch_1_Comp;
+                  char        Ch_2_Comp;
+                  } var_3;
+          } variant;
+      } Rec_Type, *Rec_Pointer;
+
+#endif
diff -Naur apps-12.11/testing/sched/smp/dhrystone_main.c apps/testing/sched/smp/dhrystone_main.c
--- apps-12.11/testing/sched/smp/dhrystone_main.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/sched/smp/dhrystone_main.c	2025-12-06 13:55:56.496957044 +0200
@@ -0,0 +1,525 @@
+// See LICENSE for license details.
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <debug.h>
+
+//**************************************************************************
+// Dhrystone bencmark
+//--------------------------------------------------------------------------
+//
+// This is the classic Dhrystone synthetic integer benchmark.
+//
+
+#pragma GCC optimize ("no-inline")
+
+#include "dhrystone.h"
+
+#include <alloca.h>
+
+#define setStats(x)
+
+#define read_csr(csrname) ({ \
+        uint32_t __csr_tmp_u32; \
+        __asm__ volatile ("csrr %0, " #csrname : "=r" (__csr_tmp_u32)); \
+        __csr_tmp_u32; \
+})
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+// dhrystone.c
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+#undef REG
+#define REG register
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1: 
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2: 
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5: 
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+// end of dhrystone.c
+
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#undef REG
+#define REG register
+#endif
+
+Boolean		Done;
+
+long            Begin_Time,
+                End_Time,
+                User_Time;
+long            Microseconds,
+                Dhrystones_Per_Second;
+
+/* end of variables for time measurement */
+
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+  
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp 
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;  
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+//int main (int argc, char** argv)
+int main(int argc, FAR char *argv[])
+/*****/
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Arguments */
+  Number_Of_Runs = NUMBER_OF_RUNS;
+
+  /* Initializations */
+
+  Next_Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+  _info("\n");
+  _info("Dhrystone Benchmark, Version %s\n", Version);
+  if (Reg)
+  {
+    _info("Program compiled with 'register' attribute\n");
+  }
+  else
+  {
+    _info("Program compiled without 'register' attribute\n");
+  }
+  _info("Using %s, HZ=%d\n", CLOCK_TYPE, HZ);
+  _info("\n");
+
+  Done = false;
+  while (!Done) {
+    _info("Trying %d runs through Dhrystone:\n", Number_Of_Runs);
+
+    /***************/
+    /* Start timer */
+    /***************/
+
+    setStats(1);
+    Start_Timer();
+
+    for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+    {
+
+      Proc_5();
+      Proc_4();
+	/* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+      Int_1_Loc = 2;
+      Int_2_Loc = 3;
+      strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+      Enum_Loc = Ident_2;
+      Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+	/* Bool_Glob == 1 */
+      while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+      {
+	Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+	  /* Int_3_Loc == 7 */
+	Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+	  /* Int_3_Loc == 7 */
+	Int_1_Loc += 1;
+      } /* while */
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+	/* Int_Glob == 5 */
+      Proc_1 (Ptr_Glob);
+      for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+			       /* loop body executed twice */
+      {
+	if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+	    /* then, not executed */
+	  {
+	  Proc_6 (Ident_1, &Enum_Loc);
+	  strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+	  Int_2_Loc = Run_Index;
+	  Int_Glob = Run_Index;
+	  }
+      }
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Int_2_Loc = Int_2_Loc * Int_1_Loc;
+      Int_1_Loc = Int_2_Loc / Int_3_Loc;
+      Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+	/* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+      Proc_2 (&Int_1_Loc);
+	/* Int_1_Loc == 5 */
+
+    } /* loop "for Run_Index" */
+
+    /**************/
+    /* Stop timer */
+    /**************/
+
+    Stop_Timer();
+    setStats(0);
+
+    User_Time = End_Time - Begin_Time;
+
+    if (User_Time < Too_Small_Time)
+    {
+      _info("Measured time too small to obtain meaningful results\n");
+      Number_Of_Runs = Number_Of_Runs * 10;
+      _info("\n");
+    } else Done = true;
+  }
+
+  _info("Final values of the variables used in the benchmark:\n");
+  _info("\n");
+  _info("Int_Glob:            %d\n", Int_Glob);
+  _info("        should be:   %d\n", 5);
+  _info("Bool_Glob:           %d\n", Bool_Glob);
+  _info("        should be:   %d\n", 1);
+  _info("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  _info("        should be:   %c\n", 'A');
+  _info("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  _info("        should be:   %c\n", 'B');
+  _info("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  _info("        should be:   %d\n", 7);
+  _info("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  _info("        should be:   Number_Of_Runs + 10\n");
+  _info("Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent)\n");
+  _info("  Discr:             %d\n", Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 2);
+  _info("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 17);
+  _info("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Next_Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Next_Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent), same as above\n");
+  _info("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 1);
+  _info("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 18);
+  _info("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Int_1_Loc:           %d\n", Int_1_Loc);
+  _info("        should be:   %d\n", 5);
+  _info("Int_2_Loc:           %d\n", Int_2_Loc);
+  _info("        should be:   %d\n", 13);
+  _info("Int_3_Loc:           %d\n", Int_3_Loc);
+  _info("        should be:   %d\n", 7);
+  _info("Enum_Loc:            %d\n", Enum_Loc);
+  _info("        should be:   %d\n", 1);
+  _info("Str_1_Loc:           %s\n", Str_1_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  _info("Str_2_Loc:           %s\n", Str_2_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  _info("\n");
+
+
+  Microseconds = ((User_Time / Number_Of_Runs) * Mic_secs_Per_Second) / HZ;
+  Dhrystones_Per_Second = (HZ * Number_Of_Runs) / User_Time;
+
+  _info("Microseconds for one run through Dhrystone: %ld\n", Microseconds);
+  _info("Dhrystones per Second:                      %ld\n", Dhrystones_Per_Second);
+
+  return 0;
+}
+
+
+
diff -Naur apps-12.11/testing/sched/smp/smp_main.c apps/testing/sched/smp/smp_main.c
--- apps-12.11/testing/sched/smp/smp_main.c	2025-03-03 14:57:07.000000000 +0200
+++ apps/testing/sched/smp/smp_main.c	2025-12-06 13:58:31.764090884 +0200
@@ -31,12 +31,14 @@
 #include <pthread.h>
 #include <string.h>
 
+#include <nuttx/semaphore.h>
+
 /****************************************************************************
  * Pre-processor Definitions
  ****************************************************************************/
 
-#define HOG_MSEC       1000
-#define YIELD_MSEC     100
+#define HOG_MSEC       10 //1000
+#define YIELD_MSEC     10 //100
 #define IMPOSSIBLE_CPU -1
 
 /****************************************************************************
@@ -50,6 +52,14 @@
  * Private Functions
  ****************************************************************************/
 
+sem_t nsem;
+#define dbginfo(str, ...) \
+       do { \
+               nxsem_wait(&nsem); \
+               _info(str, ##__VA_ARGS__); \
+               nxsem_post(&nsem); \
+       } while(0);
+
 /****************************************************************************
  * Name: show_cpu / show_cpu_conditional
  *
@@ -206,6 +216,9 @@
   int ret;
   int i;
 
+  // do not print before this
+  nxsem_init(&nsem, 0, 1);
+
   /* Initialize data */
 
   memset(threadid,
diff -Naur apps-12.11/testing/sched/smp/smp_main-dhrystone.c apps/testing/sched/smp/smp_main-dhrystone.c
--- apps-12.11/testing/sched/smp/smp_main-dhrystone.c	1970-01-01 02:00:00.000000000 +0200
+++ apps/testing/sched/smp/smp_main-dhrystone.c	2025-12-06 13:59:12.999886815 +0200
@@ -0,0 +1,607 @@
+// See LICENSE for license details.
+/****************************************************************************
+ * Included Files
+ ****************************************************************************/
+
+#include <sched.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <string.h>
+#include <debug.h>
+#include <math.h>
+
+extern int tints;
+
+//**************************************************************************
+// Dhrystone bencmark
+//--------------------------------------------------------------------------
+//
+// This is the classic Dhrystone synthetic integer benchmark.
+//
+
+#pragma GCC optimize ("no-inline")
+
+#include "dhrystone.h"
+
+#include <alloca.h>
+
+int core_main(int argc, char *argv[]);
+
+#define setStats(x)
+
+#define read_csr(reg) ({ unsigned long __tmp; \
+  asm volatile ("csrr %0, " #reg : "=r"(__tmp)); \
+  __tmp; })
+
+/* Global Variables: */
+
+Rec_Pointer     Ptr_Glob,
+                Next_Ptr_Glob;
+int             Int_Glob;
+Boolean         Bool_Glob;
+char            Ch_1_Glob,
+                Ch_2_Glob;
+int             Arr_1_Glob [50];
+int             Arr_2_Glob [50] [50];
+
+Proc_7 (Int_1_Par_Val, Int_2_Par_Val, Int_Par_Ref)
+/**********************************************/
+    /* executed three times                                      */
+    /* first call:      Int_1_Par_Val == 2, Int_2_Par_Val == 3,  */
+    /*                  Int_Par_Ref becomes 7                    */
+    /* second call:     Int_1_Par_Val == 10, Int_2_Par_Val == 5, */
+    /*                  Int_Par_Ref becomes 17                   */
+    /* third call:      Int_1_Par_Val == 6, Int_2_Par_Val == 10, */
+    /*                  Int_Par_Ref becomes 18                   */
+One_Fifty       Int_1_Par_Val;
+One_Fifty       Int_2_Par_Val;
+One_Fifty      *Int_Par_Ref;
+{
+  One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 2;
+  *Int_Par_Ref = Int_2_Par_Val + Int_Loc;
+} /* Proc_7 */
+
+
+Proc_3 (Ptr_Ref_Par)
+/******************/
+    /* executed once */
+    /* Ptr_Ref_Par becomes Ptr_Glob */
+
+Rec_Pointer *Ptr_Ref_Par;
+
+{
+  if (Ptr_Glob != Null)
+    /* then, executed */
+    *Ptr_Ref_Par = Ptr_Glob->Ptr_Comp;
+  Proc_7 (10, Int_Glob, &Ptr_Glob->variant.var_1.Int_Comp);
+} /* Proc_3 */
+
+
+Proc_4 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Boolean Bool_Loc;
+
+  Bool_Loc = Ch_1_Glob == 'A';
+  Bool_Glob = Bool_Loc | Bool_Glob;
+  Ch_2_Glob = 'B';
+} /* Proc_4 */
+
+
+Proc_5 () /* without parameters */
+/*******/
+    /* executed once */
+{
+  Ch_1_Glob = 'A';
+  Bool_Glob = false;
+} /* Proc_5 */
+
+// dhrystone.c
+#ifndef REG
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+#undef REG
+#define REG register
+#endif
+
+extern  int     Int_Glob;
+extern  char    Ch_1_Glob;
+
+Boolean Func_3 (Enum_Par_Val)
+/***************************/
+    /* executed once        */
+    /* Enum_Par_Val == Ident_3 */
+Enumeration Enum_Par_Val;
+{
+  Enumeration Enum_Loc;
+
+  Enum_Loc = Enum_Par_Val;
+  if (Enum_Loc == Ident_3)
+    /* then, executed */
+    return (true);
+  else /* not executed */
+    return (false);
+} /* Func_3 */
+
+Proc_6 (Enum_Val_Par, Enum_Ref_Par)
+/*********************************/
+    /* executed once */
+    /* Enum_Val_Par == Ident_3, Enum_Ref_Par becomes Ident_2 */
+
+Enumeration  Enum_Val_Par;
+Enumeration *Enum_Ref_Par;
+{
+  *Enum_Ref_Par = Enum_Val_Par;
+  if (! Func_3 (Enum_Val_Par))
+    /* then, not executed */
+    *Enum_Ref_Par = Ident_4;
+  switch (Enum_Val_Par)
+  {
+    case Ident_1: 
+      *Enum_Ref_Par = Ident_1;
+      break;
+    case Ident_2: 
+      if (Int_Glob > 100)
+        /* then */
+      *Enum_Ref_Par = Ident_1;
+      else *Enum_Ref_Par = Ident_4;
+      break;
+    case Ident_3: /* executed */
+      *Enum_Ref_Par = Ident_2;
+      break;
+    case Ident_4: break;
+    case Ident_5: 
+      *Enum_Ref_Par = Ident_3;
+      break;
+  } /* switch */
+} /* Proc_6 */
+
+Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)
+/*********************************************************************/
+    /* executed once      */
+    /* Int_Par_Val_1 == 3 */
+    /* Int_Par_Val_2 == 7 */
+Arr_1_Dim       Arr_1_Par_Ref;
+Arr_2_Dim       Arr_2_Par_Ref;
+int             Int_1_Par_Val;
+int             Int_2_Par_Val;
+{
+  REG One_Fifty Int_Index;
+  REG One_Fifty Int_Loc;
+
+  Int_Loc = Int_1_Par_Val + 5;
+  Arr_1_Par_Ref [Int_Loc] = Int_2_Par_Val;
+  Arr_1_Par_Ref [Int_Loc+1] = Arr_1_Par_Ref [Int_Loc];
+  Arr_1_Par_Ref [Int_Loc+30] = Int_Loc;
+  for (Int_Index = Int_Loc; Int_Index <= Int_Loc+1; ++Int_Index)
+    Arr_2_Par_Ref [Int_Loc] [Int_Index] = Int_Loc;
+  Arr_2_Par_Ref [Int_Loc] [Int_Loc-1] += 1;
+  Arr_2_Par_Ref [Int_Loc+20] [Int_Loc] = Arr_1_Par_Ref [Int_Loc];
+  Int_Glob = 5;
+} /* Proc_8 */
+
+Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)
+/*************************************************/
+    /* executed three times                                         */
+    /* first call:      Ch_1_Par_Val == 'H', Ch_2_Par_Val == 'R'    */
+    /* second call:     Ch_1_Par_Val == 'A', Ch_2_Par_Val == 'C'    */
+    /* third call:      Ch_1_Par_Val == 'B', Ch_2_Par_Val == 'C'    */
+
+Capital_Letter   Ch_1_Par_Val;
+Capital_Letter   Ch_2_Par_Val;
+{
+  Capital_Letter        Ch_1_Loc;
+  Capital_Letter        Ch_2_Loc;
+
+  Ch_1_Loc = Ch_1_Par_Val;
+  Ch_2_Loc = Ch_1_Loc;
+  if (Ch_2_Loc != Ch_2_Par_Val)
+    /* then, executed */
+    return (Ident_1);
+  else  /* not executed */
+  {
+    Ch_1_Glob = Ch_1_Loc;
+    return (Ident_2);
+   }
+} /* Func_1 */
+
+Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)
+/*************************************************/
+    /* executed once */
+    /* Str_1_Par_Ref == "DHRYSTONE PROGRAM, 1'ST STRING" */
+    /* Str_2_Par_Ref == "DHRYSTONE PROGRAM, 2'ND STRING" */
+
+Str_30  Str_1_Par_Ref;
+Str_30  Str_2_Par_Ref;
+{
+  REG One_Thirty        Int_Loc;
+      Capital_Letter    Ch_Loc;
+
+  Int_Loc = 2;
+  while (Int_Loc <= 2) /* loop body executed once */
+    if (Func_1 (Str_1_Par_Ref[Int_Loc],
+                Str_2_Par_Ref[Int_Loc+1]) == Ident_1)
+      /* then, executed */
+    {
+      Ch_Loc = 'A';
+      Int_Loc += 1;
+    } /* if, while */
+  if (Ch_Loc >= 'W' && Ch_Loc < 'Z')
+    /* then, not executed */
+    Int_Loc = 7;
+  if (Ch_Loc == 'R')
+    /* then, not executed */
+    return (true);
+  else /* executed */
+  {
+    if (strcmp (Str_1_Par_Ref, Str_2_Par_Ref) > 0)
+      /* then, not executed */
+    {
+      Int_Loc += 7;
+      Int_Glob = Int_Loc;
+      return (true);
+    }
+    else /* executed */
+      return (false);
+  } /* if Ch_Loc */
+} /* Func_2 */
+
+// end of dhrystone.c
+
+Enumeration     Func_1 ();
+  /* forward declaration necessary since Enumeration may not simply be int */
+
+#ifndef REG
+        Boolean Reg = false;
+#define REG
+        /* REG becomes defined as empty */
+        /* i.e. no register variables   */
+#else
+        Boolean Reg = true;
+#undef REG
+#define REG register
+#endif
+
+Boolean		Done;
+
+long            Begin_Time,
+                End_Time,
+                User_Time;
+long            Microseconds,
+                Dhrystones_Per_Second;
+
+/* end of variables for time measurement */
+
+
+
+Proc_1 (Ptr_Val_Par)
+/******************/
+
+REG Rec_Pointer Ptr_Val_Par;
+    /* executed once */
+{
+  REG Rec_Pointer Next_Record = Ptr_Val_Par->Ptr_Comp;  
+                                        /* == Ptr_Glob_Next */
+  /* Local variable, initialized with Ptr_Val_Par->Ptr_Comp,    */
+  /* corresponds to "rename" in Ada, "with" in Pascal           */
+  
+  structassign (*Ptr_Val_Par->Ptr_Comp, *Ptr_Glob); 
+  Ptr_Val_Par->variant.var_1.Int_Comp = 5;
+  Next_Record->variant.var_1.Int_Comp 
+        = Ptr_Val_Par->variant.var_1.Int_Comp;
+  Next_Record->Ptr_Comp = Ptr_Val_Par->Ptr_Comp;
+  Proc_3 (&Next_Record->Ptr_Comp);
+    /* Ptr_Val_Par->Ptr_Comp->Ptr_Comp 
+                        == Ptr_Glob->Ptr_Comp */
+  if (Next_Record->Discr == Ident_1)
+    /* then, executed */
+  {
+    Next_Record->variant.var_1.Int_Comp = 6;
+    Proc_6 (Ptr_Val_Par->variant.var_1.Enum_Comp, 
+           &Next_Record->variant.var_1.Enum_Comp);
+    Next_Record->Ptr_Comp = Ptr_Glob->Ptr_Comp;
+    Proc_7 (Next_Record->variant.var_1.Int_Comp, 10, 
+           &Next_Record->variant.var_1.Int_Comp);
+  }
+  else /* not executed */
+    structassign (*Ptr_Val_Par, *Ptr_Val_Par->Ptr_Comp);
+} /* Proc_1 */
+
+
+Proc_2 (Int_Par_Ref)
+/******************/
+    /* executed once */
+    /* *Int_Par_Ref == 1, becomes 4 */
+
+One_Fifty   *Int_Par_Ref;
+{
+  One_Fifty  Int_Loc;  
+  Enumeration   Enum_Loc;
+
+  Int_Loc = *Int_Par_Ref + 10;
+  do /* executed once */
+    if (Ch_1_Glob == 'A')
+      /* then, executed */
+    {
+      Int_Loc -= 1;
+      *Int_Par_Ref = Int_Loc - Int_Glob;
+      Enum_Loc = Ident_1;
+    } /* if */
+  while (Enum_Loc != Ident_1); /* true */
+} /* Proc_2 */
+
+
+#define wait_not_busy(baddr, status) \
+          do { \
+                nxsig_usleep(10); \
+                status = *(volatile int *)(baddr - 0x200); \
+                /*if(status & 0x100ff) _info("r status=%x\n", status);*/ \
+          } while ((status & 0x100ff))
+volatile unsigned char *baddr;
+unsigned char b[512]={0};
+void testsd()
+{
+        volatile int i, status=0;
+        baddr = 0x40008200;
+	int sector=4096, match=1;
+
+      for(i = 0; i < 0x200; i++)
+	      b[i] = i;
+      // fill hw buffer with user data
+      for(i = 0; i < 0x200; i++) {
+                *(volatile unsigned char*)(baddr+i) = b[i];
+        }
+      /* Then transfer the sector */
+      *(volatile int *)(baddr - 0x200 + 4) = sector;
+      // wait writing
+      wait_not_busy(baddr, status);
+
+      // read block 0 
+      sector = 0;
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = sector;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        b[i] = *(volatile unsigned char *)(baddr + i);
+      //_info("\nsector %d: ", sector);
+      //for(i=0; i<0x200; i++)
+      //       _info("b[%d]=%d ", i, b[i]);
+
+      // read block 4096
+      sector = 4096;
+      // tell hw what sector to read
+      *(volatile int *)(baddr - 0x200 + 0) = sector;
+      // wait for the hardware to fill its buffer
+      wait_not_busy(baddr, status);
+      for(i=0; i<0x200; i++)
+        b[i] = *(volatile unsigned char *)(baddr + i);
+
+      // check b[i]
+      //_info("\nsector %d: ", sector);
+      //for(i=0; i<0x200; i++)
+      //        _info("b[%d]=%d ", i, b[i]);
+      match = 1;
+      for(i=0; i<0x200; i++)
+	if(b[i] != (unsigned char)i)
+		match = 0;
+      if(match)
+	     	_info("block match\n");
+      else
+		_info("block unmatch\n");
+}
+
+int t0=0, t1=0;
+
+int sdc_main(void);
+int main(int argc, FAR char *argv[])
+/*****/
+  /* main program, corresponds to procedures        */
+  /* Main and Proc_0 in the Ada version             */
+{
+
+	//sdc_main();
+	//testsd();
+
+#if 0
+  float a=1.5, b=2.6;
+  _info("a+b=%f\n", a*b);
+  while(1);
+#endif
+
+        One_Fifty       Int_1_Loc;
+  REG   One_Fifty       Int_2_Loc;
+        One_Fifty       Int_3_Loc;
+  REG   char            Ch_Index;
+        Enumeration     Enum_Loc;
+        Str_30          Str_1_Loc;
+        Str_30          Str_2_Loc;
+  REG   int             Run_Index;
+  REG   int             Number_Of_Runs;
+
+  /* Arguments */
+  Number_Of_Runs = NUMBER_OF_RUNS;
+
+  /* Initializations */
+
+  Next_Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+  Ptr_Glob = (Rec_Pointer) alloca (sizeof (Rec_Type));
+
+  Ptr_Glob->Ptr_Comp                    = Next_Ptr_Glob;
+  Ptr_Glob->Discr                       = Ident_1;
+  Ptr_Glob->variant.var_1.Enum_Comp     = Ident_3;
+  Ptr_Glob->variant.var_1.Int_Comp      = 40;
+  strcpy (Ptr_Glob->variant.var_1.Str_Comp, 
+          "DHRYSTONE PROGRAM, SOME STRING");
+  strcpy (Str_1_Loc, "DHRYSTONE PROGRAM, 1'ST STRING");
+
+  Arr_2_Glob [8][7] = 10;
+        /* Was missing in published program. Without this statement,    */
+        /* Arr_2_Glob [8][7] would have an undefined value.             */
+        /* Warning: With 16-Bit processors and Number_Of_Runs > 32000,  */
+        /* overflow may occur for this array element.                   */
+
+  _info("\n");
+  _info("Dhrystone Benchmark, Version %s\n", Version);
+  if (Reg)
+  {
+    _info("Program compiled with 'register' attribute\n");
+  }
+  else
+  {
+    _info("Program compiled without 'register' attribute\n");
+  }
+  _info("Using %s, HZ=%d\n", CLOCK_TYPE, HZ);
+  _info("\n");
+
+  Done = false;
+  while (!Done) {
+    _info("Trying %d runs through Dhrystone:\n", Number_Of_Runs);
+
+    /***************/
+    /* Start timer */
+    /***************/
+
+    setStats(1);
+    Start_Timer();
+    t0 = read_csr(mcycle);
+
+    for (Run_Index = 1; Run_Index <= Number_Of_Runs; ++Run_Index)
+    {
+
+      Proc_5();
+      Proc_4();
+	/* Ch_1_Glob == 'A', Ch_2_Glob == 'B', Bool_Glob == true */
+      Int_1_Loc = 2;
+      Int_2_Loc = 3;
+      strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 2'ND STRING");
+      Enum_Loc = Ident_2;
+      Bool_Glob = ! Func_2 (Str_1_Loc, Str_2_Loc);
+	/* Bool_Glob == 1 */
+      while (Int_1_Loc < Int_2_Loc)  /* loop body executed once */
+      {
+	Int_3_Loc = 5 * Int_1_Loc - Int_2_Loc;
+	  /* Int_3_Loc == 7 */
+	Proc_7 (Int_1_Loc, Int_2_Loc, &Int_3_Loc);
+	  /* Int_3_Loc == 7 */
+	Int_1_Loc += 1;
+      } /* while */
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Proc_8 (Arr_1_Glob, Arr_2_Glob, Int_1_Loc, Int_3_Loc);
+	/* Int_Glob == 5 */
+      Proc_1 (Ptr_Glob);
+      for (Ch_Index = 'A'; Ch_Index <= Ch_2_Glob; ++Ch_Index)
+			       /* loop body executed twice */
+      {
+	if (Enum_Loc == Func_1 (Ch_Index, 'C'))
+	    /* then, not executed */
+	  {
+	  Proc_6 (Ident_1, &Enum_Loc);
+	  strcpy (Str_2_Loc, "DHRYSTONE PROGRAM, 3'RD STRING");
+	  Int_2_Loc = Run_Index;
+	  Int_Glob = Run_Index;
+	  }
+      }
+	/* Int_1_Loc == 3, Int_2_Loc == 3, Int_3_Loc == 7 */
+      Int_2_Loc = Int_2_Loc * Int_1_Loc;
+      Int_1_Loc = Int_2_Loc / Int_3_Loc;
+      Int_2_Loc = 7 * (Int_2_Loc - Int_3_Loc) - Int_1_Loc;
+	/* Int_1_Loc == 1, Int_2_Loc == 13, Int_3_Loc == 7 */
+      Proc_2 (&Int_1_Loc);
+	/* Int_1_Loc == 5 */
+
+    } /* loop "for Run_Index" */
+
+    /**************/
+    /* Stop timer */
+    /**************/
+
+    Stop_Timer();
+    t1 = read_csr(mcycle);
+    setStats(0);
+
+    User_Time = t1 - t0; // End_Time - Begin_Time;
+
+    if (User_Time < Too_Small_Time)
+    {
+      _info("Measured time %d too small to obtain meaningful results %d\n", User_Time, Too_Small_Time);
+      Number_Of_Runs = Number_Of_Runs * 10;
+      _info("\n");
+    } else Done = true;
+  }
+
+  _info("Final values of the variables used in the benchmark:\n");
+  _info("\n");
+  _info("Int_Glob:            %d\n", Int_Glob);
+  _info("        should be:   %d\n", 5);
+  _info("Bool_Glob:           %d\n", Bool_Glob);
+  _info("        should be:   %d\n", 1);
+  _info("Ch_1_Glob:           %c\n", Ch_1_Glob);
+  _info("        should be:   %c\n", 'A');
+  _info("Ch_2_Glob:           %c\n", Ch_2_Glob);
+  _info("        should be:   %c\n", 'B');
+  _info("Arr_1_Glob[8]:       %d\n", Arr_1_Glob[8]);
+  _info("        should be:   %d\n", 7);
+  _info("Arr_2_Glob[8][7]:    %d\n", Arr_2_Glob[8][7]);
+  _info("        should be:   Number_Of_Runs + 10\n");
+  _info("Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent)\n");
+  _info("  Discr:             %d\n", Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 2);
+  _info("  Int_Comp:          %d\n", Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 17);
+  _info("  Str_Comp:          %s\n", Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Next_Ptr_Glob->\n");
+  _info("  Ptr_Comp:          %d\n", (long) Next_Ptr_Glob->Ptr_Comp);
+  _info("        should be:   (implementation-dependent), same as above\n");
+  _info("  Discr:             %d\n", Next_Ptr_Glob->Discr);
+  _info("        should be:   %d\n", 0);
+  _info("  Enum_Comp:         %d\n", Next_Ptr_Glob->variant.var_1.Enum_Comp);
+  _info("        should be:   %d\n", 1);
+  _info("  Int_Comp:          %d\n", Next_Ptr_Glob->variant.var_1.Int_Comp);
+  _info("        should be:   %d\n", 18);
+  _info("  Str_Comp:          %s\n",
+                                Next_Ptr_Glob->variant.var_1.Str_Comp);
+  _info("        should be:   DHRYSTONE PROGRAM, SOME STRING\n");
+  _info("Int_1_Loc:           %d\n", Int_1_Loc);
+  _info("        should be:   %d\n", 5);
+  _info("Int_2_Loc:           %d\n", Int_2_Loc);
+  _info("        should be:   %d\n", 13);
+  _info("Int_3_Loc:           %d\n", Int_3_Loc);
+  _info("        should be:   %d\n", 7);
+  _info("Enum_Loc:            %d\n", Enum_Loc);
+  _info("        should be:   %d\n", 1);
+  _info("Str_1_Loc:           %s\n", Str_1_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 1'ST STRING\n");
+  _info("Str_2_Loc:           %s\n", Str_2_Loc);
+  _info("        should be:   DHRYSTONE PROGRAM, 2'ND STRING\n");
+  _info("\n");
+
+
+  Microseconds = ((User_Time / Number_Of_Runs) * Mic_secs_Per_Second) / HZ;
+  Dhrystones_Per_Second = (HZ * Number_Of_Runs) / User_Time;
+
+  _info("Microseconds for one run through Dhrystone: %ld\n", Microseconds);
+  _info("Dhrystones per Second:                      %ld\n", Dhrystones_Per_Second);
+
+  //int tints=0;
+  _info("tints=%d, t1=%d, t0=%d\n", tints, t1, t0);
+
+  core_main(0, 0);
+
+  _info("tints=%d\n", tints);
+
+  return 0;
+}
+
